; ModuleID = 'fs/io_uring.c'
source_filename = "fs/io_uring.c"
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

module asm ".section\09\22.initcall6.init\22, \22a\22\09\09"
module asm "__initcall__kmod_io_uring__915_11013_io_uring_init6:\09\09\09"
module asm ".long\09io_uring_init - .\09"
module asm ".previous\09\09\09\09\09"

%struct.kmem_cache = type opaque
%struct.static_key_false = type { %struct.static_key }
%struct.static_key = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.workqueue_struct = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.kiocb*, i1)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i64, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, i64, i32)* }
%struct.module = type opaque
%struct.file = type { %union.anon.11, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, %struct.hlist_head*, %struct.address_space*, i32, i32 }
%union.anon.11 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type { %struct.dentry*, %struct.super_block*, i32, %struct.user_namespace* }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.xattr_handler**, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, i8*, i32, i64, i64, [32 x i8], %struct.uuid_t, i32, i32, %struct.mutex, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, %struct.atomic64_t, i32, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [60 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, i32 (%struct.fs_context*)*, %struct.fs_parameter_spec*, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.fs_context = type opaque
%struct.fs_parameter_spec = type opaque
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type { i64, i64, i64, i64, i32, i8 }
%struct.kstatfs = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.shrink_control = type { i32, i32, i64, i64, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.inode*, i64*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.spinlock, %struct.atomic_t, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.16, i32 }
%union.anon.16 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.atomic64_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %union.anon.8 }
%union.anon.8 = type { %struct.atomic_t }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.block_device = type { i64, %struct.disk_stats*, i64, i8, i32, i32, %struct.inode*, %struct.super_block*, i8*, %struct.device, i8*, i32, i8, %struct.kobject*, i8, %struct.spinlock, %struct.gendisk*, i32, %struct.mutex, %struct.super_block*, %struct.partition_meta_info* }
%struct.disk_stats = type opaque
%struct.device = type { %struct.kobject, %struct.device*, %struct.device_private*, i8*, %struct.device_type*, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.mutex, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.raw_spinlock, %struct.list_head, i64*, i64, i64, %struct.bus_dma_region*, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.io_tlb_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.dev_iommu*, i32, i8 }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [64 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.attribute_group**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)*, void (%struct.kobject*, %struct.kuid_t*, %struct.kgid_t*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.atomic_t, i32, %struct.sk_buff_head, %struct.sk_buff*, %struct.sk_buff_head, %struct.anon.143, i32, i32, %struct.sk_filter*, %union.anon.144, %struct.dst_entry*, %struct.dst_entry*, %struct.atomic_t, i32, i32, %struct.refcount_struct, i64, %union.anon.164, %struct.sk_buff*, %struct.sk_buff_head, i32, i32, i32, i32, i64, %struct.timer_list, i32, i32, i64, i64, %struct.page_frag, i64, i64, i64, i32, i32, i32, i32, i8, i8, i16, i16, i16, i64, %struct.proto*, %struct.rwlock_t, i32, i32, i32, i32, %struct.kuid_t, %struct.spinlock, %struct.pid*, %struct.cred*, i64, i64, i16, i32, i8, i32, %struct.atomic_t, i8, i8, %struct.socket*, i8*, %struct.sock_cgroup_data, %struct.mem_cgroup*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, %struct.sock_reuseport*, %struct.callback_head }
%struct.sock_common = type { %union.anon, %union.anon.0, %union.anon.1, i16, i8, i8, i32, %union.anon.3, %struct.proto*, %struct.possible_net_t, %struct.atomic64_t, %union.anon.139, [0 x i32], %union.anon.140, i16, %union.anon.141, %struct.refcount_struct, [0 x i32], %union.anon.142 }
%union.anon = type { i64 }
%union.anon.0 = type { i32 }
%union.anon.1 = type { i32 }
%union.anon.3 = type { %struct.hlist_node }
%struct.possible_net_t = type {}
%union.anon.139 = type { i64 }
%union.anon.140 = type { %struct.hlist_node }
%union.anon.141 = type { i32 }
%union.anon.142 = type { i32 }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.wait_queue_head }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.anon.143 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.refcount_struct, %struct.callback_head, %struct.bpf_prog* }
%struct.bpf_prog = type { i16, i16, i32, i32, i32, i32, [8 x i8], %struct.bpf_prog_stats*, i32*, i32 (i8*, %struct.bpf_insn*)*, %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, [0 x %struct.sock_filter], [0 x %struct.bpf_insn] }
%struct.bpf_prog_stats = type { i64, i64, i64, %struct.u64_stats_sync, [8 x i8] }
%struct.u64_stats_sync = type {}
%struct.bpf_insn = type { i8, i8, i16, i32 }
%struct.bpf_prog_aux = type { %struct.atomic64_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, %struct.bpf_ctx_arg_aux*, %struct.mutex, %struct.bpf_prog*, %struct.bpf_trampoline*, i32, i32, i8, i8, i8, i8, i8, i8, %struct.hlist_node, %struct.btf_type*, i8*, %struct.bpf_prog**, i8*, %struct.bpf_jit_poke_descriptor*, %struct.bpf_kfunc_desc_tab*, i32, %struct.bpf_ksym, %struct.bpf_prog_ops*, %struct.bpf_map**, %struct.mutex, %struct.btf_mod_pair*, %struct.bpf_prog*, %struct.user_struct*, i64, [2 x %struct.bpf_map*], [16 x i8], %struct.bpf_prog_offload*, %struct.btf*, %struct.bpf_func_info*, %struct.bpf_func_info_aux*, %struct.bpf_line_info*, i8**, i32, i32, i32, i32, %struct.exception_table_entry*, %union.anon.92 }
%struct.bpf_ctx_arg_aux = type { i32, i32, i32 }
%struct.bpf_trampoline = type { %struct.hlist_node, %struct.mutex, %struct.refcount_struct, i64, %struct.anon.62, %struct.bpf_prog*, [3 x %struct.hlist_head], [3 x i32], %struct.bpf_tramp_image*, i64, %struct.module* }
%struct.anon.62 = type { %struct.btf_func_model, i8*, i8 }
%struct.btf_func_model = type { i8, i8, [12 x i8] }
%struct.bpf_tramp_image = type { i8*, %struct.bpf_ksym, %struct.percpu_ref, i8*, i8*, %union.anon.63 }
%struct.percpu_ref = type { i64, %struct.percpu_ref_data* }
%struct.percpu_ref_data = type { %struct.atomic64_t, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head, %struct.percpu_ref* }
%union.anon.63 = type { %struct.work_struct }
%struct.btf_type = type opaque
%struct.bpf_jit_poke_descriptor = type { i8*, i8*, i8*, i8*, %union.anon.64, i8, i8, i16, i32 }
%union.anon.64 = type { %struct.anon.65 }
%struct.anon.65 = type { %struct.bpf_map*, i32 }
%struct.bpf_map = type { %struct.bpf_map_ops*, %struct.bpf_map*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, [16 x i8], i32, i8, i8, [34 x i8], %struct.atomic64_t, %struct.atomic64_t, %struct.work_struct, %struct.mutex, i64, [40 x i8] }
%struct.bpf_map_ops = type { i32 (%union.bpf_attr*)*, %struct.bpf_map* (%union.bpf_attr*)*, void (%struct.bpf_map*, %struct.file*)*, void (%struct.bpf_map*)*, i32 (%struct.bpf_map*, i8*, i8*)*, void (%struct.bpf_map*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, %struct.file*, i32)*, void (i8*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (i8*)*, void (%struct.bpf_map*, i8*, %struct.seq_file*)*, i32 (%struct.bpf_map*, %struct.btf*, %struct.btf_type*, %struct.btf_type*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64, i32*)*, i32 (%struct.bpf_map*, %struct.vm_area_struct*)*, i32 (%struct.bpf_map*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.bpf_local_storage_map*, i8*, i32)*, void (%struct.bpf_local_storage_map*, i8*, i32)*, %struct.bpf_local_storage** (i8*)*, i32 (%struct.bpf_map*, i32, i64)*, i1 (%struct.bpf_map*, %struct.bpf_map*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i8*, i32*, %struct.bpf_iter_seq_info* }
%union.bpf_attr = type { %struct.anon.70 }
%struct.anon.70 = type { i32, i32, i64, i64, i32, i32, i64, i32, i32, [16 x i8], i32, i32, i32, i32, i64, i32, i32, i64, i32, i32, %union.anon.71, i32, i64 }
%union.anon.71 = type { i32 }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot_t, i64, %struct.anon.113, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.vm_userfaultfd_ctx }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.mm_struct = type { %struct.anon.17, [0 x i64] }
%struct.anon.17 = type { %struct.vm_area_struct*, %struct.rb_root, i64, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, %struct.atomic64_t, i64, i64, i64, i64, %struct.seqcount, %struct.spinlock, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.atomic_t, %struct.uprobes_state, %struct.work_struct }
%struct.rb_root = type { %struct.rb_node* }
%struct.pgd_t = type { i64 }
%struct.seqcount = type { i32 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.atomic64_t, %struct.refcount_struct, i8*, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.task_struct = type { %struct.thread_info, i32, i8*, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, i32, i32, %struct.cpumask*, %struct.cpumask*, %struct.cpumask, i8*, i16, i16, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.pid*, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i8*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.posix_cputimers, %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.fs_struct*, %struct.files_struct*, %struct.io_uring_task*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, %struct.task_struct*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.kernel_siginfo*, %struct.task_io_accounting, %struct.robust_list_head*, %struct.list_head, %struct.futex_pi_state*, %struct.mutex, i32, %struct.rseq*, i32, i64, %struct.tlbflush_unmap_batch, %union.anon.109, %struct.pipe_inode_info*, %struct.page_frag, i32, i32, i64, i64, i64, %struct.kmap_ctrl, i32, %struct.task_struct*, %struct.refcount_struct, %struct.thread_struct, [16 x i8] }
%struct.thread_info = type { i64, %union.anon.18 }
%union.anon.18 = type { i64 }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.20, i16, i16 }
%struct.llist_node = type { %struct.llist_node* }
%union.anon.20 = type { i32 }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, [24 x i8], %struct.sched_avg }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type {}
%struct.sched_avg = type { i64, i64, i64, i32, i32, i64, i64, i64, %struct.util_est }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, %struct.sched_dl_entity* }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.seqcount_raw_spinlock, %struct.hrtimer*, %struct.timerqueue_head, i64 ()*, i64 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i64, %struct.hrtimer*, i64, %struct.hrtimer*, [8 x i8], [8 x %struct.hrtimer_clock_base] }
%struct.seqcount_raw_spinlock = type { %struct.seqcount }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.cpumask = type { [4 x i64] }
%struct.sched_info = type {}
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64, i64 (%struct.restart_block*)*, %union.anon.21 }
%union.anon.21 = type { %struct.anon.22 }
%struct.anon.22 = type { i32*, i32, i32, i32, i64, i32* }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.nameidata = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type { %struct.atomic_t, i8, %struct.wait_queue_head, %struct.fdtable*, %struct.fdtable, [32 x i8], %struct.spinlock, i32, [1 x i64], [1 x i64], [1 x i64], [64 x %struct.file*], [32 x i8] }
%struct.fdtable = type { i32, %struct.file**, i64*, i64*, i64*, %struct.callback_head }
%struct.io_uring_task = type { i32, %struct.xarray, %struct.wait_queue_head, %struct.io_ring_ctx*, %struct.io_wq*, %struct.percpu_counter, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.io_wq_work_list, %struct.callback_head, i8 }
%struct.xarray = type { %struct.spinlock, i32, i8* }
%struct.io_ring_ctx = type { %struct.anon.31, %struct.anon.32, %struct.list_head, i32, %struct.cred*, %struct.io_sq_data*, %struct.wait_queue_head, %struct.list_head, i64, [40 x i8], %struct.anon.43, %struct.anon.44, %struct.io_restriction, %struct.anon.45, %struct.anon.46, [56 x i8] }
%struct.anon.31 = type { %struct.percpu_ref, %struct.io_rings*, i32, i8, [35 x i8] }
%struct.io_rings = type { %struct.io_uring, %struct.io_uring, i32, i32, i32, i32, i32, i32, i32, i32, [32 x i8], [0 x %struct.io_uring_cqe] }
%struct.io_uring = type { i32, [60 x i8], i32, [60 x i8] }
%struct.io_uring_cqe = type { i64, i32, i32 }
%struct.anon.32 = type { %struct.mutex, i32*, %struct.io_uring_sqe*, i32, i32, %struct.list_head, %struct.io_rsrc_node*, %struct.io_file_table, i32, i32, %struct.io_mapped_ubuf**, %struct.io_submit_state, %struct.list_head, %struct.list_head, %struct.list_head, %struct.xarray, %struct.xarray, i32, i32, [32 x i8] }
%struct.io_uring_sqe = type { i8, i8, i16, i32, %union.anon.33, %union.anon.34, i32, %union.anon.35, i64, %union.anon.36, i16, %union.anon.37, [2 x i64] }
%union.anon.33 = type { i64 }
%union.anon.34 = type { i64 }
%union.anon.35 = type { i32 }
%union.anon.36 = type { i16 }
%union.anon.37 = type { i32 }
%struct.io_rsrc_node = type { %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.io_rsrc_data*, %struct.llist_node, i8 }
%struct.io_rsrc_data = type { %struct.io_ring_ctx*, i64**, i32, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)*, %struct.atomic_t, %struct.completion, i8 }
%struct.io_rsrc_put = type { %struct.list_head, i64, %union.anon.38 }
%union.anon.38 = type { i8* }
%struct.io_file_table = type { %struct.io_fixed_file* }
%struct.io_fixed_file = type { i64 }
%struct.io_mapped_ubuf = type { i64, i64, i32, i64, [0 x %struct.bio_vec] }
%struct.bio_vec = type { %struct.page*, i32, i32 }
%struct.page = type { i64, %union.anon.5, %union.anon.134, %struct.atomic_t, [8 x i8] }
%union.anon.5 = type { %struct.anon.6 }
%struct.anon.6 = type { %struct.list_head, %struct.address_space*, i64, i64 }
%union.anon.134 = type { %struct.atomic_t }
%struct.io_submit_state = type { %struct.blk_plug, %struct.io_submit_link, [32 x i8*], i32, i8, [32 x %struct.io_kiocb*], i32, %struct.list_head, i32 }
%struct.blk_plug = type { %struct.list_head, %struct.list_head, i16, i8, i8 }
%struct.io_submit_link = type { %struct.io_kiocb*, %struct.io_kiocb* }
%struct.io_kiocb = type { %union.anon.39, i8*, i8, i8, i16, i32, %struct.io_ring_ctx*, i32, %struct.atomic_t, %struct.task_struct*, i64, %struct.io_kiocb*, %struct.percpu_ref*, %struct.list_head, %struct.io_task_work, %struct.hlist_node, %struct.async_poll*, %struct.io_wq_work, %struct.cred*, %struct.io_mapped_ubuf* }
%union.anon.39 = type { %struct.io_rw }
%struct.io_rw = type { %struct.kiocb, i64, i64 }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32, i16, i16, %union.anon.40 }
%union.anon.40 = type { %struct.wait_page_queue* }
%struct.wait_page_queue = type { %struct.page*, i32, %struct.wait_queue_entry }
%struct.wait_queue_entry = type { i32, i8*, i32 (%struct.wait_queue_entry*, i32, i32, i8*)*, %struct.list_head }
%struct.io_task_work = type { %union.anon.42, void (%struct.io_kiocb*, i8*)* }
%union.anon.42 = type { %struct.io_wq_work_node }
%struct.io_wq_work_node = type { %struct.io_wq_work_node* }
%struct.async_poll = type { %struct.io_poll_iocb, %struct.io_poll_iocb* }
%struct.io_poll_iocb = type { %struct.file*, %struct.wait_queue_head*, i32, i8, i8, %struct.wait_queue_entry }
%struct.io_wq_work = type { %struct.io_wq_work_node, i32 }
%struct.io_sq_data = type { %struct.refcount_struct, %struct.atomic_t, %struct.mutex, %struct.list_head, %struct.task_struct*, %struct.wait_queue_head, i32, i32, i32, i32, i64, %struct.completion }
%struct.anon.43 = type { i32, i32, %struct.eventfd_ctx*, %struct.wait_queue_head, %struct.wait_queue_head, i32, %struct.atomic_t, i32, [52 x i8] }
%struct.eventfd_ctx = type opaque
%struct.anon.44 = type { %struct.spinlock, %struct.spinlock, %struct.list_head, %struct.hlist_head*, i32, i8, [27 x i8] }
%struct.io_restriction = type { [1 x i64], [1 x i64], i8, i8, i8 }
%struct.anon.45 = type { %struct.io_rsrc_node*, %struct.io_mapped_ubuf*, %struct.io_rsrc_data*, %struct.io_rsrc_data*, %struct.delayed_work, %struct.llist_head, %struct.list_head, %struct.spinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.llist_head = type { %struct.llist_node* }
%struct.anon.46 = type { %struct.io_wq_hash*, %struct.user_struct*, %struct.mm_struct*, %struct.llist_head, %struct.delayed_work, %struct.work_struct, %struct.list_head, %struct.completion, [2 x i32], i8 }
%struct.io_wq_hash = type { %struct.refcount_struct, i64, %struct.wait_queue_head }
%struct.io_wq = type opaque
%struct.percpu_counter = type { %struct.raw_spinlock, i64, i32* }
%struct.io_wq_work_list = type { %struct.io_wq_work_node*, %struct.io_wq_work_node* }
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.time_namespace*, %struct.time_namespace*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.pid_namespace = type { %struct.idr, %struct.callback_head, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.user_namespace*, %struct.ucounts*, i32, %struct.ns_common }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, %struct.atomic_t, [12 x %struct.atomic64_t] }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32, %struct.refcount_struct }
%struct.proc_ns_operations = type opaque
%struct.net = type { %struct.refcount_struct, %struct.spinlock, i32, i32, i32, %struct.spinlock, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.llist_node, %struct.user_namespace*, %struct.ucounts*, %struct.idr, %struct.ns_common, %struct.list_head, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.uevent_sock*, %struct.hlist_head*, %struct.hlist_head*, %struct.raw_notifier_head, i32, %struct.net_device*, %struct.list_head, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, %struct.netns_nexthop, [16 x i8], %struct.netns_ipv4, %struct.net_generic*, %struct.netns_bpf, i64, %struct.sock*, [40 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.28, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.hlist_head }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.kgid_t = type { i32 }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.uevent_sock = type opaque
%struct.raw_notifier_head = type { %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.net_device = type { [16 x i8], %struct.netdev_name_node*, %struct.dev_ifalias*, i64, i64, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.145, i32, i32, %struct.net_device_ops*, i32, i16, i16, i32, i16, i16, i64, i64, i64, i64, i64, i64, i64, i32, i32, i16, i8, i8, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.ethtool_ops*, %struct.header_ops*, i8, i8, i8, i8, [32 x i8], i8, i8, i8, i8, i16, i16, i16, i16, %struct.spinlock, i32, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8, %struct.in_device*, %struct.inet6_dev*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, %struct.bpf_prog*, i64, i32, i32 (%struct.sk_buff**)*, i8*, %struct.netdev_queue*, [32 x i8], %struct.hlist_node, [40 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i32, %struct.spinlock, %struct.xdp_dev_bulk_queue*, %struct.timer_list, i32, i32, %struct.list_head, %struct.refcount_struct, %struct.list_head, i8, i8, i16, i8, void (%struct.net_device*)*, %struct.possible_net_t, i8*, i32, %union.anon.163, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i16, [16 x %struct.netdev_tc_txq], [16 x i8], %struct.phy_device*, %struct.sfp_bus*, %struct.lock_class_key*, %struct.lock_class_key*, i8, i8, %struct.list_head, %struct.udp_tunnel_nic_info*, %struct.udp_tunnel_nic*, [3 x %struct.bpf_xdp_entity] }
%struct.netdev_name_node = type { %struct.hlist_node, %struct.list_head, %struct.net_device*, i8* }
%struct.dev_ifalias = type { %struct.callback_head, [0 x i8] }
%struct.anon.145 = type { %struct.list_head, %struct.list_head }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, %struct.net_device*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.if_settings*)*, i32 (%struct.net_device*, %struct.ifreq*, i8*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_guid*, %struct.ifla_vf_guid*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, %struct.net_device*, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.net_device*)*, %struct.net_device* (%struct.net_device*, %struct.sk_buff*, i1)*, %struct.net_device* (%struct.net_device*, %struct.sock*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.sk_buff*, %struct.nlattr**, %struct.net_device*, i8*, i16, i32, i32, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_bpf*)*, i32 (%struct.net_device*, i32, %struct.xdp_frame**, i32)*, %struct.net_device* (%struct.net_device*, %struct.xdp_buff*)*, i32 (%struct.net_device*, i32, i32)*, %struct.devlink_port* (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ip_tunnel_parm*, i32)*, %struct.net_device* (%struct.net_device*)*, i32 (%struct.net_device_path_ctx*, %struct.net_device_path*)* }
%struct.ifreq = type { %union.anon.146, %union.anon.147 }
%union.anon.146 = type { [16 x i8] }
%union.anon.147 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.if_settings = type { i32, i32, %union.anon.148 }
%union.anon.148 = type { %struct.raw_hdlc_proto* }
%struct.raw_hdlc_proto = type { i16, i16 }
%struct.neigh_parms = type { %struct.possible_net_t, %struct.net_device*, %struct.list_head, i32 (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.refcount_struct, %struct.callback_head, i32, [13 x i32], [1 x i64] }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.refcount_struct, i32, %struct.sk_buff_head, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, i8, %struct.seqlock_t, [4 x i8], [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.list_head, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.seqlock_t = type { %struct.seqcount_spinlock, %struct.spinlock }
%struct.seqcount_spinlock = type { %struct.seqcount }
%struct.hh_cache = type { i32, %struct.seqlock_t, [4 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.neigh_table = type { i32, i32, i32, i16, i32 (i8*, %struct.net_device*, i32*)*, i1 (%struct.neighbour*, i8*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i32 (i8*)*, i1 (%struct.net_device*, %struct.netlink_ext_ack*)*, i8*, %struct.neigh_parms, %struct.list_head, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.atomic_t, %struct.list_head, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.possible_net_t, %struct.net_device*, i8, i8, [0 x i8] }
%struct.netlink_ext_ack = type { i8*, %struct.nlattr*, %struct.nla_policy*, [20 x i8], i8 }
%struct.nlattr = type { i16, i16 }
%struct.nla_policy = type { i8, i8, i16, %union.anon.60 }
%union.anon.60 = type { i8* }
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_guid = type { i32, i64 }
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, %struct.netlink_ext_ack*, i16, i16, i32, i32, i32, i8, %union.anon.149 }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%union.anon.149 = type { [6 x i64] }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.netdev_bpf = type { i32, %union.anon.150 }
%union.anon.150 = type { %struct.anon.151 }
%struct.anon.151 = type { i32, %struct.bpf_prog*, %struct.netlink_ext_ack* }
%struct.xdp_frame = type { i8*, i16, i16, i32, %struct.xdp_mem_info, %struct.net_device* }
%struct.xdp_mem_info = type { i32, i32 }
%struct.xdp_buff = type { i8*, i8*, i8*, i8*, %struct.xdp_rxq_info*, %struct.xdp_txq_info*, i32 }
%struct.xdp_rxq_info = type { %struct.net_device*, i32, i32, %struct.xdp_mem_info, i32, [36 x i8] }
%struct.xdp_txq_info = type { %struct.net_device* }
%struct.devlink_port = type opaque
%struct.ip_tunnel_parm = type opaque
%struct.net_device_path_ctx = type { %struct.net_device*, i8*, i32, [2 x %struct.anon.154] }
%struct.anon.154 = type { i16, i16 }
%struct.net_device_path = type { i32, %struct.net_device*, %union.anon.155 }
%union.anon.155 = type { %struct.anon.157, [4 x i8] }
%struct.anon.157 = type { i32, i16, i16 }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ethtool_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)*, i16 (%struct.sk_buff*)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32, %struct.rb_root }
%struct.in_device = type opaque
%struct.inet6_dev = type opaque
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.xdp_rxq_info, %struct.kobject, %struct.net_device*, [56 x i8] }
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i64, i64, %struct.net_device*, [16 x i8], %struct.spinlock, i32, i64, i64, [40 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, i32, %struct.refcount_struct, [24 x i8], %struct.sk_buff_head, %struct.qdisc_skb_head, %struct.gnet_stats_basic_packed, %struct.seqcount, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff_head, %struct.spinlock, %struct.spinlock, %struct.callback_head, [40 x i8], [0 x i64] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, void (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*)*, i32 (%struct.Qdisc*)*, %struct.module* }
%struct.Qdisc_class_ops = type { i32, %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**, %struct.netlink_ext_ack*)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*, %struct.netlink_ext_ack*)*, i32 (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_block* (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.tcf_block = type { %struct.mutex, %struct.list_head, i32, i32, %struct.refcount_struct, %struct.net*, %struct.Qdisc*, %struct.rw_semaphore, %struct.flow_block, %struct.list_head, i8, %struct.atomic_t, i32, i32, %struct.anon.159, %struct.callback_head, [128 x %struct.hlist_head], %struct.mutex }
%struct.flow_block = type { %struct.list_head }
%struct.anon.159 = type { %struct.tcf_chain*, %struct.list_head }
%struct.tcf_chain = type { %struct.mutex, %struct.tcf_proto*, %struct.list_head, %struct.tcf_block*, i32, i32, i32, i8, i8, %struct.tcf_proto_ops*, i8*, %struct.callback_head }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i8*, %struct.tcf_proto_ops*, %struct.tcf_chain*, %struct.spinlock, i8, %struct.refcount_struct, %struct.callback_head, %struct.hlist_node }
%struct.tcf_result = type { %union.anon.160 }
%union.anon.160 = type { %struct.anon.161 }
%struct.anon.161 = type { i64, i32 }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, i1, %struct.netlink_ext_ack*)*, i8* (%struct.tcf_proto*, i32)*, void (%struct.tcf_proto*, i8*)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i8**, i32, %struct.netlink_ext_ack*)*, i32 (%struct.tcf_proto*, i8*, i8*, i1, %struct.netlink_ext_ack*)*, i1 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, %struct.tcf_walker*, i1)*, i32 (%struct.tcf_proto*, i1, i32 (i32, i8*, i8*)*, i8*, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, i8*)*, void (%struct.tcf_proto*, i8*)*, void (i8*, i32, i64, i8*, i64)*, i8* (%struct.net*, %struct.tcf_chain*, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (i8*)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.sk_buff*, %struct.net*, i8*)*, %struct.module*, i32 }
%struct.tcf_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.gnet_stats_basic_packed, %struct.u64_stats_sync }
%struct.qdisc_skb_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.gnet_stats_basic_packed = type { i64, i64 }
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.xdp_dev_bulk_queue = type opaque
%union.anon.163 = type { %struct.pcpu_lstats* }
%struct.pcpu_lstats = type { %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_sync }
%struct.u64_stats_t = type { %struct.local64_t }
%struct.local64_t = type { %struct.local_t }
%struct.local_t = type { %struct.atomic64_t }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, %struct.address_space* ()*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, %struct.net_device* (%struct.nlattr**, i8*, i8, i32, i32)*, void (%struct.net_device*)*, i8, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.phy_device = type opaque
%struct.sfp_bus = type opaque
%struct.udp_tunnel_nic_info = type opaque
%struct.udp_tunnel_nic = type opaque
%struct.bpf_xdp_entity = type { %struct.bpf_prog*, %struct.bpf_xdp_link* }
%struct.bpf_xdp_link = type opaque
%struct.netns_core = type { %struct.ctl_table_header*, i32, i32*, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.ipstats_mib*, %struct.tcp_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib* }
%struct.ipstats_mib = type { [37 x i64], %struct.u64_stats_sync }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [126 x i64] }
%struct.udp_mib = type { [10 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_nexthop = type { %struct.rb_root, %struct.hlist_head*, i32, i32, %struct.blocking_notifier_head }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.netns_ipv4 = type { %struct.inet_timewait_death_row, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.ip_ra_chain*, %struct.mutex, i8, i8, %struct.hlist_head*, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, %struct.fqdir*, i8, i8, i8, i8, i8, i32, i32, %struct.local_ports, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i8, i32, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i8, i8, i8, i8, i32, i32, i32, [3 x i32], [3 x i32], i64, i64, i32, i32, %struct.tcp_congestion_ops*, %struct.tcp_fastopen_context*, i32, %struct.atomic_t, i64, i32, i32, i8, i8, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.fib_notifier_ops*, i32, %struct.fib_notifier_ops*, i32, %struct.atomic_t, %struct.siphash_key_t, [48 x i8] }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32 }
%struct.inet_hashinfo = type opaque
%struct.ipv4_devconf = type opaque
%struct.ip_ra_chain = type opaque
%struct.inet_peer_base = type opaque
%struct.fqdir = type { i64, i64, i32, i32, %struct.inet_frags*, %struct.net*, i8, [23 x i8], %struct.rhashtable, [56 x i8], %struct.atomic64_t, %struct.work_struct, %struct.llist_node, [16 x i8] }
%struct.inet_frags = type { i32, void (%struct.inet_frag_queue*, i8*)*, void (%struct.inet_frag_queue*)*, void (%struct.timer_list*)*, %struct.kmem_cache*, i8*, %struct.rhashtable_params, %struct.refcount_struct, %struct.completion }
%struct.inet_frag_queue = type { %struct.rhash_head, %union.anon.47, %struct.timer_list, %struct.spinlock, %struct.refcount_struct, %struct.rb_root, %struct.sk_buff*, %struct.sk_buff*, i64, i32, i32, i8, i16, %struct.fqdir*, %struct.callback_head }
%struct.rhash_head = type { %struct.rhash_head* }
%union.anon.47 = type { %struct.frag_v6_compare_key }
%struct.frag_v6_compare_key = type { %struct.in6_addr, %struct.in6_addr, i32, i32, i32 }
%struct.in6_addr = type { %union.anon.48 }
%union.anon.48 = type { [4 x i32] }
%struct.rhashtable_params = type { i16, i16, i16, i16, i32, i16, i8, i32 (i8*, i32, i32)*, i32 (i8*, i32, i32)*, i32 (%struct.rhashtable_compare_arg*, i8*)* }
%struct.rhashtable_compare_arg = type { %struct.rhashtable*, i8* }
%struct.rhashtable = type { %struct.bucket_table*, i32, i32, %struct.rhashtable_params, i8, %struct.work_struct, %struct.mutex, %struct.spinlock, %struct.atomic_t }
%struct.bucket_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.tcp_congestion_ops = type opaque
%struct.tcp_fastopen_context = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.kgid_t] }
%struct.fib_notifier_ops = type { i32, %struct.list_head, i32 (%struct.net*)*, i32 (%struct.net*, %struct.notifier_block*, %struct.netlink_ext_ack*)*, %struct.module*, %struct.callback_head }
%struct.siphash_key_t = type { [2 x i64] }
%struct.net_generic = type opaque
%struct.netns_bpf = type { [2 x %struct.bpf_prog_array*], [2 x %struct.bpf_prog*], [2 x %struct.list_head] }
%struct.bpf_prog_array = type { %struct.callback_head, [0 x %struct.bpf_prog_array_item] }
%struct.bpf_prog_array_item = type { %struct.bpf_prog*, %union.anon.93 }
%union.anon.93 = type { [2 x %struct.bpf_cgroup_storage*] }
%struct.bpf_cgroup_storage = type opaque
%struct.time_namespace = type opaque
%struct.cgroup_namespace = type { %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.css_set = type opaque
%struct.signal_struct = type { %struct.refcount_struct, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, %struct.task_struct*, %struct.sigpending, %struct.hlist_head, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x %struct.pid*], %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], i8, i16, i16, %struct.mm_struct*, %struct.mutex, %struct.rw_semaphore }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.sighand_struct = type { %struct.spinlock, %struct.refcount_struct, %struct.wait_queue_head, [64 x %struct.k_sigaction] }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.seccomp = type {}
%struct.syscall_user_dispatch = type {}
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root_cached = type { %struct.rb_root, %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type { %struct.bio*, %struct.bio* }
%struct.bio = type { %struct.bio*, %struct.block_device*, i32, i16, i16, i16, i8, %struct.atomic_t, %struct.bvec_iter, void (%struct.bio*)*, i8*, %union.anon.172, i16, i16, %struct.atomic_t, %struct.bio_vec*, %struct.bio_set*, [0 x %struct.bio_vec] }
%struct.bvec_iter = type { i64, i32, i32, i32 }
%union.anon.172 = type {}
%struct.bio_set = type { %struct.kmem_cache*, i32, %struct.bio_alloc_cache*, %struct.mempool_s, %struct.mempool_s, i32, %struct.spinlock, %struct.bio_list, %struct.work_struct, %struct.workqueue_struct*, %struct.hlist_node }
%struct.bio_alloc_cache = type opaque
%struct.mempool_s = type { %struct.spinlock, i32, i32, i8**, i8*, i8* (i32, i8*)*, void (i8*, i8*)*, %struct.wait_queue_head }
%struct.reclaim_state = type opaque
%struct.io_context = type { %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, i16, %struct.xarray, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %union.anon.94, %union.anon.95, i32 }
%struct.request_queue = type { %struct.request*, %struct.elevator_queue*, %struct.percpu_ref, %struct.blk_queue_stats*, %struct.rq_qos*, %struct.blk_mq_ops*, %struct.blk_mq_ctx*, i32, %struct.blk_mq_hw_ctx**, i32, i8*, i64, %struct.atomic_t, i32, %struct.spinlock, %struct.gendisk*, %struct.kobject, %struct.kobject*, i64, i32, i32, i32, i32, %struct.blk_stat_callback*, [16 x %struct.blk_rq_stat], %struct.timer_list, %struct.work_struct, %struct.atomic_t, %struct.sbitmap_queue, %struct.sbitmap_queue, %struct.list_head, %struct.queue_limits, i32, i32, %struct.mutex, %struct.blk_flush_queue*, %struct.list_head, %struct.spinlock, %struct.delayed_work, %struct.mutex, %struct.mutex, %struct.list_head, %struct.spinlock, i32, %struct.callback_head, %struct.wait_queue_head, %struct.mutex, %struct.blk_mq_tag_set*, %struct.list_head, %struct.bio_set, %struct.dentry*, i8, i64, [5 x i64] }
%struct.request = type { %struct.request_queue*, %struct.blk_mq_ctx*, %struct.blk_mq_hw_ctx*, i32, i32, i32, i32, i32, i64, %struct.bio*, %struct.bio*, %struct.list_head, %union.anon.166, %union.anon.167, %union.anon.168, %struct.gendisk*, %struct.block_device*, i64, i64, i16, i16, i16, i16, i32, %struct.refcount_struct, i32, i64, %union.anon.171, void (%struct.request*, i8)*, i8* }
%struct.blk_mq_hw_ctx = type opaque
%union.anon.166 = type { %struct.hlist_node }
%union.anon.167 = type { %struct.rb_node }
%union.anon.168 = type { %struct.anon.170 }
%struct.anon.170 = type { i32, %struct.list_head, void (%struct.request*, i8)* }
%union.anon.171 = type { %struct.__call_single_data }
%struct.__call_single_data = type { %struct.__call_single_node, void (i8*)*, i8* }
%struct.elevator_queue = type { %struct.elevator_type*, i8*, %struct.kobject, %struct.mutex, i8, [64 x %struct.hlist_head] }
%struct.elevator_type = type { %struct.kmem_cache*, %struct.elevator_mq_ops, i64, i64, %struct.elv_fs_entry*, i8*, i8*, i32, %struct.module*, [22 x i8], %struct.list_head }
%struct.elevator_mq_ops = type { i32 (%struct.request_queue*, %struct.elevator_type*)*, void (%struct.elevator_queue*)*, i32 (%struct.blk_mq_hw_ctx*, i32)*, void (%struct.blk_mq_hw_ctx*, i32)*, void (%struct.blk_mq_hw_ctx*)*, i1 (%struct.request_queue*, %struct.request*, %struct.bio*)*, i1 (%struct.request_queue*, %struct.bio*, i32)*, i32 (%struct.request_queue*, %struct.request**, %struct.bio*)*, void (%struct.request_queue*, %struct.request*, i32)*, void (%struct.request_queue*, %struct.request*, %struct.request*)*, void (i32, %struct.blk_mq_alloc_data*)*, void (%struct.request*)*, void (%struct.request*)*, void (%struct.blk_mq_hw_ctx*, %struct.list_head*, i1)*, %struct.request* (%struct.blk_mq_hw_ctx*)*, i1 (%struct.blk_mq_hw_ctx*)*, void (%struct.request*, i64)*, void (%struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, void (%struct.io_cq*)*, void (%struct.io_cq*)* }
%struct.blk_mq_alloc_data = type opaque
%struct.elv_fs_entry = type { %struct.attribute, i64 (%struct.elevator_queue*, i8*)*, i64 (%struct.elevator_queue*, i8*, i64)* }
%struct.blk_queue_stats = type opaque
%struct.rq_qos = type opaque
%struct.blk_mq_ops = type opaque
%struct.blk_mq_ctx = type opaque
%struct.blk_stat_callback = type opaque
%struct.blk_rq_stat = type { i64, i64, i64, i32, i64 }
%struct.sbitmap_queue = type { %struct.sbitmap, i32, %struct.atomic_t, %struct.sbq_wait_state*, %struct.atomic_t, i32 }
%struct.sbitmap = type { i32, i32, i32, i8, %struct.sbitmap_word*, i32* }
%struct.sbitmap_word = type { i64, [56 x i8], i64, [56 x i8], i64, [56 x i8] }
%struct.sbq_wait_state = type { %struct.atomic_t, %struct.wait_queue_head, [32 x i8] }
%struct.queue_limits = type { i32, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i8, i8, i8, i32 }
%struct.blk_flush_queue = type opaque
%struct.blk_mq_tag_set = type opaque
%union.anon.94 = type { %struct.list_head }
%union.anon.95 = type { %struct.hlist_node }
%struct.kernel_siginfo = type { %struct.anon.96 }
%struct.anon.96 = type { i32, i32, i32, %union.__sifields }
%union.__sifields = type { %struct.anon.100 }
%struct.anon.100 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type {}
%struct.robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.rseq = type { i32, i32, %union.anon.108, i32, [12 x i8] }
%union.anon.108 = type { i64 }
%struct.tlbflush_unmap_batch = type {}
%union.anon.109 = type { %struct.callback_head }
%struct.pipe_inode_info = type { %struct.mutex, %struct.wait_queue_head, %struct.wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.fasync_struct = type { %struct.rwlock_t, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.kmap_ctrl = type {}
%struct.thread_struct = type { %struct.cpu_context, %struct.anon.112, i32, i8*, i32, i32, i64, i64, %struct.debug_info, i64 }
%struct.cpu_context = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.anon.112 = type { i64, i64, %struct.user_fpsimd_state }
%struct.user_fpsimd_state = type { [32 x i128], i32, i32, [2 x i32] }
%struct.debug_info = type {}
%struct.completion = type { i32, %struct.swait_queue_head }
%struct.swait_queue_head = type { %struct.raw_spinlock, %struct.list_head }
%struct.kioctx_table = type opaque
%struct.uprobes_state = type {}
%struct.pgprot_t = type { i64 }
%struct.anon.113 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, i32 (%struct.vm_fault*, i64, i64)*, i64 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.anon.114, i32, %struct.pmd_t*, %struct.pud_t*, %union.anon.115, %struct.page*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.anon.114 = type { %struct.vm_area_struct*, i32, i64, i64 }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { %struct.p4d_t }
%struct.p4d_t = type { %struct.pgd_t }
%union.anon.115 = type { %struct.pte_t }
%struct.pte_t = type { i64 }
%struct.vm_userfaultfd_ctx = type {}
%struct.poll_table_struct = type { void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)*, i32 }
%struct.bpf_local_storage_map = type opaque
%struct.bpf_local_storage = type opaque
%struct.bpf_verifier_env = type opaque
%struct.bpf_func_state = type opaque
%struct.bpf_iter_seq_info = type { %struct.seq_operations*, i32 (i8*, %struct.bpf_iter_aux_info*)*, void (i8*)*, i32 }
%struct.bpf_iter_aux_info = type opaque
%struct.bpf_kfunc_desc_tab = type opaque
%struct.bpf_ksym = type { i64, i64, [128 x i8], %struct.list_head, %struct.latch_tree_node, i8 }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.bpf_prog_ops = type { i32 (%struct.bpf_prog*, %union.bpf_attr*, %union.bpf_attr*)* }
%struct.btf_mod_pair = type { %struct.btf*, %struct.module* }
%struct.user_struct = type { %struct.refcount_struct, %struct.percpu_counter, i64, %struct.atomic64_t, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t, %struct.ratelimit_state }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.bpf_prog_offload = type { %struct.bpf_prog*, %struct.net_device*, %struct.bpf_offload_dev*, i8*, %struct.list_head, i8, i8, i8*, i32 }
%struct.bpf_offload_dev = type opaque
%struct.btf = type opaque
%struct.bpf_func_info = type { i32, i32 }
%struct.bpf_func_info_aux = type { i16, i8 }
%struct.bpf_line_info = type { i32, i32, i32, i32 }
%struct.exception_table_entry = type { i32, i32 }
%union.anon.92 = type { %struct.work_struct }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%union.anon.144 = type { %struct.socket_wq* }
%struct.socket_wq = type { %struct.wait_queue_head, %struct.fasync_struct*, i64, %struct.callback_head, [8 x i8] }
%struct.dst_entry = type { %struct.net_device*, %struct.dst_ops*, i64, i64, i8*, i32 (%struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, i16, i16, i16, i16, %struct.atomic_t, i32, i64, %struct.lwtunnel_state*, %struct.callback_head, i16, i16, i32 }
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32, i1)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [40 x i8] }
%struct.lwtunnel_state = type opaque
%struct.refcount_struct = type { %struct.atomic_t }
%union.anon.164 = type { %struct.sk_buff* }
%struct.sk_buff = type { %union.anon.49, %union.anon.52, %union.anon.53, [48 x i8], %union.anon.54, i32, i32, i16, i16, i16, [0 x i8], i8, [0 x i32], [0 x i8], i16, [0 x i8], i16, %union.anon.56, i32, i32, i32, i16, i16, %union.anon.58, %union.anon.59, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %struct.refcount_struct }
%union.anon.49 = type { %struct.anon.50 }
%struct.anon.50 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.51 }
%union.anon.51 = type { %struct.net_device* }
%union.anon.52 = type { %struct.sock* }
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.anon.55 }
%struct.anon.55 = type { i64, void (%struct.sk_buff*)* }
%union.anon.56 = type { i32 }
%union.anon.58 = type { i32 }
%union.anon.59 = type { i16 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.timer_list = type { %struct.hlist_node, i64, void (%struct.timer_list*)*, i32 }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*, i1)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, [2 x i64], i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, i1 (i32, i32)*, void (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, i32, i1 (%struct.sock*, i32)*, i1 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, %struct.atomic64_t*, %struct.percpu_counter*, i64*, i64*, i32*, i32*, i32, i32, i32, i8, %struct.kmem_cache*, i32, i32, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.138, %struct.module*, [32 x i8], %struct.list_head, i32 (%struct.sock*, i32)* }
%struct.msghdr = type { i8*, i32, %struct.iov_iter, %union.anon.137, i8, i64, i32, %struct.kiocb* }
%struct.iov_iter = type { i8, i8, i64, i64, %union.anon.4, %union.anon.135 }
%union.anon.4 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.135 = type { i64 }
%union.anon.137 = type { i8* }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.request_sock_ops = type opaque
%struct.timewait_sock_ops = type opaque
%union.anon.138 = type { %struct.inet_hashinfo* }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %union.anon.110, %struct.qspinlock }
%union.anon.110 = type { %struct.atomic_t }
%struct.pid = type { %struct.refcount_struct, i32, %struct.spinlock, [4 x %struct.hlist_head], %struct.hlist_head, %struct.wait_queue_head, %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace* }
%struct.socket = type { i32, i16, i64, %struct.file*, %struct.sock*, %struct.proto_ops*, [24 x i8], %struct.socket_wq }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32, i1)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i8*, i1, i1)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, [2 x i64], i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, void (%struct.seq_file*, %struct.socket*)*, i32 (%struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.sock*, i32)*, i32 (%struct.socket*)*, i32 (%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, i32)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.165, i32 }
%union.anon.165 = type { i8* }
%struct.sock_cgroup_data = type {}
%struct.sock_reuseport = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.116, i8*, i64, i16, i16, %struct.kernfs_iattrs* }
%union.anon.116 = type { %struct.kernfs_elem_dir }
%struct.kernfs_elem_dir = type { i64, %struct.rb_root, %struct.kernfs_root*, i64 }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.idr, i32, i32, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.wait_queue_head }
%struct.kernfs_syscall_ops = type { i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i64)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key, i8 }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i64)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.attribute_group**, %struct.dev_pm_ops*, void (%struct.device*)*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, i32, %struct.spinlock, i8, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, i32 (%struct.device*)*, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.bus_dma_region = type opaque
%struct.device_dma_parameters = type { i32, i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.io_tlb_mem = type opaque
%struct.dev_archdata = type {}
%struct.device_node = type opaque
%struct.fwnode_handle = type { %struct.fwnode_handle*, %struct.fwnode_operations*, %struct.device*, %struct.list_head, %struct.list_head, i8 }
%struct.fwnode_operations = type { %struct.fwnode_handle* (%struct.fwnode_handle*)*, void (%struct.fwnode_handle*)*, i1 (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*, %struct.device*)*, i1 (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i32, i8*, i64)*, i32 (%struct.fwnode_handle*, i8*, i8**, i64)*, i8* (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i8*, i32, i32, %struct.fwnode_reference_args*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, i32 (%struct.fwnode_handle*, %struct.fwnode_endpoint*)*, i32 (%struct.fwnode_handle*)* }
%struct.fwnode_reference_args = type { %struct.fwnode_handle*, i32, [8 x i64] }
%struct.fwnode_endpoint = type { i32, i32, %struct.fwnode_handle* }
%struct.class = type { i8*, %struct.module*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, void (%struct.device*, %struct.kuid_t*, %struct.kgid_t*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.iommu_group = type opaque
%struct.dev_iommu = type opaque
%struct.gendisk = type { i32, i32, i32, [32 x i8], i16, i16, %struct.xarray, %struct.block_device*, %struct.block_device_operations*, %struct.request_queue*, i8*, i32, i64, %struct.mutex, i32, %struct.backing_dev_info*, %struct.kobject*, %struct.timer_rand_state*, %struct.atomic_t, %struct.disk_events*, i32, %struct.badblocks*, %struct.lockdep_map, i64 }
%struct.block_device_operations = type { i32 (%struct.bio*)*, i32 (%struct.block_device*, i32)*, void (%struct.gendisk*, i32)*, i32 (%struct.block_device*, i64, %struct.page*, i32)*, i32 (%struct.block_device*, i32, i32, i64)*, i32 (%struct.block_device*, i32, i32, i64)*, i32 (%struct.gendisk*, i32)*, void (%struct.gendisk*)*, i32 (%struct.block_device*, %struct.hd_geometry*)*, i32 (%struct.block_device*, i1)*, void (%struct.block_device*, i64)*, i32 (%struct.gendisk*, i64, i32, i32 (%struct.blk_zone*, i32, i8*)*, i8*)*, i8* (%struct.gendisk*, i16*)*, %struct.module*, %struct.pr_ops*, i32 (%struct.gendisk*, i64*)* }
%struct.hd_geometry = type opaque
%struct.blk_zone = type { i64, i64, i64, i8, i8, i8, i8, [4 x i8], i64, [24 x i8] }
%struct.pr_ops = type opaque
%struct.timer_rand_state = type opaque
%struct.disk_events = type opaque
%struct.badblocks = type opaque
%struct.lockdep_map = type {}
%struct.partition_meta_info = type { [37 x i8], [64 x i8] }
%struct.backing_dev_info = type { i64, %struct.rb_node, %struct.list_head, i64, i64, %struct.kref, i32, i32, i32, i32, %struct.atomic64_t, %struct.bdi_writeback, %struct.list_head, %struct.wait_queue_head, %struct.device*, [64 x i8], %struct.device*, %struct.timer_list }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.atomic_t, [4 x %struct.percpu_counter], i64, i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, %struct.delayed_work, i64, %struct.list_head }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rcuwait, %struct.wait_queue_head, %struct.atomic_t }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.rcuwait = type { %struct.task_struct* }
%struct.uuid_t = type { [16 x i8] }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*)*, [24 x i8] }
%struct.qstr = type { %union.anon.12, i8* }
%union.anon.12 = type { i64 }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i64, i32, i32, %struct.list_head, %struct.atomic64_t* }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, i64, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, i8, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [12 x i64] }
%struct.uid_gid_map = type { i32, %union.anon.26 }
%union.anon.26 = type { %struct.anon.27, [48 x i8] }
%struct.anon.27 = type { %struct.uid_gid_extent*, %struct.uid_gid_extent* }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.dentry = type { i32, %struct.seqcount_spinlock, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.117, %struct.list_head, %struct.list_head, %union.anon.118 }
%struct.lockref = type { %union.anon.14 }
%union.anon.14 = type { i64 }
%union.anon.117 = type { %struct.list_head }
%union.anon.118 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i64, %union.anon.173, i32, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.spinlock, i16, i8, i8, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.174, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.175, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.176, i32, i8* }
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.user_namespace*, %struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32, i1)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.iattr*)*, i32 (%struct.user_namespace*, %struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec64*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.posix_acl*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.fileattr*)*, i32 (%struct.dentry*, %struct.fileattr*)*, [8 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.posix_acl = type opaque
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.timespec64, i64, i64 }
%struct.fiemap_extent_info = type opaque
%struct.fileattr = type opaque
%union.anon.173 = type { i32 }
%struct.timespec64 = type { i64, i64 }
%union.anon.174 = type { %struct.callback_head }
%union.anon.175 = type { %struct.file_operations* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.xarray, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i64, i64, %struct.address_space_operations*, i64, i32, %struct.spinlock, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, void (%struct.readahead_control*)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.readahead_control = type { %struct.file*, %struct.address_space*, %struct.file_ra_state*, i64, i32, i32 }
%struct.swap_info_struct = type opaque
%union.anon.176 = type { %struct.pipe_inode_info* }
%struct.spinlock = type { %union.anon.7 }
%union.anon.7 = type { %struct.raw_spinlock }
%struct.atomic64_t = type { i64 }
%struct.mutex = type { %struct.atomic64_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.user_struct*, %struct.user_namespace*, %struct.ucounts*, %struct.group_info*, %union.anon.30 }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%union.anon.30 = type { %struct.callback_head }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, i8*, i32, i8, i32, i32, %struct.wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.119 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)*, i1 (%struct.file_lock*)* }
%union.anon.119 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.pt_regs = type { %union.anon.177, i64, i32, i32, i64, i64, [2 x i64], i64, i64 }
%union.anon.177 = type { %struct.user_pt_regs }
%struct.user_pt_regs = type { [31 x i64], i64, i64, i64 }
%struct.io_uring_params = type { i32, i32, i32, i32, i32, i32, i32, [3 x i32], %struct.io_sqring_offsets, %struct.io_cqring_offsets }
%struct.io_sqring_offsets = type { i32, i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.io_cqring_offsets = type { i32, i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.io_task_cancel = type { %struct.task_struct*, i8 }
%struct.io_tctx_node = type { %struct.list_head, %struct.task_struct*, %struct.io_ring_ctx* }
%struct.io_defer_entry = type { %struct.list_head, %struct.io_kiocb*, i32 }
%struct.req_batch = type { %struct.task_struct*, i32, i32 }
%struct.io_buffer = type { %struct.list_head, i64, i32, i16 }
%struct.io_timeout_data = type { %struct.io_kiocb*, %struct.hrtimer, %struct.timespec64, i32, i32 }
%struct.io_poll_table = type { %struct.poll_table_struct, %struct.io_kiocb*, i32, i32 }
%struct.io_op_def = type { i16, i16 }
%struct.iov_iter_state = type { i64, i64, i64 }
%struct.io_async_rw = type { [8 x %struct.iovec], %struct.iovec*, %struct.iov_iter, %struct.iov_iter_state, i64, %struct.wait_page_queue }
%struct.io_poll_update = type { %struct.file*, i64, i64, i32, i8, i8 }
%struct.io_timeout = type { %struct.file*, i32, i32, %struct.list_head, %struct.io_kiocb*, %struct.io_kiocb* }
%struct.io_sync = type { %struct.file*, i64, i64, i32, i32 }
%struct.io_close = type { %struct.file*, i32, i32 }
%struct.io_uring_rsrc_update2 = type { i32, i32, i64, i64, i32, i32 }
%struct.io_rsrc_update = type { %struct.file*, i64, i32, i32 }
%struct.io_statx = type { %struct.file*, i32, i32, i32, i8*, %struct.statx* }
%struct.statx = type { i32, i32, i64, i32, i32, i32, i16, [1 x i16], i64, i64, i64, i64, %struct.statx_timestamp, %struct.statx_timestamp, %struct.statx_timestamp, %struct.statx_timestamp, i32, i32, i32, i32, i64, i64, [12 x i64] }
%struct.statx_timestamp = type { i64, i32, i32 }
%struct.io_fadvise = type { %struct.file*, i64, i32, i32 }
%struct.io_madvise = type { %struct.file*, i64, i32, i32 }
%struct.open_flags = type { i32, i16, i32, i32, i32 }
%struct.io_open = type { %struct.file*, i32, i32, %struct.filename*, %struct.open_how, i64 }
%struct.filename = type { i8*, i8*, i32, %struct.audit_names*, [0 x i8] }
%struct.audit_names = type opaque
%struct.open_how = type { i64, i64, i64 }
%struct.io_epoll = type { %struct.file*, i32, i32, i32, %struct.epoll_event }
%struct.epoll_event = type { i32, i64 }
%struct.io_provide_buf = type { %struct.file*, i64, i32, i32, i16, i16 }
%struct.io_rename = type { %struct.file*, i32, i32, %struct.filename*, %struct.filename*, i32 }
%struct.io_unlink = type { %struct.file*, i32, i32, %struct.filename* }
%struct.io_mkdir = type { %struct.file*, i32, i16, %struct.filename* }
%struct.io_hardlink = type { %struct.file*, i32, i32, %struct.filename*, %struct.filename*, i32 }
%struct.io_async_msghdr = type { [8 x %struct.iovec], %struct.iovec*, %struct.sockaddr*, %struct.msghdr, %struct.__kernel_sockaddr_storage }
%struct.__kernel_sockaddr_storage = type { %union.anon.181 }
%union.anon.181 = type { i8*, [120 x i8] }
%struct.anon.128 = type { i64, i8, i8, %struct.atomic_t, i32 }
%struct.io_tctx_exit = type { %struct.callback_head, %struct.completion, %struct.io_ring_ctx* }
%struct.wait_page_key = type { %struct.page*, i32, i32 }
%struct.io_cancel_data = type { %struct.io_ring_ctx*, i64 }
%struct.__kernel_timespec = type { i64, i64 }
%struct.io_uring_getevents_arg = type { i64, i32, i32, i64 }
%struct.io_wait_queue = type { %struct.wait_queue_entry, %struct.io_ring_ctx*, i32, i32 }
%struct.io_wq_data = type { %struct.io_wq_hash*, %struct.task_struct*, void (%struct.io_wq_work*)*, %struct.io_wq_work* (%struct.io_wq_work*)* }
%struct.ksignal = type { %struct.k_sigaction, %struct.kernel_siginfo, i32 }
%struct.io_uring_probe_op = type { i8, i8, i16, i32 }
%struct.io_uring_restriction = type { i16, %union.anon.186, i8, [3 x i32] }
%union.anon.186 = type { i8 }
%struct.io_uring_rsrc_register = type { i32, i32, i64, i64, i64 }

@__UNIQUE_ID___addressable_io_uring_init916 = internal global i8* bitcast (i32 ()* @io_uring_init to i8*), section ".discard.addressable", align 8
@percpu_counter_batch = external dso_local local_unnamed_addr global i32, align 4
@kmalloc_caches = external dso_local local_unnamed_addr global [3 x [14 x %struct.kmem_cache*]], align 8
@gic_nonsecure_priorities = external dso_local global %struct.static_key_false, align 4
@system_wq = external dso_local local_unnamed_addr global %struct.workqueue_struct*, align 8
@io_uring_fops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.kiocb*, i1)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @io_uring_poll, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* @io_uring_mmap, i64 0, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @io_uring_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* @io_uring_show_fdinfo, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, i64, i32)* null }, align 8
@memstart_addr = external dso_local local_unnamed_addr global i64, align 8
@kimage_voffset = external dso_local local_unnamed_addr global i64, align 8
@system_unbound_wq = external dso_local local_unnamed_addr global %struct.workqueue_struct*, align 8
@jiffies = external dso_local global i64, section ".data..cacheline_aligned", align 64
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@req_cachep = internal unnamed_addr global %struct.kmem_cache* null, align 8
@.str.3 = private unnamed_addr constant [14 x i8] c"SqThread:\09%d\0A\00", align 1
@.str.4 = private unnamed_addr constant [17 x i8] c"SqThreadCpu:\09%d\0A\00", align 1
@.str.5 = private unnamed_addr constant [15 x i8] c"UserFiles:\09%u\0A\00", align 1
@.str.6 = private unnamed_addr constant [9 x i8] c"%5u: %s\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%5u: <none>\0A\00", align 1
@.str.8 = private unnamed_addr constant [14 x i8] c"UserBufs:\09%u\0A\00", align 1
@.str.9 = private unnamed_addr constant [16 x i8] c"%5u: 0x%llx/%u\0A\00", align 1
@.str.10 = private unnamed_addr constant [16 x i8] c"Personalities:\0A\00", align 1
@.str.11 = private unnamed_addr constant [11 x i8] c"PollList:\0A\00", align 1
@.str.12 = private unnamed_addr constant [24 x i8] c"  op=%d, task_works=%d\0A\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"%5d\0A\00", align 1
@.str.14 = private unnamed_addr constant [7 x i8] c"\09Uid:\09\00", align 1
@.str.15 = private unnamed_addr constant [3 x i8] c"\09\09\00", align 1
@.str.16 = private unnamed_addr constant [8 x i8] c"\0A\09Gid:\09\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"\0A\09Groups:\09\00", align 1
@.str.18 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.19 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.20 = private unnamed_addr constant [11 x i8] c"\0A\09CapEff:\09\00", align 1
@overflowuid = external dso_local local_unnamed_addr global i32, align 4
@overflowgid = external dso_local local_unnamed_addr global i32, align 4
@io_op_defs = internal unnamed_addr constant [40 x { i8, i8, i16 }] [{ i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 -43, i8 1, i16 264 }, { i8, i8, i16 } { i8 -89, i8 1, i16 264 }, { i8, i8, i16 } { i8 1, i8 0, i16 0 }, { i8, i8, i16 } { i8 21, i8 1, i16 264 }, { i8, i8, i16 } { i8 39, i8 1, i16 264 }, { i8, i8, i16 } { i8 5, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 1, i8 0, i16 0 }, { i8, i8, i16 } { i8 -91, i8 0, i16 368 }, { i8, i8, i16 } { i8 -43, i8 0, i16 368 }, { i8, i8, i16 } { i8 0, i8 0, i16 96 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 21, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 0, i8 0, i16 96 }, { i8, i8, i16 } { i8 -91, i8 0, i16 128 }, { i8, i8, i16 } { i8 1, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 85, i8 1, i16 264 }, { i8, i8, i16 } { i8 39, i8 1, i16 264 }, { i8, i8, i16 } { i8 1, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 37, i8 0, i16 0 }, { i8, i8, i16 } { i8 85, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 4, i8 0, i16 0 }, { i8, i8, i16 } { i8 7, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } { i8 7, i8 0, i16 0 }, { i8, i8, i16 } { i8 1, i8 0, i16 0 }, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer, { i8, i8, i16 } zeroinitializer], align 4
@io_req_prep_async.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.22 = private unnamed_addr constant [40 x i8] c"\014io_uring: prep_async() bad opcode %d\0A\00", align 1
@io_uring_alloc_task_context.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@io_uring_alloc_task_context.__key.23 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.24 = private unnamed_addr constant [12 x i8] c"&tctx->wait\00", align 1
@io_init_wq_offload.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.25 = private unnamed_addr constant [12 x i8] c"&hash->wait\00", align 1
@__num_online_cpus = external dso_local global %struct.atomic_t, align 4
@io_req_prep.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.26 = private unnamed_addr constant [33 x i8] c"\014io_uring: unhandled opcode %d\0A\00", align 1
@io_ring_ctx_alloc.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.27 = private unnamed_addr constant [18 x i8] c"&ctx->sqo_sq_wait\00", align 1
@io_ring_ctx_alloc.__key.28 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"&ctx->poll_wait\00", align 1
@io_ring_ctx_alloc.__key.30 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.31 = private unnamed_addr constant [17 x i8] c"&ctx->uring_lock\00", align 1
@io_ring_ctx_alloc.__key.32 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.33 = private unnamed_addr constant [14 x i8] c"&ctx->cq_wait\00", align 1
@nr_cpu_ids = external dso_local local_unnamed_addr global i32, align 4
@io_get_sq_data.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.34 = private unnamed_addr constant [11 x i8] c"&sqd->lock\00", align 1
@io_get_sq_data.__key.35 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.36 = private unnamed_addr constant [11 x i8] c"&sqd->wait\00", align 1
@__cpu_online_mask = external dso_local global %struct.cpumask, align 8
@.str.37 = private unnamed_addr constant [11 x i8] c"iou-sqp-%d\00", align 1
@cpu_bit_bitmap = external dso_local constant [65 x [4 x i64]], align 8
@.str.38 = private unnamed_addr constant [11 x i8] c"[io_uring]\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"io_kiocb\00", align 1
@llvm.compiler.used = appending global [1 x i8*] [i8* bitcast (i8** @__UNIQUE_ID___addressable_io_uring_init916 to i8*)], section "llvm.metadata"

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define dso_local noalias %struct.sock* @io_uring_get_socket(%struct.file* nocapture noundef readnone %file) local_unnamed_addr #0 {
entry:
  ret %struct.sock* null
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define dso_local void @__io_uring_free(%struct.task_struct* nocapture noundef %tsk) local_unnamed_addr #1 {
entry:
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i64 0, i32 85
  %0 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %xa = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 1
  %call = call fastcc i1 @xa_empty(%struct.xarray* noundef %xa) #25
  br i1 %call, label %if.end, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 8597; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !9
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 4
  %1 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool16.not = icmp eq %struct.io_wq* %1, null
  br i1 %tobool16.not, label %if.end30, label %if.then29, !prof !8

if.then29:                                        ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 8598; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !10
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 0
  %2 = load i32, i32* %cached_refs, align 8
  %tobool40.not = icmp eq i32 %2, 0
  br i1 %tobool40.not, label %if.end54, label %if.then53, !prof !8

if.then53:                                        ; preds = %if.end30
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 8599; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !11
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end30
  %inflight = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 5
  call void @percpu_counter_destroy(%struct.percpu_counter* noundef %inflight) #27
  %3 = bitcast %struct.io_uring_task* %0 to i8*
  call void @kfree(i8* noundef %3) #27
  store %struct.io_uring_task* null, %struct.io_uring_task** %io_uring, align 8
  ret void
}

; Function Attrs: argmemonly mustprogress nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @xa_empty(%struct.xarray* nocapture noundef readonly %xa) unnamed_addr #3 {
entry:
  %xa_head = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 2
  %0 = load i8*, i8** %xa_head, align 8
  %cmp = icmp eq i8* %0, null
  ret i1 %cmp
}

; Function Attrs: argmemonly mustprogress nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_counter_destroy(%struct.percpu_counter* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @kfree(i8* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define dso_local void @__io_uring_cancel(i1 noundef %cancel_all) local_unnamed_addr #1 {
entry:
  call fastcc void @io_uring_cancel_generic(i1 noundef %cancel_all, %struct.io_sq_data* noundef null) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_cancel_generic(i1 noundef %cancel_all, %struct.io_sq_data* noundef readonly %sqd) unnamed_addr #1 {
entry:
  %wait = alloca %struct.wait_queue_entry, align 8
  %index = alloca i64, align 8
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %3 = bitcast %struct.wait_queue_entry* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %3) #26
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %4 = bitcast i8** %private to %struct.task_struct**
  %5 = bitcast %struct.wait_queue_entry* %wait to i64*
  store i64 0, i64* %5, align 8
  store %struct.task_struct* %1, %struct.task_struct** %4, align 8
  %func = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 2
  store i32 (%struct.wait_queue_entry*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func, align 8
  %entry2 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry2, i64 0, i32 0
  store %struct.list_head* %entry2, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3, i32 1
  store %struct.list_head* %entry2, %struct.list_head** %prev, align 8
  %tobool.not = icmp eq %struct.io_sq_data* %sqd, null
  br i1 %tobool.not, label %if.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 4
  %6 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %cmp.not = icmp eq %struct.task_struct* %6, %1
  br i1 %cmp.not, label %if.end, label %if.then, !prof !8

if.then:                                          ; preds = %land.rhs
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9759; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !13
  %.pre = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then, %land.rhs
  %7 = phi %struct.io_uring_task* [ %2, %entry ], [ %.pre, %if.then ], [ %2, %land.rhs ]
  %tobool22.not = icmp eq %struct.io_uring_task* %7, null
  br i1 %tobool22.not, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.end
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 4
  %8 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool25.not = icmp eq %struct.io_wq* %8, null
  br i1 %tobool25.not, label %if.end28, label %if.then26

if.then26:                                        ; preds = %if.end24
  call void @io_wq_exit_start(%struct.io_wq* noundef nonnull %8) #27
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end24
  %in_idle = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 7
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %in_idle) #27
  call fastcc void @io_uring_drop_tctx_refs(%struct.task_struct* noundef %1) #25
  %lnot31 = xor i1 %cancel_all, true
  %call33130 = call fastcc i64 @tctx_inflight(%struct.io_uring_task* noundef %2, i1 noundef %lnot31) #25
  %tobool34.not131 = icmp eq i64 %call33130, 0
  br i1 %tobool34.not131, label %do.end85, label %if.end36.lr.ph

if.end36.lr.ph:                                   ; preds = %if.end28
  %ctx_list = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 3
  %9 = bitcast %struct.list_head* %ctx_list to i8**
  %10 = bitcast i64* %index to i8*
  %xa = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 1
  %wait73 = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 2
  br label %if.end36

if.end36:                                         ; preds = %if.end36.lr.ph, %if.end82
  %call33132 = phi i64 [ %call33130, %if.end36.lr.ph ], [ %call33, %if.end82 ]
  br i1 %tobool.not, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end36
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #26
  store i64 0, i64* %index, align 8
  %call39 = call i8* @xa_find(%struct.xarray* noundef %xa, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool40.not128 = icmp eq i8* %call39, null
  br i1 %tobool40.not128, label %for.end, label %for.body

for.body:                                         ; preds = %if.then38, %for.inc
  %node.0.in129 = phi i8* [ %call49, %for.inc ], [ %call39, %if.then38 ]
  %ctx41 = getelementptr inbounds i8, i8* %node.0.in129, i64 24
  %11 = bitcast i8* %ctx41 to %struct.io_ring_ctx**
  %12 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %11, align 8
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %12, i64 0, i32 5
  %13 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool42.not = icmp eq %struct.io_sq_data* %13, null
  br i1 %tobool42.not, label %if.end44, label %for.inc

if.end44:                                         ; preds = %for.body
  call fastcc void @io_uring_try_cancel_requests(%struct.io_ring_ctx* noundef %12, %struct.task_struct* noundef %1, i1 noundef %cancel_all) #25
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end44
  %call49 = call i8* @xa_find_after(%struct.xarray* noundef %xa, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool40.not = icmp eq i8* %call49, null
  br i1 %tobool40.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.then38
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #26
  br label %if.end72

if.else:                                          ; preds = %if.end36
  %.pn125 = load i8*, i8** %9, align 8
  %14 = bitcast i8* %.pn125 to %struct.list_head*
  %cmp55.not126 = icmp eq %struct.list_head* %ctx_list, %14
  br i1 %cmp55.not126, label %if.end72, label %for.body59

for.body59:                                       ; preds = %if.else, %for.body59
  %.pn127 = phi i8* [ %.pn, %for.body59 ], [ %.pn125, %if.else ]
  %ctx.0.in = getelementptr i8, i8* %.pn127, i64 -960
  %ctx.0 = bitcast i8* %ctx.0.in to %struct.io_ring_ctx*
  call fastcc void @io_uring_try_cancel_requests(%struct.io_ring_ctx* noundef %ctx.0, %struct.task_struct* noundef %1, i1 noundef %cancel_all) #25
  %15 = bitcast i8* %.pn127 to i8**
  %.pn = load i8*, i8** %15, align 8
  %16 = bitcast i8* %.pn to %struct.list_head*
  %cmp55.not = icmp eq %struct.list_head* %ctx_list, %16
  br i1 %cmp55.not, label %if.end72, label %for.body59

if.end72:                                         ; preds = %for.body59, %if.else, %for.end
  call void @prepare_to_wait(%struct.wait_queue_head* noundef %wait73, %struct.wait_queue_entry* noundef nonnull %wait, i32 noundef 2) #27
  call fastcc void @io_uring_drop_tctx_refs(%struct.task_struct* noundef %1) #25
  %call78 = call fastcc i64 @tctx_inflight(%struct.io_uring_task* noundef %2, i1 noundef %lnot31) #25
  %cmp79 = icmp eq i64 %call33132, %call78
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end72
  call void @schedule() #27
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %if.end72
  call void @finish_wait(%struct.wait_queue_head* noundef %wait73, %struct.wait_queue_entry* noundef nonnull %wait) #27
  call fastcc void @io_uring_drop_tctx_refs(%struct.task_struct* noundef %1) #25
  %call33 = call fastcc i64 @tctx_inflight(%struct.io_uring_task* noundef %2, i1 noundef %lnot31) #25
  %tobool34.not = icmp eq i64 %call33, 0
  br i1 %tobool34.not, label %do.end85, label %if.end36

do.end85:                                         ; preds = %if.end82, %if.end28
  call fastcc void @__ll_sc_atomic_sub(%struct.atomic_t* noundef %in_idle) #27
  call fastcc void @io_uring_clean_tctx(%struct.io_uring_task* noundef %2) #25
  br i1 %cancel_all, label %if.then88, label %cleanup

if.then88:                                        ; preds = %do.end85
  call void @__io_uring_free(%struct.task_struct* noundef %1) #25
  br label %cleanup

cleanup:                                          ; preds = %do.end85, %if.then88, %if.end
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %3) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define dso_local i64 @__arm64_sys_io_uring_enter(%struct.pt_regs* nocapture noundef readonly %regs) local_unnamed_addr #1 {
entry:
  %arrayidx = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 0
  %0 = load i64, i64* %arrayidx, align 8
  %arrayidx3 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 1
  %1 = load i64, i64* %arrayidx3, align 8
  %arrayidx5 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 2
  %2 = load i64, i64* %arrayidx5, align 8
  %arrayidx7 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 3
  %3 = load i64, i64* %arrayidx7, align 8
  %arrayidx9 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 4
  %4 = load i64, i64* %arrayidx9, align 8
  %arrayidx11 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 5
  %5 = load i64, i64* %arrayidx11, align 8
  %call = call fastcc i64 @__se_sys_io_uring_enter(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__se_sys_io_uring_enter(i64 noundef %fd, i64 noundef %to_submit, i64 noundef %min_complete, i64 noundef %flags, i64 noundef %argp, i64 noundef %argsz) unnamed_addr #1 {
entry:
  %conv = trunc i64 %fd to i32
  %conv1 = trunc i64 %to_submit to i32
  %conv2 = trunc i64 %min_complete to i32
  %conv3 = trunc i64 %flags to i32
  %0 = inttoptr i64 %argp to i8*
  %call = call fastcc i64 @__do_sys_io_uring_enter(i32 noundef %conv, i32 noundef %conv1, i32 noundef %conv2, i32 noundef %conv3, i8* noundef %0, i64 noundef %argsz) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define dso_local i64 @__arm64_sys_io_uring_setup(%struct.pt_regs* nocapture noundef readonly %regs) local_unnamed_addr #1 {
entry:
  %arrayidx = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 0
  %0 = load i64, i64* %arrayidx, align 8
  %arrayidx3 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 1
  %1 = load i64, i64* %arrayidx3, align 8
  %call = call fastcc i64 @__se_sys_io_uring_setup(i64 noundef %0, i64 noundef %1) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__se_sys_io_uring_setup(i64 noundef %entries, i64 noundef %params) unnamed_addr #1 {
entry:
  %conv = trunc i64 %entries to i32
  %0 = inttoptr i64 %params to %struct.io_uring_params*
  %call = call fastcc i64 @__do_sys_io_uring_setup(i32 noundef %conv, %struct.io_uring_params* noundef %0) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define dso_local i64 @__arm64_sys_io_uring_register(%struct.pt_regs* nocapture noundef readonly %regs) local_unnamed_addr #1 {
entry:
  %arrayidx = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 0
  %0 = load i64, i64* %arrayidx, align 8
  %arrayidx3 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 1
  %1 = load i64, i64* %arrayidx3, align 8
  %arrayidx5 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 2
  %2 = load i64, i64* %arrayidx5, align 8
  %arrayidx7 = getelementptr %struct.pt_regs, %struct.pt_regs* %regs, i64 0, i32 0, i32 0, i32 0, i64 3
  %3 = load i64, i64* %arrayidx7, align 8
  %call = call fastcc i64 @__se_sys_io_uring_register(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__se_sys_io_uring_register(i64 noundef %fd, i64 noundef %opcode, i64 noundef %arg, i64 noundef %nr_args) unnamed_addr #1 {
entry:
  %conv = trunc i64 %fd to i32
  %conv1 = trunc i64 %opcode to i32
  %0 = inttoptr i64 %arg to i8*
  %conv2 = trunc i64 %nr_args to i32
  %call = call fastcc i64 @__do_sys_io_uring_register(i32 noundef %conv, i32 noundef %conv1, i8* noundef %0, i32 noundef %conv2) #25
  ret i64 %call
}

; Function Attrs: cold noinline nounwind null_pointer_is_valid optsize
define internal i32 @io_uring_init() #5 section ".init.text" {
entry:
  %call = call %struct.kmem_cache* @kmem_cache_create(i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i64 0, i64 0), i32 noundef 216, i32 noundef 8, i32 noundef 270336, void (i8*)* noundef null) #27
  store %struct.kmem_cache* %call, %struct.kmem_cache** @req_cachep, align 8
  ret i32 0
}

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #6

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @autoremove_wake_function(%struct.wait_queue_entry* noundef, i32 noundef, i32 noundef, i8* noundef) #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @io_wq_exit_start(%struct.io_wq* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_drop_tctx_refs(%struct.task_struct* noundef %task) unnamed_addr #1 {
entry:
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 85
  %0 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 0
  %1 = load i32, i32* %cached_refs, align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %cached_refs, align 8
  %inflight = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 5
  %conv = zext i32 %1 to i64
  call fastcc void @percpu_counter_sub(%struct.percpu_counter* noundef %inflight, i64 noundef %conv) #25
  call fastcc void @put_task_struct_many(%struct.task_struct* noundef %task, i32 noundef %1) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @tctx_inflight(%struct.io_uring_task* noundef %tctx, i1 noundef %tracked) unnamed_addr #1 {
entry:
  br i1 %tracked, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %counter.i = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 6, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4
  %conv = sext i32 %0 to i64
  br label %return

if.end:                                           ; preds = %entry
  %inflight = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 5
  %call1 = call fastcc i64 @percpu_counter_sum(%struct.percpu_counter* noundef %inflight) #25
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %call1, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @xa_find(%struct.xarray* noundef, i64* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_try_cancel_requests(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task, i1 noundef %cancel_all) unnamed_addr #1 {
entry:
  %cancel = alloca %struct.io_task_cancel, align 8
  %frombool = zext i1 %cancel_all to i8
  %0 = bitcast %struct.io_task_cancel* %cancel to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %0) #26
  %1 = getelementptr inbounds %struct.io_task_cancel, %struct.io_task_cancel* %cancel, i64 0, i32 1
  %2 = bitcast i8* %1 to i64*, !annotation !14
  store i64 0, i64* %2, align 8, !annotation !14
  %task1 = getelementptr inbounds %struct.io_task_cancel, %struct.io_task_cancel* %cancel, i64 0, i32 0
  store %struct.task_struct* %task, %struct.task_struct** %task1, align 8
  %all = getelementptr inbounds %struct.io_task_cancel, %struct.io_task_cancel* %cancel, i64 0, i32 1
  store i8 %frombool, i8* %all, align 8
  %tobool3.not = icmp eq %struct.task_struct* %task, null
  br i1 %tobool3.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 85
  %3 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi %struct.io_uring_task* [ %3, %cond.true ], [ null, %entry ]
  %tobool9.not = icmp eq %struct.io_uring_task* %cond, null
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %cond, i64 0, i32 4
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 2
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %cond.end
  br i1 %tobool3.not, label %if.then, label %if.else

if.then:                                          ; preds = %while.cond
  %call = call fastcc i1 @io_uring_try_cancel_iowq(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end20

if.else:                                          ; preds = %while.cond
  br i1 %tobool9.not, label %if.end20, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %4 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool10.not = icmp eq %struct.io_wq* %4, null
  br i1 %tobool10.not, label %if.end20, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %call13 = call i32 @io_wq_cancel_cb(%struct.io_wq* noundef nonnull %4, i1 (%struct.io_wq_work*, i8*)* noundef nonnull @io_cancel_task_cb, i8* noundef nonnull %0, i1 noundef true) #27
  %cmp = icmp ne i32 %call13, 2
  br label %if.end20

if.end20:                                         ; preds = %if.else, %land.lhs.true, %if.then11, %if.then
  %ret.0.shrunk = phi i1 [ %cmp, %if.then11 ], [ false, %land.lhs.true ], [ false, %if.else ], [ %call, %if.then ]
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 2
  %tobool21.not = icmp eq i32 %and, 0
  %6 = and i1 %tobool21.not, %cancel_all
  br i1 %6, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %7 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool25.not = icmp eq %struct.io_sq_data* %7, null
  br i1 %tobool25.not, label %if.end36, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %lor.lhs.false
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %7, i64 0, i32 4
  %8 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %9 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %10 = inttoptr i64 %9 to %struct.task_struct*
  %cmp29 = icmp eq %struct.task_struct* %8, %10
  br i1 %cmp29, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end20, %land.lhs.true26
  %call33115 = call fastcc i32 @list_empty_careful(%struct.list_head* noundef %iopoll_list) #25
  %tobool34.not116 = icmp eq i32 %call33115, 0
  br i1 %tobool34.not116, label %while.body35, label %if.end36

while.body35:                                     ; preds = %if.then31, %while.body35
  call fastcc void @io_iopoll_try_reap_events(%struct.io_ring_ctx* noundef %ctx) #25
  %call33 = call fastcc i32 @list_empty_careful(%struct.list_head* noundef %iopoll_list) #25
  %tobool34.not = icmp eq i32 %call33, 0
  br i1 %tobool34.not, label %while.body35, label %if.end36

if.end36:                                         ; preds = %while.body35, %if.then31, %land.lhs.true26, %lor.lhs.false
  %ret.2.off0 = phi i1 [ %ret.0.shrunk, %land.lhs.true26 ], [ %ret.0.shrunk, %lor.lhs.false ], [ %ret.0.shrunk, %if.then31 ], [ true, %while.body35 ]
  %call38 = call fastcc i1 @io_cancel_defer_files(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task, i1 noundef %cancel_all) #25
  %or42109 = or i1 %ret.2.off0, %call38
  %call46 = call fastcc i1 @io_poll_remove_all(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task, i1 noundef %cancel_all) #25
  %or50110 = or i1 %or42109, %call46
  %call54 = call fastcc i1 @io_kill_timeouts(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task, i1 noundef %cancel_all) #25
  %or58111 = or i1 %or50110, %call54
  br i1 %tobool3.not, label %if.end70, label %if.then62

if.then62:                                        ; preds = %if.end36
  %call63 = call fastcc i1 @io_run_task_work() #25
  %or67112 = or i1 %or58111, %call63
  br i1 %or67112, label %cleanup, label %while.end76

if.end70:                                         ; preds = %if.end36
  br i1 %or58111, label %cleanup, label %while.end76

cleanup:                                          ; preds = %if.end70, %if.then62
  call fastcc void @_cond_resched() #25
  br label %while.cond

while.end76:                                      ; preds = %if.end70, %if.then62
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %0) #26
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @xa_find_after(%struct.xarray* noundef, i64* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @prepare_to_wait(%struct.wait_queue_head* noundef, %struct.wait_queue_entry* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @schedule() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @finish_wait(%struct.wait_queue_head* noundef, %struct.wait_queue_entry* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_clean_tctx(%struct.io_uring_task* noundef %tctx) unnamed_addr #1 {
entry:
  %index = alloca i64, align 8
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 4
  %0 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %1 = bitcast i64* %index to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %1) #26
  store i64 0, i64* %index, align 8
  %xa = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 1
  %call = call i8* @xa_find(%struct.xarray* noundef %xa, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool.not12 = icmp eq i8* %call, null
  br i1 %tobool.not12, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %2 = load i64, i64* %index, align 8
  call fastcc void @io_uring_del_tctx_node(i64 noundef %2) #25
  call fastcc void @_cond_resched() #25
  %call3 = call i8* @xa_find_after(%struct.xarray* noundef %xa, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool.not = icmp eq i8* %call3, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %tobool4.not = icmp eq %struct.io_wq* %0, null
  br i1 %tobool4.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.end
  call void @io_wq_put_and_exit(%struct.io_wq* noundef nonnull %0) #27
  store %struct.io_wq* null, %struct.io_wq** %io_wq, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %1) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i64 0, i32 0
  %0 = call { i32, i64 } asm sideeffect "// atomic_add\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09${0:w}, $2\0A\09add\09${0:w}, ${0:w}, ${3:w}\0A\09stxr\09${1:w}, ${0:w}, $2\0A\09cbnz\09${1:w}, 1b\0A", "=&r,=&r,=*Q,Ir,*Q"(i32* elementtype(i32) %counter, i32 1, i32* elementtype(i32) %counter) #26, !srcloc !15
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_counter_sub(%struct.percpu_counter* noundef %fbc, i64 noundef %amount) unnamed_addr #1 {
entry:
  %sub = sub i64 0, %amount
  call fastcc void @percpu_counter_add(%struct.percpu_counter* noundef %fbc, i64 noundef %sub) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @put_task_struct_many(%struct.task_struct* noundef %t, i32 noundef %nr) unnamed_addr #1 {
entry:
  %usage = getelementptr inbounds %struct.task_struct, %struct.task_struct* %t, i64 0, i32 3
  %call = call fastcc i1 @refcount_sub_and_test(i32 noundef %nr, %struct.refcount_struct* noundef %usage) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_task_struct(%struct.task_struct* noundef %t) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_counter_add(%struct.percpu_counter* noundef %fbc, i64 noundef %amount) unnamed_addr #1 {
entry:
  %0 = load i32, i32* @percpu_counter_batch, align 4
  call void @percpu_counter_add_batch(%struct.percpu_counter* noundef %fbc, i64 noundef %amount, i32 noundef %0) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_counter_add_batch(%struct.percpu_counter* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @refcount_sub_and_test(i32 noundef %i, %struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__refcount_sub_and_test(i32 noundef %i, %struct.refcount_struct* noundef %r) #25
  ret i1 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__put_task_struct(%struct.task_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__refcount_sub_and_test(i32 noundef %i, %struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.refcount_struct, %struct.refcount_struct* %r, i64 0, i32 0
  %call.i.i = call fastcc i32 @__ll_sc_atomic_fetch_sub_release(i32 noundef %i, %struct.atomic_t* noundef %refs) #27
  %cmp = icmp eq i32 %call.i.i, %i
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %entry
  call void asm sideeffect "dmb ishld", "~{memory}"() #26, !srcloc !16
  br label %cleanup

if.end2:                                          ; preds = %entry
  %sub = sub i32 %call.i.i, %i
  %0 = or i32 %sub, %call.i.i
  %.not = icmp sgt i32 %0, -1
  br i1 %.not, label %cleanup, label %if.then7, !prof !8

if.then7:                                         ; preds = %if.end2
  call void @refcount_warn_saturate(%struct.refcount_struct* noundef %r, i32 noundef 3) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.then7, %if.then1
  ret i1 %cmp
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @refcount_warn_saturate(%struct.refcount_struct* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__ll_sc_atomic_fetch_sub_release(i32 noundef %i, %struct.atomic_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i64 0, i32 0
  %0 = call { i32, i32, i64 } asm sideeffect "// atomic_fetch_sub_release\0A\09prfm\09pstl1strm, $3\0A1:\09ldxr\09${0:w}, $3\0A\09sub\09${1:w}, ${0:w}, ${4:w}\0A\09stlxr\09${2:w}, ${1:w}, $3\0A\09cbnz\09${2:w}, 1b\0A\09", "=&r,=&r,=&r,=*Q,Jr,*Q,~{memory}"(i32* elementtype(i32) %counter, i32 %i, i32* elementtype(i32) %counter) #26, !srcloc !17
  %asmresult = extractvalue { i32, i32, i64 } %0, 0
  ret i32 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @percpu_counter_sum(%struct.percpu_counter* noundef %fbc) unnamed_addr #1 {
entry:
  %call = call i64 @__percpu_counter_sum(%struct.percpu_counter* noundef %fbc) #27
  ret i64 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__percpu_counter_sum(%struct.percpu_counter* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_uring_try_cancel_iowq(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %tctx_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 6
  %0 = bitcast %struct.list_head* %tctx_list to %struct.io_tctx_node**
  %node.039 = load %struct.io_tctx_node*, %struct.io_tctx_node** %0, align 8
  %ctx_node40 = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.039, i64 0, i32 0
  %cmp.not41 = icmp eq %struct.list_head* %ctx_node40, %tctx_list
  br i1 %cmp.not41, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %1 = bitcast %struct.io_ring_ctx* %ctx to i8*
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %cleanup
  %node.043 = phi %struct.io_tctx_node* [ %node.039, %for.body.lr.ph ], [ %node.0, %cleanup ]
  %ret.0.off042 = phi i1 [ false, %for.body.lr.ph ], [ %ret.1.off0, %cleanup ]
  %task = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.043, i64 0, i32 1
  %2 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i64 0, i32 85
  %3 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %3, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %3, i64 0, i32 4
  %4 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool2.not = icmp eq %struct.io_wq* %4, null
  br i1 %tobool2.not, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = call i32 @io_wq_cancel_cb(%struct.io_wq* noundef nonnull %4, i1 (%struct.io_wq_work*, i8*)* noundef nonnull @io_cancel_ctx_cb, i8* noundef %1, i1 noundef true) #27
  %cmp4 = icmp ne i32 %call, 2
  %or38 = or i1 %ret.0.off042, %cmp4
  br label %cleanup

cleanup:                                          ; preds = %for.body, %lor.lhs.false, %if.end
  %ret.1.off0 = phi i1 [ %or38, %if.end ], [ %ret.0.off042, %lor.lhs.false ], [ %ret.0.off042, %for.body ]
  %5 = bitcast %struct.io_tctx_node* %node.043 to %struct.io_tctx_node**
  %node.0 = load %struct.io_tctx_node*, %struct.io_tctx_node** %5, align 8
  %ctx_node = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.0, i64 0, i32 0
  %cmp.not = icmp eq %struct.list_head* %ctx_node, %tctx_list
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %cleanup, %entry
  %ret.0.off0.lcssa = phi i1 [ false, %entry ], [ %ret.1.off0, %cleanup ]
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  ret i1 %ret.0.off0.lcssa
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @io_wq_cancel_cb(%struct.io_wq* noundef, i1 (%struct.io_wq_work*, i8*)* noundef, i8* noundef, i1 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i1 @io_cancel_task_cb(%struct.io_wq_work* noundef readonly %work, i8* nocapture noundef readonly %data) #1 {
entry:
  %add.ptr = getelementptr %struct.io_wq_work, %struct.io_wq_work* %work, i64 -12, i32 1
  %0 = bitcast i32* %add.ptr to %struct.io_kiocb*
  %1 = getelementptr inbounds i8, i8* %data, i64 8
  %2 = load i8, i8* %1, align 8, !range !18
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = getelementptr inbounds i32, i32* %add.ptr, i64 22
  %4 = load i32, i32* %3, align 8
  %and = and i32 %4, 4096
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %ctx2 = getelementptr inbounds i32, i32* %add.ptr, i64 20
  %5 = bitcast i32* %ctx2 to %struct.io_ring_ctx**
  %6 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %5, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %6, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %task = bitcast i8* %data to %struct.task_struct**
  %7 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %8 = load i8, i8* %1, align 8, !range !18
  %tobool4 = icmp ne i8 %8, 0
  %call = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef %0, %struct.task_struct* noundef %7, i1 noundef %tobool4) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %task6 = bitcast i8* %data to %struct.task_struct**
  %9 = load %struct.task_struct*, %struct.task_struct** %task6, align 8
  %tobool8 = icmp ne i8 %2, 0
  %call9 = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef %0, %struct.task_struct* noundef %9, i1 noundef %tobool8) #25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0.in = phi i1 [ %call9, %if.else ], [ %call, %if.then ]
  ret i1 %ret.0.in
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @list_empty_careful(%struct.list_head* noundef %head) unnamed_addr #1 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = call i64 asm sideeffect "ldar $0, $1", "=r,*Q,~{memory}"(%struct.list_head** elementtype(%struct.list_head*) %next1) #26, !srcloc !19
  %1 = inttoptr i64 %0 to %struct.list_head*
  %cmp = icmp eq %struct.list_head* %1, %head
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %cmp2 = icmp eq %struct.list_head* %2, %head
  %phi.cast = zext i1 %cmp2 to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i32 [ 0, %entry ], [ %phi.cast, %land.rhs ]
  ret i32 %3
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_iopoll_try_reap_events(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %nr_events = alloca i32, align 4
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 2
  %call20 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool1.not21 = icmp eq i32 %call20, 0
  br i1 %tobool1.not21, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %if.end
  %1 = bitcast i32* %nr_events to i8*
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %1) #26
  store i32 0, i32* %nr_events, align 4
  %call2 = call fastcc i32 @io_do_iopoll(%struct.io_ring_ctx* noundef %ctx, i32* noundef nonnull %nr_events, i64 noundef 0) #25
  %2 = load i32, i32* %nr_events, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %cleanup.thread, label %if.end4

cleanup.thread:                                   ; preds = %while.body
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1) #26
  br label %while.end

if.end4:                                          ; preds = %while.body
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %5 = getelementptr %struct.task_struct, %struct.task_struct* %4, i64 0, i32 0
  %call1.i = call fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %5, i32 noundef 1) #27
  %tobool.i.not = icmp eq i32 %call1.i, 0
  br i1 %tobool.i.not, label %cleanup, label %if.then6

if.then6:                                         ; preds = %if.end4
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  call fastcc void @_cond_resched() #25
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then6
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1) #26
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %while.body, label %while.end

while.end:                                        ; preds = %cleanup, %if.end, %cleanup.thread
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %return

return:                                           ; preds = %entry, %while.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_cancel_defer_files(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task, i1 noundef %cancel_all) unnamed_addr #1 {
entry:
  %list = alloca %struct.list_head, align 8
  %0 = bitcast %struct.list_head* %list to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %0) #26
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %defer_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 5
  %prev1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 5, i32 1
  %de.0.in48 = bitcast %struct.list_head** %prev1 to %struct.io_defer_entry**
  %de.049 = load %struct.io_defer_entry*, %struct.io_defer_entry** %de.0.in48, align 8
  %list250 = getelementptr inbounds %struct.io_defer_entry, %struct.io_defer_entry* %de.049, i64 0, i32 0
  %cmp.not51 = icmp eq %struct.list_head* %list250, %defer_list
  br i1 %cmp.not51, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %req59 = getelementptr inbounds %struct.io_defer_entry, %struct.io_defer_entry* %de.049, i64 0, i32 1
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %req59, align 8
  %call60 = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef %1, %struct.task_struct* noundef %task, i1 noundef %cancel_all) #25
  br i1 %call60, label %if.then, label %for.cond

for.cond:                                         ; preds = %for.body.preheader, %for.body
  %de.05261 = phi %struct.io_defer_entry* [ %de.0, %for.body ], [ %de.049, %for.body.preheader ]
  %prev8 = getelementptr inbounds %struct.io_defer_entry, %struct.io_defer_entry* %de.05261, i64 0, i32 0, i32 1
  %de.0.in = bitcast %struct.list_head** %prev8 to %struct.io_defer_entry**
  %de.0 = load %struct.io_defer_entry*, %struct.io_defer_entry** %de.0.in, align 8
  %list2 = getelementptr inbounds %struct.io_defer_entry, %struct.io_defer_entry* %de.0, i64 0, i32 0
  %cmp.not = icmp eq %struct.list_head* %list2, %defer_list
  br i1 %cmp.not, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %req = getelementptr inbounds %struct.io_defer_entry, %struct.io_defer_entry* %de.0, i64 0, i32 1
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %req, align 8
  %call = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef %2, %struct.task_struct* noundef %task, i1 noundef %cancel_all) #25
  br i1 %call, label %if.then, label %for.cond

if.then:                                          ; preds = %for.body, %for.body.preheader
  %list253.lcssa = phi %struct.list_head* [ %list250, %for.body.preheader ], [ %list2, %for.body ]
  call fastcc void @list_cut_position(%struct.list_head* noundef nonnull %list, %struct.list_head* noundef %defer_list, %struct.list_head* noundef %list253.lcssa) #25
  br label %for.end

for.end:                                          ; preds = %for.cond, %entry, %if.then
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %call15 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %list) #25
  %tobool16.not = icmp eq i32 %call15, 0
  br i1 %tobool16.not, label %while.cond.preheader, label %cleanup

while.cond.preheader:                             ; preds = %for.end
  %call1954 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %list) #25
  %tobool20.not55 = icmp eq i32 %call1954, 0
  br i1 %tobool20.not55, label %while.body.lr.ph, label %cleanup

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %3 = bitcast %struct.list_head* %list to i8**
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %4 = load i8*, i8** %3, align 8
  %list29 = bitcast i8* %4 to %struct.list_head*
  call fastcc void @list_del_init(%struct.list_head* noundef %list29) #25
  %req30 = getelementptr inbounds i8, i8* %4, i64 16
  %5 = bitcast i8* %req30 to %struct.io_kiocb**
  %6 = load %struct.io_kiocb*, %struct.io_kiocb** %5, align 8
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %6, i64 noundef -125) #25
  call void @kfree(i8* noundef %4) #27
  %call19 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %list) #25
  %tobool20.not = icmp eq i32 %call19, 0
  br i1 %tobool20.not, label %while.body, label %cleanup

cleanup:                                          ; preds = %while.body, %while.cond.preheader, %for.end
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %0) #26
  ret i1 %tobool16.not
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_poll_remove_all(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %tsk, i1 noundef %cancel_all) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %cancel_hash_bits = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 4
  %cancel_hash = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 3
  br label %for.body

for.body:                                         ; preds = %entry, %for.end
  %posted.063 = phi i32 [ 0, %entry ], [ %posted.1.lcssa, %for.end ]
  %i.062 = phi i32 [ 0, %entry ], [ %inc, %for.end ]
  %0 = load %struct.hlist_head*, %struct.hlist_head** %cancel_hash, align 8
  %idxprom = sext i32 %i.062 to i64
  %first = getelementptr %struct.hlist_head, %struct.hlist_head* %0, i64 %idxprom, i32 0
  %1 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8
  %tobool.not = icmp eq %struct.hlist_node* %1, null
  %add.ptr55 = getelementptr %struct.hlist_node, %struct.hlist_node* %1, i64 -10
  %tobool4.not5964 = icmp eq %struct.hlist_node* %add.ptr55, null
  %tobool4.not59 = or i1 %tobool.not, %tobool4.not5964
  br i1 %tobool4.not59, label %for.end, label %land.rhs.preheader

land.rhs.preheader:                               ; preds = %for.body
  %2 = bitcast %struct.hlist_node* %add.ptr55 to %struct.io_kiocb*
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.preheader, %for.inc
  %req.061 = phi %struct.io_kiocb* [ %spec.select58, %for.inc ], [ %2, %land.rhs.preheader ]
  %posted.160 = phi i32 [ %posted.2, %for.inc ], [ %posted.063, %land.rhs.preheader ]
  %next = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.061, i64 0, i32 15, i32 0
  %3 = load %struct.hlist_node*, %struct.hlist_node** %next, align 8
  %call = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef nonnull %req.061, %struct.task_struct* noundef %tsk, i1 noundef %cancel_all) #25
  br i1 %call, label %if.then, label %for.inc

if.then:                                          ; preds = %land.rhs
  %call9 = call fastcc i1 @io_poll_remove_one(%struct.io_kiocb* noundef nonnull %req.061) #25
  %conv = zext i1 %call9 to i32
  %add = add i32 %posted.160, %conv
  br label %for.inc

for.inc:                                          ; preds = %land.rhs, %if.then
  %posted.2 = phi i32 [ %add, %if.then ], [ %posted.160, %land.rhs ]
  %tobool12.not = icmp eq %struct.hlist_node* %3, null
  %add.ptr1954 = getelementptr %struct.hlist_node, %struct.hlist_node* %3, i64 -10
  %4 = bitcast %struct.hlist_node* %add.ptr1954 to %struct.io_kiocb*
  %spec.select58 = select i1 %tobool12.not, %struct.io_kiocb* null, %struct.io_kiocb* %4
  %tobool4.not = icmp eq %struct.io_kiocb* %spec.select58, null
  br i1 %tobool4.not, label %for.end, label %land.rhs

for.end:                                          ; preds = %for.inc, %for.body
  %posted.1.lcssa = phi i32 [ %posted.063, %for.body ], [ %posted.2, %for.inc ]
  %inc = add i32 %i.062, 1
  %5 = load i32, i32* %cancel_hash_bits, align 32
  %i.0.highbits = lshr i32 %inc, %5
  %cmp = icmp eq i32 %i.0.highbits, 0
  br i1 %cmp, label %for.body, label %for.end24

for.end24:                                        ; preds = %for.end
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %tobool26 = icmp ne i32 %posted.1.lcssa, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %for.end24
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %for.end24
  ret i1 %tobool26
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_kill_timeouts(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %tsk, i1 noundef %cancel_all) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %rlock.i51 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i51) #27
  %timeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 12
  %0 = bitcast %struct.list_head* %timeout_list to i8**
  %1 = load i8*, i8** %0, align 8
  %2 = bitcast i8* %1 to %struct.list_head*
  %cmp.not59 = icmp eq %struct.list_head* %timeout_list, %2
  br i1 %cmp.not59, label %for.end.thread, label %for.body

for.end.thread:                                   ; preds = %entry
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i51) #27
  br label %if.end28.critedge

for.body:                                         ; preds = %entry, %for.inc
  %.pn62.in.in = phi i8* [ %.pn62, %for.inc ], [ %1, %entry ]
  %canceled.060 = phi i32 [ %canceled.1, %for.inc ], [ 0, %entry ]
  %req.061.in = getelementptr i8, i8* %.pn62.in.in, i64 -16
  %req.061 = bitcast i8* %req.061.in to %struct.io_kiocb*
  %.pn62.in = bitcast i8* %.pn62.in.in to i8**
  %.pn62 = load i8*, i8** %.pn62.in, align 8
  %call = call fastcc i1 @io_match_task(%struct.io_kiocb* noundef %req.061, %struct.task_struct* noundef %tsk, i1 noundef %cancel_all) #25
  br i1 %call, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call fastcc void @io_kill_timeout(%struct.io_kiocb* noundef %req.061, i32 noundef -125) #25
  %inc = add i32 %canceled.060, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %canceled.1 = phi i32 [ %inc, %if.then ], [ %canceled.060, %for.body ]
  %3 = bitcast i8* %.pn62 to %struct.list_head*
  %cmp.not = icmp eq %struct.list_head* %timeout_list, %3
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i51) #27
  %cmp22.not = icmp eq i32 %canceled.1, 0
  br i1 %cmp22.not, label %if.end28.critedge, label %if.then23

if.then23:                                        ; preds = %for.end
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end28

if.end28.critedge:                                ; preds = %for.end.thread, %for.end
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end28

if.end28:                                         ; preds = %if.end28.critedge, %if.then23
  %cmp2265 = phi i1 [ false, %if.end28.critedge ], [ true, %if.then23 ]
  ret i1 %cmp2265
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_run_task_work() unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %2 = getelementptr %struct.task_struct, %struct.task_struct* %1, i64 0, i32 0
  %call1 = call fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %2, i32 noundef 6) #25
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %lor.lhs.false, label %do.body8

lor.lhs.false:                                    ; preds = %entry
  %task_works = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 96
  %3 = load %struct.callback_head*, %struct.callback_head** %task_works, align 32
  %tobool3.not = icmp eq %struct.callback_head* %3, null
  br i1 %tobool3.not, label %return, label %do.body8

do.body8:                                         ; preds = %entry, %lor.lhs.false
  %__state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 1
  store volatile i32 0, i32* %__state, align 16
  call fastcc void @tracehook_notify_signal() #25
  br label %return

return:                                           ; preds = %lor.lhs.false, %do.body8
  %retval.0 = phi i1 [ true, %do.body8 ], [ false, %lor.lhs.false ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @_cond_resched() unnamed_addr #1 {
entry:
  %call = call i32 @__cond_resched() #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_lock(%struct.mutex* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal i1 @io_cancel_ctx_cb(%struct.io_wq_work* nocapture noundef readonly %work, i8* noundef readnone %data) #3 {
entry:
  %add.ptr = getelementptr %struct.io_wq_work, %struct.io_wq_work* %work, i64 -12, i32 1
  %ctx = getelementptr inbounds i32, i32* %add.ptr, i64 20
  %0 = bitcast i32* %ctx to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  %2 = bitcast i8* %data to %struct.io_ring_ctx*
  %cmp = icmp eq %struct.io_ring_ctx* %1, %2
  ret i1 %cmp
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_unlock(%struct.mutex* noundef) local_unnamed_addr #4

; Function Attrs: nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly
define internal fastcc i1 @io_match_task(%struct.io_kiocb* noundef readonly %head, %struct.task_struct* noundef readnone %task, i1 noundef %cancel_all) unnamed_addr #7 {
entry:
  %tobool.not = icmp eq %struct.task_struct* %task, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %task1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %head, i64 0, i32 9
  %0 = load %struct.task_struct*, %struct.task_struct** %task1, align 8
  %cmp.not = icmp ne %struct.task_struct* %0, %task
  %brmerge = or i1 %cmp.not, %cancel_all
  %not.cmp.not = xor i1 %cmp.not, true
  br i1 %brmerge, label %cleanup, label %for.cond.preheader

if.end:                                           ; preds = %entry
  br i1 %cancel_all, label %cleanup, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end, %land.lhs.true
  %tobool5.not14 = icmp eq %struct.io_kiocb* %head, null
  br i1 %tobool5.not14, label %cleanup, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %req.015 = phi %struct.io_kiocb* [ %2, %for.inc ], [ %head, %for.cond.preheader ]
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.015, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 512
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %for.inc, label %cleanup.loopexit

for.inc:                                          ; preds = %for.body
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.015, i64 0, i32 11
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %tobool5.not = icmp eq %struct.io_kiocb* %2, null
  br i1 %tobool5.not, label %cleanup.loopexit, label %for.body

cleanup.loopexit:                                 ; preds = %for.inc, %for.body
  %3 = xor i1 %tobool6.not, true
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %for.cond.preheader, %land.lhs.true, %if.end
  %retval.0 = phi i1 [ %not.cmp.not, %land.lhs.true ], [ true, %if.end ], [ false, %for.cond.preheader ], [ %3, %cleanup.loopexit ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !20
  call fastcc void @do_raw_spin_lock(%struct.raw_spinlock* noundef %lock) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @do_raw_spin_lock(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.raw_spinlock* %lock to i8*
  %call11.i.i.i.i = call fastcc i32 @__cmpxchg_case_acq_32(i8* noundef %0, i32 noundef 0) #27
  %cmp.not.i.i.i = icmp eq i32 %call11.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %queued_spin_lock.exit, label %if.end.i, !prof !8

if.end.i:                                         ; preds = %entry
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i64 0, i32 0
  call void @queued_spin_lock_slowpath(%struct.qspinlock* noundef %raw_lock, i32 noundef %call11.i.i.i.i) #27
  br label %queued_spin_lock.exit

queued_spin_lock.exit:                            ; preds = %entry, %if.end.i
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @queued_spin_lock_slowpath(%struct.qspinlock* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__cmpxchg_case_acq_32(i8* noundef %ptr, i32 noundef %old) unnamed_addr #1 {
entry:
  %conv = zext i32 %old to i64
  %call = call fastcc i32 @__ll_sc__cmpxchg_case_acq_32(i8* noundef %ptr, i64 noundef %conv) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__ll_sc__cmpxchg_case_acq_32(i8* noundef %ptr, i64 noundef %old) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i32*
  %1 = call { i64, i32 } asm sideeffect "\09prfm\09pstl1strm, $2\0A1:\09ldaxr\09${1:w}, $2\0A\09eor\09${0:w}, ${1:w}, ${3:w}\0A\09cbnz\09${0:w}, 2f\0A\09stxr\09${0:w}, ${4:w}, $2\0A\09cbnz\09${0:w}, 1b\0A\09\0A2:", "=&r,=&r,=*Q,Kr,r,*Q,~{memory}"(i32* elementtype(i32) %0, i64 %old, i32 1, i32* elementtype(i32) %0) #26, !srcloc !21
  %asmresult1 = extractvalue { i64, i32 } %1, 1
  ret i32 %asmresult1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  call fastcc void @do_raw_spin_unlock(%struct.raw_spinlock* noundef %lock) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !22
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @do_raw_spin_unlock(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  %locked.i = bitcast %struct.raw_spinlock* %lock to i8*
  call void asm sideeffect "stlrb ${1:w}, $0", "=*Q,r,~{memory}"(i8* elementtype(i8) %locked.i, i8 0) #26, !srcloc !23
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @list_empty(%struct.list_head* noundef %head) unnamed_addr #8 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load volatile %struct.list_head*, %struct.list_head** %next, align 8
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_do_iopoll(%struct.io_ring_ctx* noundef %ctx, i32* nocapture noundef %nr_events, i64 noundef %min) unnamed_addr #1 {
entry:
  %done = alloca %struct.list_head, align 8
  %0 = bitcast %struct.list_head* %done to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %0) #26
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %done, i64 0, i32 0
  store %struct.list_head* %done, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %done, i64 0, i32 1
  store %struct.list_head* %done, %struct.list_head** %prev, align 8
  %poll_multi_queue = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 5
  %1 = load i8, i8* %poll_multi_queue, align 4, !range !18
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %nr_events, align 4
  %conv = zext i32 %2 to i64
  %cmp = icmp slt i64 %conv, %min
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 2
  %4 = bitcast %struct.list_head* %iopoll_list to i8**
  %5 = load i8*, i8** %4, align 8
  %6 = bitcast i8* %5 to %struct.list_head*
  %cmp13.not104 = icmp eq %struct.list_head* %iopoll_list, %6
  br i1 %cmp13.not104, label %for.end, label %for.body

for.body:                                         ; preds = %land.end, %for.inc
  %7 = phi %struct.list_head* [ %14, %for.inc ], [ %6, %land.end ]
  %.pn.in.in106 = phi i8* [ %.pn108, %for.inc ], [ %5, %land.end ]
  %spin.0.off0105 = phi i1 [ %spin.2.off0.ph, %for.inc ], [ %3, %land.end ]
  %req.0.in107 = getelementptr i8, i8* %.pn.in.in106, i64 -128
  %.pn108.in = bitcast i8* %.pn.in.in106 to i8**
  %.pn108 = load i8*, i8** %.pn108.in, align 8
  %kiocb15 = bitcast i8* %req.0.in107 to %struct.kiocb*
  %8 = getelementptr i8, i8* %.pn.in.in106, i64 -55
  %9 = load volatile i8, i8* %8, align 1
  %tobool20.not = icmp eq i8 %9, 0
  br i1 %tobool20.not, label %if.end, label %for.inc.sink.split

if.end:                                           ; preds = %for.body
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %done) #25
  %tobool22.not = icmp eq i32 %call, 0
  br i1 %tobool22.not, label %for.end, label %if.end24

if.end24:                                         ; preds = %if.end
  %ki_filp = bitcast i8* %req.0.in107 to %struct.file**
  %10 = load %struct.file*, %struct.file** %ki_filp, align 8
  %f_op = getelementptr inbounds %struct.file, %struct.file* %10, i64 0, i32 3
  %11 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %iopoll = getelementptr inbounds %struct.file_operations, %struct.file_operations* %11, i64 0, i32 6
  %12 = load i32 (%struct.kiocb*, i1)*, i32 (%struct.kiocb*, i1)** %iopoll, align 8
  %call26 = call i32 %12(%struct.kiocb* noundef %kiocb15, i1 noundef %spin.0.off0105) #27
  %cmp27 = icmp slt i32 %call26, 0
  br i1 %cmp27, label %cleanup60, label %if.else, !prof !24

if.else:                                          ; preds = %if.end24
  %tobool34.not = icmp eq i32 %call26, 0
  %spec.select = select i1 %tobool34.not, i1 %spin.0.off0105, i1 false
  %13 = load volatile i8, i8* %8, align 1
  %tobool43.not = icmp eq i8 %13, 0
  br i1 %tobool43.not, label %for.inc, label %for.inc.sink.split

for.inc.sink.split:                               ; preds = %if.else, %for.body
  %spin.2.off0.ph.ph = phi i1 [ %spin.0.off0105, %for.body ], [ %spec.select, %if.else ]
  call fastcc void @list_move_tail(%struct.list_head* noundef %7, %struct.list_head* noundef nonnull %done) #25
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %if.else
  %spin.2.off0.ph = phi i1 [ %spec.select, %if.else ], [ %spin.2.off0.ph.ph, %for.inc.sink.split ]
  %14 = bitcast i8* %.pn108 to %struct.list_head*
  %cmp13.not = icmp eq %struct.list_head* %iopoll_list, %14
  br i1 %cmp13.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.end, %land.end
  %call56 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %done) #25
  %tobool57.not = icmp eq i32 %call56, 0
  br i1 %tobool57.not, label %if.then58, label %cleanup60

if.then58:                                        ; preds = %for.end
  call fastcc void @io_iopoll_complete(%struct.io_ring_ctx* noundef %ctx, i32* noundef %nr_events, %struct.list_head* noundef nonnull %done) #25
  br label %cleanup60

cleanup60:                                        ; preds = %if.end24, %for.end, %if.then58
  %retval.2 = phi i32 [ 0, %if.then58 ], [ 0, %for.end ], [ %call26, %if.end24 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %0) #26
  ret i32 %retval.2
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_move_tail(%struct.list_head* noundef %list, %struct.list_head* noundef %head) unnamed_addr #9 {
entry:
  call fastcc void @__list_del_entry(%struct.list_head* noundef %list) #25
  call fastcc void @list_add_tail(%struct.list_head* noundef %list, %struct.list_head* noundef %head) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_iopoll_complete(%struct.io_ring_ctx* noundef %ctx, i32* nocapture noundef %nr_events, %struct.list_head* noundef %done) unnamed_addr #1 {
entry:
  %rb = alloca %struct.req_batch, align 8
  %0 = bitcast %struct.req_batch* %rb to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %0, i8 0, i64 16, i1 false), !annotation !14
  call void asm sideeffect "dmb ishld", "~{memory}"() #26, !srcloc !25
  call fastcc void @io_init_req_batch(%struct.req_batch* noundef nonnull %rb) #25
  %call16 = call fastcc i32 @list_empty(%struct.list_head* noundef %done) #25
  %tobool.not17 = icmp eq i32 %call16, 0
  br i1 %tobool.not17, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %entry
  %1 = bitcast %struct.list_head* %done to i8**
  %submit_state = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end
  %2 = load i8*, i8** %1, align 8
  %add.ptr = getelementptr i8, i8* %2, i64 -128
  %3 = bitcast i8* %add.ptr to %struct.io_kiocb*
  %4 = bitcast i8* %2 to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %4) #25
  %user_data = getelementptr i8, i8* %2, i64 -24
  %5 = bitcast i8* %user_data to i64*
  %6 = load i64, i64* %5, align 8
  %result = getelementptr i8, i8* %2, i64 -52
  %7 = bitcast i8* %result to i32*
  %8 = load i32, i32* %7, align 4
  %conv = zext i32 %8 to i64
  %call1 = call fastcc i32 @io_put_rw_kbuf(%struct.io_kiocb* noundef %3) #25
  %call2 = call fastcc i1 @__io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %6, i64 noundef %conv, i32 noundef %call1) #25
  %9 = load i32, i32* %nr_events, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %nr_events, align 4
  %call3 = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %3) #25
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  call fastcc void @io_req_free_batch(%struct.req_batch* noundef nonnull %rb, %struct.io_kiocb* noundef %3, %struct.io_submit_state* noundef %submit_state) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %done) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %while.body, label %while.end

while.end:                                        ; preds = %if.end, %entry
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_cqring_ev_posted_iopoll(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_req_free_batch_finish(%struct.io_ring_ctx* noundef %ctx, %struct.req_batch* noundef nonnull %rb) #25
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %0) #26
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @__list_del_entry(%struct.list_head* nocapture noundef readonly %entry1) unnamed_addr #9 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  call fastcc void @__list_del(%struct.list_head* noundef %0, %struct.list_head* noundef %1) #25
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_add_tail(%struct.list_head* noundef %new, %struct.list_head* noundef %head) unnamed_addr #9 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8
  call fastcc void @__list_add(%struct.list_head* noundef %new, %struct.list_head* noundef %0, %struct.list_head* noundef %head) #25
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @__list_del(%struct.list_head* noundef %prev, %struct.list_head* noundef %next) unnamed_addr #9 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i64 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i64 0, i32 0
  store volatile %struct.list_head* %next, %struct.list_head** %next4, align 8
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @__list_add(%struct.list_head* noundef %new, %struct.list_head* noundef %prev, %struct.list_head* noundef %next) unnamed_addr #9 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i64 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i64 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i64 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i64 0, i32 0
  store volatile %struct.list_head* %new, %struct.list_head** %next6, align 8
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @io_init_req_batch(%struct.req_batch* nocapture noundef writeonly %rb) unnamed_addr #10 {
entry:
  %task_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 1
  store i32 0, i32* %task_refs, align 8
  %ctx_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 2
  store i32 0, i32* %ctx_refs, align 4
  %task = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 0
  store %struct.task_struct* null, %struct.task_struct** %task, align 8
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_del(%struct.list_head* nocapture noundef %entry1) unnamed_addr #9 {
entry:
  call fastcc void @__list_del_entry(%struct.list_head* noundef %entry1) #25
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 0
  store %struct.list_head* inttoptr (i64 -2401263026318606080 to %struct.list_head*), %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 1
  store %struct.list_head* inttoptr (i64 -2401263026318606046 to %struct.list_head*), %struct.list_head** %prev, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_uring_cqe* @io_get_cqe(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool.not = icmp eq %struct.io_uring_cqe* %call, null
  br i1 %tobool.not, label %if.end, label %do.body5, !prof !24

do.body5:                                         ; preds = %entry
  %conv = trunc i64 %res to i32
  %user_data6 = getelementptr inbounds %struct.io_uring_cqe, %struct.io_uring_cqe* %call, i64 0, i32 0
  store volatile i64 %user_data, i64* %user_data6, align 8
  %res17 = getelementptr inbounds %struct.io_uring_cqe, %struct.io_uring_cqe* %call, i64 0, i32 1
  store volatile i32 %conv, i32* %res17, align 8
  %flags = getelementptr inbounds %struct.io_uring_cqe, %struct.io_uring_cqe* %call, i64 0, i32 2
  store volatile i32 %cflags, i32* %flags, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %call31 = call fastcc i1 @io_cqring_event_overflow(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, i64 noundef %res, i32 noundef %cflags) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %do.body5
  %retval.0 = phi i1 [ true, %do.body5 ], [ %call31, %if.end ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_put_rw_kbuf(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 32768
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %cleanup, label %if.end, !prof !8

if.end:                                           ; preds = %entry
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %1 = load i64, i64* %addr, align 8
  %2 = inttoptr i64 %1 to %struct.io_buffer*
  %call = call fastcc i32 @io_put_kbuf(%struct.io_kiocb* noundef %req, %struct.io_buffer* noundef %2) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !8

if.end:                                           ; preds = %entry
  %refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 8
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i64 0, i32 0
  %1 = load volatile i32, i32* %counter.i, align 4
  %add = add i32 %1, 127
  %cmp = icmp ult i32 %add, 128
  br i1 %cmp, label %if.then17, label %if.end18, !prof !24

if.then17:                                        ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1153; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !26
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %refs) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br label %return

return:                                           ; preds = %entry, %if.end18
  %retval.0 = phi i1 [ %cmp.i.i, %if.end18 ], [ true, %entry ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_free_batch(%struct.req_batch* nocapture noundef %rb, %struct.io_kiocb* noundef %req, %struct.io_submit_state* noundef %state) unnamed_addr #1 {
entry:
  call fastcc void @io_queue_next(%struct.io_kiocb* noundef %req) #25
  call fastcc void @io_dismantle_req(%struct.io_kiocb* noundef %req) #25
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %0 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %task1 = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 0
  %1 = load %struct.task_struct*, %struct.task_struct** %task1, align 8
  %cmp.not = icmp eq %struct.task_struct* %0, %1
  br i1 %cmp.not, label %entry.if.end8_crit_edge, label %if.then

entry.if.end8_crit_edge:                          ; preds = %entry
  %task_refs9.phi.trans.insert = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 1
  %.pre32 = load i32, i32* %task_refs9.phi.trans.insert, align 8
  %phi.bo = add i32 %.pre32, 1
  br label %if.end8

if.then:                                          ; preds = %entry
  %tobool.not = icmp eq %struct.task_struct* %1, null
  br i1 %tobool.not, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %task_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 1
  %2 = load i32, i32* %task_refs, align 8
  call fastcc void @io_put_task(%struct.task_struct* noundef nonnull %1, i32 noundef %2) #25
  %.pre = load %struct.task_struct*, %struct.task_struct** %task, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %3 = phi %struct.task_struct* [ %.pre, %if.then3 ], [ %0, %if.then ]
  store %struct.task_struct* %3, %struct.task_struct** %task1, align 8
  br label %if.end8

if.end8:                                          ; preds = %entry.if.end8_crit_edge, %if.end
  %4 = phi i32 [ %phi.bo, %entry.if.end8_crit_edge ], [ 1, %if.end ]
  %task_refs9 = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 1
  store i32 %4, i32* %task_refs9, align 8
  %ctx_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 2
  %5 = load i32, i32* %ctx_refs, align 4
  %inc10 = add i32 %5, 1
  store i32 %inc10, i32* %ctx_refs, align 4
  %free_reqs = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 3
  %6 = load i32, i32* %free_reqs, align 8
  %cmp11.not = icmp eq i32 %6, 32
  br i1 %cmp11.not, label %if.else, label %if.then13

if.then13:                                        ; preds = %if.end8
  %conv = zext i32 %6 to i64
  %inc15 = add i32 %6, 1
  store i32 %inc15, i32* %free_reqs, align 8
  %arrayidx = getelementptr %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 2, i64 %conv
  %7 = bitcast i8** %arrayidx to %struct.io_kiocb**
  store %struct.io_kiocb* %req, %struct.io_kiocb** %7, align 8
  br label %if.end16

if.else:                                          ; preds = %if.end8
  %inflight_entry = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 13
  %free_list = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 7
  call fastcc void @list_add(%struct.list_head* noundef %inflight_entry, %struct.list_head* noundef %free_list) #25
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then13
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %off_timeout_used = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %off_timeout_used, align 4
  %0 = and i8 %bf.load, 48
  %.not = icmp eq i8 %0, 0
  br i1 %.not, label %do.body, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  call fastcc void @__io_commit_cqring_flush(%struct.io_ring_ctx* noundef %ctx) #25
  br label %do.body

do.body:                                          ; preds = %entry, %if.then
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %tail = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 1, i32 2
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 0
  %2 = load i32, i32* %cached_cq_tail, align 64
  call void asm sideeffect "stlr ${1:w}, $0", "=*Q,r,~{memory}"(i32* elementtype(i32) %tail, i32 %2) #26, !srcloc !27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_cqring_ev_posted_iopoll(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  call void asm sideeffect "dmb ish", "~{memory}"() #26, !srcloc !28
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %cq_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 4
  %call = call fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %cq_wait) #25
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.then
  call void @__wake_up(%struct.wait_queue_head* noundef %cq_wait, i32 noundef 3, i32 noundef 0, i8* noundef null) #27
  br label %if.end4

if.end4:                                          ; preds = %if.then, %if.then2, %entry
  %call5 = call fastcc i1 @io_should_trigger_evfd(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %cq_ev_fd = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 2
  %1 = load %struct.eventfd_ctx*, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %call7 = call i64 @eventfd_signal(%struct.eventfd_ctx* noundef %1, i64 noundef 1) #27
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %poll_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 3
  %call9 = call fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %poll_wait) #25
  %tobool10.not = icmp eq i32 %call9, 0
  br i1 %tobool10.not, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end8
  call void @__wake_up(%struct.wait_queue_head* noundef %poll_wait, i32 noundef 1, i32 noundef 1, i8* noundef null) #27
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_free_batch_finish(%struct.io_ring_ctx* noundef %ctx, %struct.req_batch* nocapture noundef readonly %rb) unnamed_addr #1 {
entry:
  %ctx_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 2
  %0 = load i32, i32* %ctx_refs, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  %conv = sext i32 %0 to i64
  call fastcc void @percpu_ref_put_many(%struct.percpu_ref* noundef %refs, i64 noundef %conv) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %task = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 0
  %1 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %tobool2.not = icmp eq %struct.task_struct* %1, null
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %task_refs = getelementptr inbounds %struct.req_batch, %struct.req_batch* %rb, i64 0, i32 1
  %2 = load i32, i32* %task_refs, align 8
  call fastcc void @io_put_task(%struct.task_struct* noundef nonnull %1, i32 noundef %2) #25
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc %struct.io_uring_cqe* @io_get_cqe(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #8 {
entry:
  %rings1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings1, align 16
  %cq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 1
  %1 = load i32, i32* %cq_entries, align 4
  %call = call fastcc i32 @__io_cqring_events(%struct.io_ring_ctx* noundef %ctx) #25
  %2 = load i32, i32* %cq_entries, align 4
  %cmp = icmp eq i32 %call, %2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = add i32 %1, -1
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 0
  %3 = load i32, i32* %cached_cq_tail, align 64
  %inc = add i32 %3, 1
  store i32 %inc, i32* %cached_cq_tail, align 64
  %and = and i32 %3, %sub
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr %struct.io_rings, %struct.io_rings* %0, i64 0, i32 11, i64 %idxprom
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi %struct.io_uring_cqe* [ %arrayidx, %if.end ], [ null, %entry ]
  ret %struct.io_uring_cqe* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_cqring_event_overflow(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %0, i32 noundef 4196896) #27
  %tobool.not = icmp eq i8* %call.i.i, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @io_account_cq_overflow(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

if.end:                                           ; preds = %entry
  %cq_overflow_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 14
  %call1 = call fastcc i32 @list_empty(%struct.list_head* noundef %cq_overflow_list) #25
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end12, label %if.then3

if.then3:                                         ; preds = %if.end
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 8
  call fastcc void @set_bit(i64 noundef 0, i64* noundef %check_cq_overflow) #25
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %sq_flags = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 7
  %2 = load i32, i32* %sq_flags, align 4
  %or = or i32 %2, 2
  store volatile i32 %or, i32* %sq_flags, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then3, %if.end
  %user_data13 = bitcast i8* %call.i.i to i64*
  store i64 %user_data, i64* %user_data13, align 8
  %conv = trunc i64 %res to i32
  %res15 = getelementptr inbounds i8, i8* %call.i.i, i64 8
  %3 = bitcast i8* %res15 to i32*
  store i32 %conv, i32* %3, align 8
  %flags = getelementptr inbounds i8, i8* %call.i.i, i64 12
  %4 = bitcast i8* %flags to i32*
  store i32 %cflags, i32* %4, align 4
  %list = getelementptr inbounds i8, i8* %call.i.i, i64 16
  %5 = bitcast i8* %list to %struct.list_head*
  call fastcc void @list_add_tail(%struct.list_head* noundef %5, %struct.list_head* noundef %cq_overflow_list) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then
  %6 = xor i1 %tobool.not, true
  ret i1 %6
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @__io_cqring_events(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #8 {
entry:
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 0
  %0 = load i32, i32* %cached_cq_tail, align 64
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %head = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 1, i32 0
  %2 = load volatile i32, i32* %head, align 64
  %sub = sub i32 %0, %2
  ret i32 %sub
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @io_account_cq_overflow(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #9 {
entry:
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %cq_overflow = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 9
  %1 = load volatile i32, i32* %cq_overflow, align 4
  %add = add i32 %1, 1
  store volatile i32 %add, i32* %cq_overflow, align 4
  %cq_extra = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 5
  %2 = load i32, i32* %cq_extra, align 64
  %dec = add i32 %2, -1
  store i32 %dec, i32* %cq_extra, align 64
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @set_bit(i64 noundef %nr, i64* noundef %addr) unnamed_addr #1 {
entry:
  %rem.i = and i64 %nr, 63
  %shl.i = shl nuw i64 1, %rem.i
  %0 = bitcast i64* %addr to %struct.atomic64_t*
  call fastcc void @__ll_sc_atomic64_or(i64 noundef %shl.i, %struct.atomic64_t* noundef %0) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local noalias i8* @__kmalloc(i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #11

; Function Attrs: null_pointer_is_valid
declare dso_local noalias i8* @kmem_cache_alloc(%struct.kmem_cache* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic64_or(i64 noundef %i, %struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64 } asm sideeffect "// atomic64_or\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09orr\09$0, $0, $3\0A\09stxr\09${1:w}, $0, $2\0A\09cbnz\09${1:w}, 1b", "=&r,=&r,=*Q,Lr,*Q"(i64* elementtype(i64) %counter, i64 %i, i64* elementtype(i64) %counter) #26, !srcloc !29
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_put_kbuf(%struct.io_kiocb* nocapture noundef %req, %struct.io_buffer* noundef %kbuf) unnamed_addr #1 {
entry:
  %bid = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %kbuf, i64 0, i32 3
  %0 = load i16, i16* %bid, align 4
  %conv = zext i16 %0 to i32
  %shl = shl nuw i32 %conv, 16
  %or = or i32 %shl, 1
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, -32769
  store i32 %and, i32* %flags, align 8
  %2 = bitcast %struct.io_buffer* %kbuf to i8*
  call void @kfree(i8* noundef %2) #27
  ret i32 %or
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i64 0, i32 0
  %0 = call { i32, i64 } asm sideeffect "// atomic_sub_return\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09${0:w}, $2\0A\09sub\09${0:w}, ${0:w}, ${3:w}\0A\09stlxr\09${1:w}, ${0:w}, $2\0A\09cbnz\09${1:w}, 1b\0A\09dmb ish", "=&r,=&r,=*Q,Jr,*Q,~{memory}"(i32* elementtype(i32) %counter, i32 1, i32* elementtype(i32) %counter) #26, !srcloc !30
  %asmresult = extractvalue { i32, i64 } %0, 0
  ret i32 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_queue_next(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_kiocb* @io_req_find_next(%struct.io_kiocb* noundef %req) #25
  %tobool.not = icmp eq %struct.io_kiocb* %call, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_req_task_queue(%struct.io_kiocb* noundef nonnull %call) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_dismantle_req(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags1, align 8
  %call = call fastcc i1 @io_req_needs_clean(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @io_clean_op(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %1 = load %struct.file*, %struct.file** %file, align 8
  call fastcc void @io_put_file(%struct.file* noundef %1) #25
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %fixed_rsrc_refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 12
  %2 = load %struct.percpu_ref*, %struct.percpu_ref** %fixed_rsrc_refs, align 8
  %tobool4.not = icmp eq %struct.percpu_ref* %2, null
  br i1 %tobool4.not, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end3
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef nonnull %2) #25
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = load i8*, i8** %async_data, align 8
  %tobool8.not = icmp eq i8* %3, null
  br i1 %tobool8.not, label %if.end12, label %if.then9

if.then9:                                         ; preds = %if.end7
  call void @kfree(i8* noundef nonnull %3) #27
  store i8* null, i8** %async_data, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end7
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_put_task(%struct.task_struct* noundef %task, i32 noundef %nr) unnamed_addr #1 {
entry:
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 85
  %0 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %cmp = icmp eq %struct.task_struct* %2, %task
  br i1 %cmp, label %if.then, label %if.else, !prof !8

if.then:                                          ; preds = %entry
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 0
  %3 = load i32, i32* %cached_refs, align 8
  %add = add i32 %3, %nr
  store i32 %add, i32* %cached_refs, align 8
  br label %if.end13

if.else:                                          ; preds = %entry
  %inflight = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 5
  %conv2 = sext i32 %nr to i64
  call fastcc void @percpu_counter_sub(%struct.percpu_counter* noundef %inflight, i64 noundef %conv2) #25
  %counter.i = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 7, i32 0
  %4 = load volatile i32, i32* %counter.i, align 4
  %tobool4.not = icmp eq i32 %4, 0
  br i1 %tobool4.not, label %if.end, label %if.then12, !prof !8

if.then12:                                        ; preds = %if.else
  %wait = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %0, i64 0, i32 2
  call void @__wake_up(%struct.wait_queue_head* noundef %wait, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  call fastcc void @put_task_struct_many(%struct.task_struct* noundef %task, i32 noundef %nr) #25
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_add(%struct.list_head* noundef %new, %struct.list_head* noundef %head) unnamed_addr #9 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  call fastcc void @__list_add(%struct.list_head* noundef %new, %struct.list_head* noundef %head, %struct.list_head* noundef %0) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @io_req_find_next(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 12
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !8

if.end:                                           ; preds = %entry
  %call = call fastcc %struct.io_kiocb* @__io_req_find_next(%struct.io_kiocb* noundef %req) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.io_kiocb* [ %call, %if.end ], [ null, %entry ]
  ret %struct.io_kiocb* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_task_queue(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_req_task_submit, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @__io_req_find_next(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1052928
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %call = call fastcc i1 @io_disarm_next(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then3, label %if.end8.critedge

if.then3:                                         ; preds = %if.then
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %2) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %1) #25
  br label %if.end9

if.end8.critedge:                                 ; preds = %if.then
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.end8.critedge, %entry
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  store %struct.io_kiocb* null, %struct.io_kiocb** %link, align 8
  ret %struct.io_kiocb* %3
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_disarm_next(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1048576
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %link1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %link1, align 8
  %and3 = and i32 %0, -1048577
  store i32 %and3, i32* %flags, align 8
  %tobool4.not = icmp eq %struct.io_kiocb* %1, null
  br i1 %tobool4.not, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 2
  %2 = load i8, i8* %opcode, align 8
  %cmp = icmp eq i8 %2, 15
  br i1 %cmp, label %if.then6, label %if.end16

if.then6:                                         ; preds = %land.lhs.true
  call fastcc void @io_remove_next_linked(%struct.io_kiocb* noundef %req) #25
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 6
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 10
  %4 = load i64, i64* %user_data, align 8
  %call = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %3, i64 noundef %4, i64 noundef -125, i32 noundef 0) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef nonnull %1) #25
  br label %if.end16

if.else:                                          ; preds = %entry
  %and8 = and i32 %0, 4096
  %tobool9.not = icmp eq i32 %and8, 0
  br i1 %tobool9.not, label %if.end16, label %if.then10

if.then10:                                        ; preds = %if.else
  %ctx12 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %5 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx12, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %5, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %call13 = call fastcc i1 @io_kill_linked_timeout(%struct.io_kiocb* noundef %req) #25
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end16

if.end16:                                         ; preds = %if.then, %land.lhs.true, %if.then6, %if.else, %if.then10
  %posted.1.off0 = phi i1 [ %call13, %if.then10 ], [ false, %if.else ], [ true, %if.then6 ], [ false, %land.lhs.true ], [ false, %if.then ]
  %6 = load i32, i32* %flags, align 8
  %7 = and i32 %6, 264
  %8 = icmp eq i32 %7, 256
  br i1 %8, label %if.then27, label %if.end35, !prof !24

if.then27:                                        ; preds = %if.end16
  %link28 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %9 = load %struct.io_kiocb*, %struct.io_kiocb** %link28, align 8
  %cmp29 = icmp ne %struct.io_kiocb* %9, null
  %or58 = or i1 %posted.1.off0, %cmp29
  call fastcc void @io_fail_links(%struct.io_kiocb* noundef %req) #25
  br label %if.end35

if.end35:                                         ; preds = %if.then27, %if.end16
  %posted.2.off0 = phi i1 [ %or58, %if.then27 ], [ %posted.1.off0, %if.end16 ]
  ret i1 %posted.2.off0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %cq_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 4
  %call = call fastcc i1 @wq_has_sleeper(%struct.wait_queue_head* noundef %cq_wait) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__wake_up(%struct.wait_queue_head* noundef %cq_wait, i32 noundef 3, i32 noundef 0, i8* noundef null) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %0 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool.not = icmp eq %struct.io_sq_data* %0, null
  br i1 %tobool.not, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %wait = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %0, i64 0, i32 5
  %call3 = call fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %wait) #25
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.end8, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %1 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %wait7 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %1, i64 0, i32 5
  call void @__wake_up(%struct.wait_queue_head* noundef %wait7, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %call9 = call fastcc i1 @io_should_trigger_evfd(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %cq_ev_fd = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 2
  %2 = load %struct.eventfd_ctx*, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %call11 = call i64 @eventfd_signal(%struct.eventfd_ctx* noundef %2, i64 noundef 1) #27
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %poll_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 3
  %call13 = call fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %poll_wait) #25
  %tobool14.not = icmp eq i32 %call13, 0
  br i1 %tobool14.not, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end12
  call void @__wake_up(%struct.wait_queue_head* noundef %poll_wait, i32 noundef 1, i32 noundef 1, i8* noundef null) #27
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end12
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @io_remove_next_linked(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #12 {
entry:
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %link1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 11
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %link1, align 8
  store %struct.io_kiocb* %1, %struct.io_kiocb** %link, align 8
  store %struct.io_kiocb* null, %struct.io_kiocb** %link1, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, i64 noundef %res, i32 noundef %cflags) #25
  ret i1 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_free_req_work, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_kill_linked_timeout(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %link1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %link1, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %0, null
  br i1 %tobool.not, label %cleanup9, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 2
  %1 = load i8, i8* %opcode, align 8
  %cmp = icmp eq i8 %1, 15
  br i1 %cmp, label %if.then, label %cleanup9

if.then:                                          ; preds = %land.lhs.true
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 1
  %2 = bitcast i8** %async_data to %struct.io_timeout_data**
  %3 = load %struct.io_timeout_data*, %struct.io_timeout_data** %2, align 8
  call fastcc void @io_remove_next_linked(%struct.io_kiocb* noundef %req) #25
  %head = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 0, i32 0, i32 0, i32 4
  %4 = bitcast i32* %head to %struct.io_kiocb**
  store %struct.io_kiocb* null, %struct.io_kiocb** %4, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %3, i64 0, i32 1
  %call = call i32 @hrtimer_try_to_cancel(%struct.hrtimer* noundef %timer) #27
  %cmp3.not = icmp eq i32 %call, -1
  br i1 %cmp3.not, label %cleanup9, label %if.then5

if.then5:                                         ; preds = %if.then
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 0, i32 0, i32 0, i32 2
  %5 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %5) #25
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 6
  %6 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 10
  %7 = load i64, i64* %user_data, align 8
  %call7 = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %6, i64 noundef %7, i64 noundef -125, i32 noundef 0) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef nonnull %0) #25
  br label %cleanup9

cleanup9:                                         ; preds = %entry, %land.lhs.true, %if.then, %if.then5
  %retval.1 = phi i1 [ true, %if.then5 ], [ false, %if.then ], [ false, %land.lhs.true ], [ false, %entry ]
  ret i1 %retval.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_fail_links(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %link1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %link1, align 8
  store %struct.io_kiocb* null, %struct.io_kiocb** %link1, align 8
  %tobool.not19 = icmp eq %struct.io_kiocb* %0, null
  br i1 %tobool.not19, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %link.020 = phi %struct.io_kiocb* [ %3, %if.end ], [ %0, %entry ]
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %link.020, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 256
  %tobool3.not = icmp eq i32 %and, 0
  br i1 %tobool3.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %link.020, i64 0, i32 5
  %2 = load i32, i32* %result, align 4
  %conv = zext i32 %2 to i64
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %res.0 = phi i64 [ %conv, %if.then ], [ -125, %while.body ]
  %link4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %link.020, i64 0, i32 11
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %link4, align 8
  store %struct.io_kiocb* null, %struct.io_kiocb** %link4, align 8
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %link.020, i64 0, i32 6
  %4 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %link.020, i64 0, i32 10
  %5 = load i64, i64* %user_data, align 8
  %call = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %4, i64 noundef %5, i64 noundef %res.0, i32 noundef 0) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef nonnull %link.020) #25
  %tobool.not = icmp eq %struct.io_kiocb* %3, null
  br i1 %tobool.not, label %while.end, label %while.body

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_free_req_work(%struct.io_kiocb* noundef %req, i8* nocapture noundef readnone %locked) #1 {
entry:
  call fastcc void @io_free_req(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %0 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i64 0, i32 85
  %1 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %1, null
  br i1 %tobool.not, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 2175; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !31
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rlock.i = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 8, i32 0, i32 0
  %call19 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  %node22 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 0, i32 0
  %task_list = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 9
  call fastcc void @wq_list_add_tail(%struct.io_wq_work_node* noundef %node22, %struct.io_wq_work_list* noundef %task_list) #25
  %task_running = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 11
  %2 = load i8, i8* %task_running, align 8, !range !18
  %tobool23.not = icmp eq i8 %2, 0
  br i1 %tobool23.not, label %if.then25, label %if.then30.critedge

if.then25:                                        ; preds = %if.end
  store i8 1, i8* %task_running, align 8
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call19) #27
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags32 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 0, i32 2
  %4 = load i32, i32* %flags32, align 8
  %and = and i32 %4, 2
  %5 = xor i32 %and, 2
  %task_work = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 10
  %call34 = call i32 @task_work_add(%struct.task_struct* noundef %0, %struct.callback_head* noundef %task_work, i32 noundef %5) #27
  %tobool35.not = icmp eq i32 %call34, 0
  br i1 %tobool35.not, label %if.then36, label %do.body40

if.then30.critedge:                               ; preds = %if.end
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call19) #27
  br label %cleanup

if.then36:                                        ; preds = %if.then25
  %call37 = call i32 @wake_up_process(%struct.task_struct* noundef %0) #27
  br label %cleanup

do.body40:                                        ; preds = %if.then25
  %call48 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  store i8 0, i8* %task_running, align 8
  %first = getelementptr inbounds %struct.io_wq_work_list, %struct.io_wq_work_list* %task_list, i64 0, i32 0
  %6 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %first, align 8
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %first, align 8
  %last = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 9, i32 1
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %last, align 8
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call48) #27
  %tobool62.not115 = icmp eq %struct.io_wq_work_node* %6, null
  br i1 %tobool62.not115, label %cleanup, label %while.body

while.body:                                       ; preds = %do.body40, %if.end73
  %node.0116 = phi %struct.io_wq_work_node* [ %7, %if.end73 ], [ %6, %do.body40 ]
  %next = getelementptr inbounds %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0116, i64 0, i32 0
  %7 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %next, align 8
  %fallback_node = bitcast %struct.io_wq_work_node* %node.0116 to %struct.llist_node*
  %ctx68 = getelementptr %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0116, i64 -8
  %8 = bitcast %struct.io_wq_work_node* %ctx68 to %struct.io_ring_ctx**
  %9 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %8, align 8
  %fallback_llist = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %9, i64 0, i32 14, i32 3
  %call69 = call fastcc i1 @llist_add(%struct.llist_node* noundef nonnull %fallback_node, %struct.llist_head* noundef %fallback_llist) #25
  br i1 %call69, label %if.then70, label %if.end73

if.then70:                                        ; preds = %while.body
  %10 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %8, align 8
  %fallback_work = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %10, i64 0, i32 14, i32 4
  call fastcc void @schedule_delayed_work(%struct.delayed_work* noundef %fallback_work) #25
  br label %if.end73

if.end73:                                         ; preds = %if.then70, %while.body
  %tobool62.not = icmp eq %struct.io_wq_work_node* %7, null
  br i1 %tobool62.not, label %cleanup, label %while.body

cleanup:                                          ; preds = %if.end73, %do.body40, %if.then30.critedge, %if.then36
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_free_req(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  call fastcc void @io_queue_next(%struct.io_kiocb* noundef %req) #25
  call fastcc void @__io_free_req(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_free_req(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  call fastcc void @io_dismantle_req(%struct.io_kiocb* noundef %req) #25
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %1 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  call fastcc void @io_put_task(%struct.task_struct* noundef %1, i32 noundef 1) #25
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %inflight_entry = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 13
  %locked_free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 2
  call fastcc void @list_add(%struct.list_head* noundef %inflight_entry, %struct.list_head* noundef %locked_free_list) #25
  %locked_free_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 3
  %2 = load i32, i32* %locked_free_nr, align 16
  %inc = add i32 %2, 1
  store i32 %inc, i32* %locked_free_nr, align 16
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %ref) unnamed_addr #1 {
entry:
  call fastcc void @percpu_ref_put_many(%struct.percpu_ref* noundef %ref, i64 noundef 1) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_ref_put_many(%struct.percpu_ref* noundef %ref, i64 noundef %nr) unnamed_addr #1 {
entry:
  %percpu_count = alloca i64*, align 8
  %0 = bitcast i64** %percpu_count to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64* null, i64** %percpu_count, align 8, !annotation !14
  call fastcc void @__rcu_read_lock() #27
  %call = call fastcc i1 @__ref_is_percpu(%struct.percpu_ref* noundef %ref, i64** noundef nonnull %percpu_count) #25
  br i1 %call, label %do.body1, label %if.else

do.body1:                                         ; preds = %entry
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !32
  %1 = load i64*, i64** %percpu_count, align 8
  %2 = ptrtoint i64* %1 to i64
  %call7 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add = add i64 %call7, %2
  %3 = inttoptr i64 %add to i8*
  %sub = sub i64 0, %nr
  call fastcc void @__percpu_add_case_64(i8* noundef %3, i64 noundef %sub) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !33
  br label %if.end14

if.else:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 0, i32 1
  %4 = load %struct.percpu_ref_data*, %struct.percpu_ref_data** %data, align 8
  %count = getelementptr inbounds %struct.percpu_ref_data, %struct.percpu_ref_data* %4, i64 0, i32 0
  %call.i.i.i.i = call fastcc i64 @__ll_sc_atomic64_sub_return(i64 noundef %nr, %struct.atomic64_t* noundef %count) #27
  %cmp.i.i.i = icmp eq i64 %call.i.i.i.i, 0
  br i1 %cmp.i.i.i, label %if.then12, label %if.end14, !prof !24

if.then12:                                        ; preds = %if.else
  %5 = load %struct.percpu_ref_data*, %struct.percpu_ref_data** %data, align 8
  %release = getelementptr inbounds %struct.percpu_ref_data, %struct.percpu_ref_data* %5, i64 0, i32 1
  %6 = load void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)** %release, align 8
  call void %6(%struct.percpu_ref* noundef %ref) #27
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then12, %do.body1
  call fastcc void @rcu_read_unlock() #25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @__ref_is_percpu(%struct.percpu_ref* noundef %ref, i64** nocapture noundef writeonly %percpu_countp) unnamed_addr #8 {
entry:
  %percpu_count_ptr = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 0, i32 0
  %0 = load volatile i64, i64* %percpu_count_ptr, align 8
  %and = and i64 %0, 3
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %1 = inttoptr i64 %0 to i64*
  store i64* %1, i64** %percpu_countp, align 8
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  ret i1 %tobool.not
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__percpu_add_case_64(i8* noundef %ptr, i64 noundef %val) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i64*
  %1 = call { i32, i64 } asm sideeffect "1:\09ldxr\09$1, $2\0Aadd\09$1, $1, $3\0A\09stxr\09${0:w}, $1, $2\0A\09cbnz\09${0:w}, 1b", "=&r,=&r,=*Q,r,*Q"(i64* elementtype(i64) %0, i64 %val, i64* elementtype(i64) %0) #26, !srcloc !34
  ret void
}

; Function Attrs: nofree noinline nounwind null_pointer_is_valid readonly
define internal fastcc i64 @__kern_my_cpu_offset() unnamed_addr #13 {
entry:
  %0 = call i64 @llvm.read_register.i64(metadata !0)
  %1 = inttoptr i64 %0 to i64*
  %2 = call i64 asm ".if 1 == 1\0A661:\0A\09mrs $0, tpidr_el1\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 31\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09mrs $0, tpidr_el2\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "=r,*Q"(i64* elementtype(i64) %1) #29, !srcloc !35
  ret i64 %2
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @rcu_read_unlock() unnamed_addr #1 {
entry:
  call fastcc void @__rcu_read_unlock() #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__rcu_read_lock() unnamed_addr #1 {
entry:
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !36
  ret void
}

; Function Attrs: nofree nounwind readonly
declare i64 @llvm.read_register.i64(metadata) #14

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__ll_sc_atomic64_sub_return(i64 noundef %i, %struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64 } asm sideeffect "// atomic64_sub_return\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09sub\09$0, $0, $3\0A\09stlxr\09${1:w}, $0, $2\0A\09cbnz\09${1:w}, 1b\0A\09dmb ish", "=&r,=&r,=*Q,Jr,*Q,~{memory}"(i64* elementtype(i64) %counter, i64 %i, i64* elementtype(i64) %counter) #26, !srcloc !37
  %asmresult = extractvalue { i64, i64 } %0, 0
  ret i64 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__rcu_read_unlock() unnamed_addr #1 {
entry:
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !38
  call void @rcu_read_unlock_strict() #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @rcu_read_unlock_strict() local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  %call = call fastcc i64 @arch_local_irq_save() #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !39
  call fastcc void @do_raw_spin_lock_flags(%struct.raw_spinlock* noundef %lock) #25
  ret i64 %call
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @wq_list_add_tail(%struct.io_wq_work_node* noundef %node, %struct.io_wq_work_list* noundef %list) unnamed_addr #9 {
entry:
  %next = getelementptr inbounds %struct.io_wq_work_node, %struct.io_wq_work_node* %node, i64 0, i32 0
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %next, align 8
  %first = getelementptr inbounds %struct.io_wq_work_list, %struct.io_wq_work_list* %list, i64 0, i32 0
  %0 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %first, align 8
  %tobool.not = icmp eq %struct.io_wq_work_node* %0, null
  %last = getelementptr inbounds %struct.io_wq_work_list, %struct.io_wq_work_list* %list, i64 0, i32 1
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.io_wq_work_node* %node, %struct.io_wq_work_node** %last, align 8
  store volatile %struct.io_wq_work_node* %node, %struct.io_wq_work_node** %first, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %last, align 8
  %next7 = getelementptr inbounds %struct.io_wq_work_node, %struct.io_wq_work_node* %1, i64 0, i32 0
  store %struct.io_wq_work_node* %node, %struct.io_wq_work_node** %next7, align 8
  store %struct.io_wq_work_node* %node, %struct.io_wq_work_node** %last, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @task_work_add(%struct.task_struct* noundef, %struct.callback_head* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @wake_up_process(%struct.task_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @llist_add(%struct.llist_node* noundef %new, %struct.llist_head* noundef %head) unnamed_addr #1 {
entry:
  %call = call i1 @llist_add_batch(%struct.llist_node* noundef %new, %struct.llist_node* noundef %new, %struct.llist_head* noundef %head) #27
  ret i1 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @schedule_delayed_work(%struct.delayed_work* noundef %dwork) unnamed_addr #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8
  call fastcc void @queue_delayed_work(%struct.workqueue_struct* noundef %0, %struct.delayed_work* noundef %dwork) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @arch_local_irq_save() unnamed_addr #1 {
entry:
  %call = call fastcc i64 @arch_local_save_flags() #25
  %call1 = call fastcc i32 @arch_irqs_disabled_flags(i64 noundef %call) #25
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @arch_local_irq_disable() #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @do_raw_spin_lock_flags(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.raw_spinlock* %lock to i8*
  %call11.i.i.i.i = call fastcc i32 @__cmpxchg_case_acq_32(i8* noundef %0, i32 noundef 0) #27
  %cmp.not.i.i.i = icmp eq i32 %call11.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %queued_spin_lock.exit, label %if.end.i, !prof !8

if.end.i:                                         ; preds = %entry
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i64 0, i32 0
  call void @queued_spin_lock_slowpath(%struct.qspinlock* noundef %raw_lock, i32 noundef %call11.i.i.i.i) #27
  br label %queued_spin_lock.exit

queued_spin_lock.exit:                            ; preds = %entry, %if.end.i
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @arch_local_save_flags() unnamed_addr #1 {
entry:
  %0 = call i64 asm sideeffect ".if 1 == 1\0A661:\0A\09mrs\09$0, daif\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 19\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09\09.irp\09num,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\0A\09.equ\09.L__reg_num_x\\num, \\num\0A\09.endr\0A\09.equ\09.L__reg_num_xzr, 31\0A\09.macro\09mrs_s, rt, sreg\0A.inst (0xd5200000|(\\sreg)|(.L__reg_num_\\rt))\0A\09\09.endm\0A\09mrs_s $0, (((3) << 19) | ((0) << 16) | ((4) << 12) | ((6) << 8) | ((0) << 5))\0A\09.purgem\09mrs_s\0A\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "=&r,~{memory}"() #26, !srcloc !40
  ret i64 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @arch_irqs_disabled_flags(i64 noundef %flags) unnamed_addr #1 {
entry:
  %conv = trunc i64 %flags to i32
  %0 = call i32 asm sideeffect ".if 1 == 1\0A661:\0A\09and\09${0:w}, ${1:w}, #0x00000080\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 19\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09eor\09${0:w}, ${1:w}, #0xe0\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "=&r,r,~{memory}"(i32 %conv) #26, !srcloc !41
  ret i32 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @arch_local_irq_disable() unnamed_addr #1 {
entry:
  %call39 = call fastcc i32 @static_key_count() #25
  %cmp40 = icmp sgt i32 %call39, 0
  br i1 %cmp40, label %if.then50, label %if.end51, !prof !24

if.then50:                                        ; preds = %entry
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %entry
  %__prio37.0 = phi i64 [ 160, %if.then50 ], [ 96, %entry ]
  call void asm sideeffect ".if 1 == 1\0A661:\0A\09msr\09daifset, #3\09\09// arch_local_irq_disable\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 19\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09\09.irp\09num,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\0A\09.equ\09.L__reg_num_x\\num, \\num\0A\09.endr\0A\09.equ\09.L__reg_num_xzr, 31\0A\09.macro\09msr_s, sreg, rt\0A.inst (0xd5000000|(\\sreg)|(.L__reg_num_\\rt))\0A\09\09.endm\0A\09msr_s (((3) << 19) | ((0) << 16) | ((4) << 12) | ((6) << 8) | ((0) << 5)), $0\0A\09.purgem\09msr_s\0A\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "r,~{memory}"(i64 %__prio37.0) #26, !srcloc !42
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @static_key_count() unnamed_addr #8 {
entry:
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.static_key_false, %struct.static_key_false* @gic_nonsecure_priorities, i64 0, i32 0, i32 0, i32 0), align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %lock, i64 noundef %flags) unnamed_addr #1 {
entry:
  call fastcc void @do_raw_spin_unlock(%struct.raw_spinlock* noundef %lock) #25
  call fastcc void @arch_local_irq_restore(i64 noundef %flags) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !43
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @arch_local_irq_restore(i64 noundef %flags) unnamed_addr #1 {
entry:
  call void asm sideeffect ".if 1 == 1\0A661:\0A\09msr\09daif, $0\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 19\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09\09.irp\09num,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\0A\09.equ\09.L__reg_num_x\\num, \\num\0A\09.endr\0A\09.equ\09.L__reg_num_xzr, 31\0A\09.macro\09msr_s, sreg, rt\0A.inst (0xd5000000|(\\sreg)|(.L__reg_num_\\rt))\0A\09\09.endm\0A\09msr_s (((3) << 19) | ((0) << 16) | ((4) << 12) | ((6) << 8) | ((0) << 5)), $0\0A\09.purgem\09msr_s\0A\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "r,~{memory}"(i64 %flags) #26, !srcloc !44
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @llist_add_batch(%struct.llist_node* noundef, %struct.llist_node* noundef, %struct.llist_head* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @queue_delayed_work(%struct.workqueue_struct* noundef %wq, %struct.delayed_work* noundef %dwork) unnamed_addr #1 {
entry:
  %call = call i1 @queue_delayed_work_on(i32 noundef 256, %struct.workqueue_struct* noundef %wq, %struct.delayed_work* noundef %dwork, i64 noundef 1) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @queue_delayed_work_on(i32 noundef, %struct.workqueue_struct* noundef, %struct.delayed_work* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  call fastcc void @arch_local_irq_disable() #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !45
  call fastcc void @do_raw_spin_lock(%struct.raw_spinlock* noundef %lock) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @hrtimer_try_to_cancel(%struct.hrtimer* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %lock) unnamed_addr #1 {
entry:
  call fastcc void @do_raw_spin_unlock(%struct.raw_spinlock* noundef %lock) #25
  call fastcc void @arch_local_irq_enable() #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !46
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @arch_local_irq_enable() unnamed_addr #1 {
entry:
  call void asm sideeffect ".if 1 == 1\0A661:\0A\09msr\09daifclr, #3\09\09// arch_local_irq_enable\0A662:\0A.pushsection .altinstructions,\22a\22\0A .word 661b - .\0A .word 663f - .\0A .hword 19\0A .byte 662b-661b\0A .byte 664f-663f\0A.popsection\0A.subsection 1\0A663:\0A\09\09.irp\09num,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\0A\09.equ\09.L__reg_num_x\\num, \\num\0A\09.endr\0A\09.equ\09.L__reg_num_xzr, 31\0A\09.macro\09msr_s, sreg, rt\0A.inst (0xd5000000|(\\sreg)|(.L__reg_num_\\rt))\0A\09\09.endm\0A\09msr_s (((3) << 19) | ((0) << 16) | ((4) << 12) | ((6) << 8) | ((0) << 5)), $0\0A\09.purgem\09msr_s\0A\0A664:\0A\09.org\09. - (664b-663b) + (662b-661b)\0A\09.org\09. - (662b-661b) + (664b-663b)\0A\09.previous\0A.endif\0A", "r,~{memory}"(i64 224) #26, !srcloc !47
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @wq_has_sleeper(%struct.wait_queue_head* noundef %wq_head) unnamed_addr #1 {
entry:
  call void asm sideeffect "dmb ish", "~{memory}"() #26, !srcloc !48
  %call = call fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %wq_head) #25
  %tobool = icmp ne i32 %call, 0
  ret i1 %tobool
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__wake_up(%struct.wait_queue_head* noundef, i32 noundef, i32 noundef, i8* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @waitqueue_active(%struct.wait_queue_head* noundef %wq_head) unnamed_addr #8 {
entry:
  %head = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %wq_head, i64 0, i32 1
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %head) #25
  %tobool.not = icmp eq i32 %call, 0
  %lnot.ext = zext i1 %tobool.not to i32
  ret i32 %lnot.ext
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_should_trigger_evfd(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #1 {
entry:
  %cq_ev_fd = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 2
  %0 = load %struct.eventfd_ctx*, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %tobool.not = icmp eq %struct.eventfd_ctx* %0, null
  br i1 %tobool.not, label %return, label %do.end, !prof !8

do.end:                                           ; preds = %entry
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %cq_flags = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 8
  %2 = load volatile i32, i32* %cq_flags, align 8
  %and = and i32 %2, 1
  %tobool4.not = icmp eq i32 %and, 0
  br i1 %tobool4.not, label %if.end6, label %return

if.end6:                                          ; preds = %do.end
  %eventfd_async = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %eventfd_async, align 4
  %3 = and i8 %bf.load, 4
  %tobool7.not = icmp eq i8 %3, 0
  br i1 %tobool7.not, label %return, label %lor.rhs

lor.rhs:                                          ; preds = %if.end6
  %call = call fastcc i1 @io_wq_current_is_worker() #25
  br label %return

return:                                           ; preds = %if.end6, %lor.rhs, %do.end, %entry
  %retval.0 = phi i1 [ false, %entry ], [ false, %do.end ], [ true, %if.end6 ], [ %call, %lor.rhs ]
  ret i1 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @eventfd_signal(%struct.eventfd_ctx* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_wq_current_is_worker() unnamed_addr #1 {
entry:
  %call = call fastcc i32 @preempt_count() #25
  %0 = and i32 %call, 15728640
  %call1 = call fastcc i32 @preempt_count() #25
  %1 = and i32 %call1, 983040
  %or16 = or i32 %1, %0
  %call4 = call fastcc i32 @preempt_count() #25
  %2 = and i32 %call4, 256
  %or818 = or i32 %or16, %2
  %tobool.not = icmp eq i32 %or818, 0
  br i1 %tobool.not, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 4
  %5 = load i32, i32* %flags, align 4
  %and10 = and i32 %5, 16
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true
  %pf_io_worker = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 66
  %6 = load i8*, i8** %pf_io_worker, align 64
  %tobool13 = icmp ne i8* %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %tobool13, %land.rhs ]
  ret i1 %7
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @preempt_count() unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %2 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 0, i32 1
  %count = bitcast %union.anon.18* %2 to i32*
  %3 = load volatile i32, i32* %count, align 8
  ret i32 %3
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_req_task_submit(%struct.io_kiocb* noundef %req, i8* nocapture noundef %locked) #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  call fastcc void @io_tw_lock(%struct.io_ring_ctx* noundef %0, i8* noundef %locked) #25
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %1 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 4
  %2 = load i32, i32* %flags, align 4
  %and = and i32 %2, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.else, !prof !8

if.then:                                          ; preds = %entry
  call fastcc void @__io_queue_sqe(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.else:                                          ; preds = %entry
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef -14) #25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_tw_lock(%struct.io_ring_ctx* noundef %ctx, i8* nocapture noundef %locked) unnamed_addr #1 {
entry:
  %0 = load i8, i8* %locked, align 1, !range !18
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  store i8 1, i8* %locked, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_queue_sqe(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags18 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  br label %issue_sqe

issue_sqe:                                        ; preds = %issue_sqe.backedge, %entry
  %call = call fastcc i32 @io_issue_sqe(%struct.io_kiocb* noundef %req, i32 noundef 3) #25
  switch i32 %call, label %if.else31 [
    i32 0, label %if.then
    i32 -11, label %land.lhs.true
  ], !prof !49

if.then:                                          ; preds = %issue_sqe
  %0 = load i32, i32* %flags18, align 8
  %and = and i32 %0, 65536
  %tobool4.not = icmp eq i32 %and, 0
  br i1 %tobool4.not, label %if.end11, label %if.then5

if.then5:                                         ; preds = %if.then
  %ctx6 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx6, align 8
  %compl_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 11, i32 6
  %2 = load i32, i32* %compl_nr, align 8
  %inc = add i32 %2, 1
  store i32 %inc, i32* %compl_nr, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 11, i32 5, i64 %idxprom
  store %struct.io_kiocb* %req, %struct.io_kiocb** %arrayidx, align 8
  %3 = load i32, i32* %compl_nr, align 8
  %cmp = icmp eq i32 %3, 32
  br i1 %cmp, label %if.then10, label %cleanup

if.then10:                                        ; preds = %if.then5
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %1) #25
  br label %cleanup

if.end11:                                         ; preds = %if.then
  %call12 = call fastcc %struct.io_kiocb* @io_prep_linked_timeout(%struct.io_kiocb* noundef %req) #25
  %tobool13.not = icmp eq %struct.io_kiocb* %call12, null
  br i1 %tobool13.not, label %cleanup, label %if.then14

if.then14:                                        ; preds = %if.end11
  call fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef nonnull %call12) #25
  br label %cleanup

land.lhs.true:                                    ; preds = %issue_sqe
  %4 = load i32, i32* %flags18, align 8
  %and19 = and i32 %4, 2048
  %tobool20.not = icmp eq i32 %and19, 0
  br i1 %tobool20.not, label %if.then21, label %if.else31

if.then21:                                        ; preds = %land.lhs.true
  %call22 = call fastcc %struct.io_kiocb* @io_prep_linked_timeout(%struct.io_kiocb* noundef %req) #25
  %call23 = call fastcc i32 @io_arm_poll_handler(%struct.io_kiocb* noundef %req) #25
  switch i32 %call23, label %sw.epilog [
    i32 2, label %sw.bb
    i32 1, label %sw.bb27
  ]

sw.bb:                                            ; preds = %if.then21
  %tobool24.not = icmp eq %struct.io_kiocb* %call22, null
  br i1 %tobool24.not, label %issue_sqe.backedge, label %if.then25

if.then25:                                        ; preds = %sw.bb
  call fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef nonnull %call22) #25
  br label %issue_sqe.backedge

issue_sqe.backedge:                               ; preds = %if.then25, %sw.bb
  br label %issue_sqe

sw.bb27:                                          ; preds = %if.then21
  call void @io_queue_async_work(%struct.io_kiocb* noundef %req, i8* noundef null) #25
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then21, %sw.bb27
  %tobool28.not = icmp eq %struct.io_kiocb* %call22, null
  br i1 %tobool28.not, label %cleanup, label %if.then29

if.then29:                                        ; preds = %sw.epilog
  call fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef nonnull %call22) #25
  br label %cleanup

if.else31:                                        ; preds = %issue_sqe, %land.lhs.true
  %conv32 = sext i32 %call to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv32) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then14, %if.end11, %sw.epilog, %if.then29, %if.else31, %if.then5, %if.then10
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %res) unnamed_addr #1 {
entry:
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef 0) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_issue_sqe(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 262144
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %creds2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 18
  %2 = load %struct.cred*, %struct.cred** %creds2, align 8
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 80
  %5 = load %struct.cred*, %struct.cred** %cred, align 8
  %cmp.not = icmp eq %struct.cred* %2, %5
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call4 = call %struct.cred* @override_creds(%struct.cred* noundef %2) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %creds.0 = phi %struct.cred* [ %call4, %if.then ], [ null, %land.lhs.true ], [ null, %entry ]
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %6 = load i8, i8* %opcode, align 8
  switch i8 %6, label %sw.epilog [
    i8 0, label %sw.bb
    i8 1, label %sw.bb6
    i8 4, label %sw.bb6
    i8 22, label %sw.bb6
    i8 2, label %sw.bb8
    i8 5, label %sw.bb8
    i8 23, label %sw.bb8
    i8 3, label %sw.bb10
    i8 6, label %sw.bb12
    i8 7, label %sw.bb14
    i8 8, label %sw.bb16
    i8 9, label %sw.bb18
    i8 26, label %sw.bb20
    i8 10, label %sw.bb22
    i8 27, label %sw.bb24
    i8 11, label %sw.bb26
    i8 12, label %sw.bb28
    i8 13, label %sw.bb30
    i8 16, label %sw.bb32
    i8 14, label %sw.bb34
    i8 17, label %sw.bb36
    i8 18, label %sw.bb38
    i8 19, label %sw.bb40
    i8 20, label %sw.bb42
    i8 21, label %sw.bb44
    i8 24, label %sw.bb46
    i8 25, label %sw.bb48
    i8 28, label %sw.bb50
    i8 29, label %sw.bb52
    i8 30, label %sw.bb54
    i8 31, label %sw.bb56
    i8 32, label %sw.bb58
    i8 33, label %sw.bb60
    i8 34, label %sw.bb62
    i8 35, label %sw.bb64
    i8 36, label %sw.bb66
    i8 37, label %sw.bb68
    i8 38, label %sw.bb70
    i8 39, label %sw.bb72
  ]

sw.bb:                                            ; preds = %if.end
  %call5 = call fastcc i32 @io_nop(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.end, %if.end, %if.end
  %call7 = call fastcc i32 @io_read(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end, %if.end, %if.end
  %call9 = call fastcc i32 @io_write(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  %call11 = call fastcc i32 @io_fsync(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end
  %call13 = call fastcc i32 @io_poll_add(%struct.io_kiocb* noundef %req) #25
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  call fastcc void @io_poll_update(%struct.io_kiocb* noundef %req) #25
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end
  %call17 = call fastcc i32 @io_sync_file_range(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb18:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end
  call fastcc void @io_timeout(%struct.io_kiocb* noundef %req) #25
  br label %sw.epilog

sw.bb28:                                          ; preds = %if.end
  call fastcc void @io_timeout_remove(%struct.io_kiocb* noundef %req) #25
  br label %sw.epilog

sw.bb30:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb34:                                          ; preds = %if.end
  call fastcc void @io_async_cancel(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end
  %call37 = call fastcc i32 @io_fallocate(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb38:                                          ; preds = %if.end
  %call39 = call fastcc i32 @io_openat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end
  %call41 = call fastcc i32 @io_close(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb42:                                          ; preds = %if.end
  call fastcc void @io_files_update(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb44:                                          ; preds = %if.end
  %call45 = call fastcc i32 @io_statx(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end
  %call47 = call fastcc i32 @io_fadvise(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb48:                                          ; preds = %if.end
  %call49 = call fastcc i32 @io_madvise(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb50:                                          ; preds = %if.end
  %call51 = call fastcc i32 @io_openat2(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb52:                                          ; preds = %if.end
  %call53 = call fastcc i32 @io_epoll_ctl(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.end
  %call55 = call fastcc i32 @io_splice(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb56:                                          ; preds = %if.end
  call fastcc void @io_provide_buffers(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb58:                                          ; preds = %if.end
  call fastcc void @io_remove_buffers(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end
  %call61 = call fastcc i32 @io_tee(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb62:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb64:                                          ; preds = %if.end
  %call65 = call fastcc i32 @io_renameat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb66:                                          ; preds = %if.end
  %call67 = call fastcc i32 @io_unlinkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb68:                                          ; preds = %if.end
  %call69 = call fastcc i32 @io_mkdirat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb70:                                          ; preds = %if.end
  %call71 = call fastcc i32 @io_symlinkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.bb72:                                          ; preds = %if.end
  %call73 = call fastcc i32 @io_linkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.bb72, %sw.bb70, %sw.bb68, %sw.bb66, %sw.bb64, %sw.bb62, %sw.bb60, %sw.bb58, %sw.bb56, %sw.bb54, %sw.bb52, %sw.bb50, %sw.bb48, %sw.bb46, %sw.bb44, %sw.bb42, %sw.bb40, %sw.bb38, %sw.bb36, %sw.bb34, %sw.bb32, %sw.bb30, %sw.bb28, %sw.bb26, %sw.bb24, %sw.bb22, %sw.bb20, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb12, %sw.bb10, %sw.bb8, %sw.bb6, %sw.bb
  %ret.0 = phi i32 [ %call73, %sw.bb72 ], [ %call71, %sw.bb70 ], [ %call69, %sw.bb68 ], [ %call67, %sw.bb66 ], [ %call65, %sw.bb64 ], [ -95, %sw.bb62 ], [ %call61, %sw.bb60 ], [ 0, %sw.bb58 ], [ 0, %sw.bb56 ], [ %call55, %sw.bb54 ], [ %call53, %sw.bb52 ], [ %call51, %sw.bb50 ], [ %call49, %sw.bb48 ], [ %call47, %sw.bb46 ], [ %call45, %sw.bb44 ], [ 0, %sw.bb42 ], [ %call41, %sw.bb40 ], [ %call39, %sw.bb38 ], [ %call37, %sw.bb36 ], [ 0, %sw.bb34 ], [ -95, %sw.bb32 ], [ -95, %sw.bb30 ], [ 0, %sw.bb28 ], [ 0, %sw.bb26 ], [ -95, %sw.bb24 ], [ -95, %sw.bb22 ], [ -95, %sw.bb20 ], [ -95, %sw.bb18 ], [ %call17, %sw.bb16 ], [ 0, %sw.bb14 ], [ %call13, %sw.bb12 ], [ %call11, %sw.bb10 ], [ %call9, %sw.bb8 ], [ %call7, %sw.bb6 ], [ %call5, %sw.bb ], [ -22, %if.end ]
  %tobool74.not = icmp eq %struct.cred* %creds.0, null
  br i1 %tobool74.not, label %if.end76, label %if.then75

if.then75:                                        ; preds = %sw.epilog
  call void @revert_creds(%struct.cred* noundef nonnull %creds.0) #27
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %sw.epilog
  %tobool77.not = icmp eq i32 %ret.0, 0
  br i1 %tobool77.not, label %if.end79, label %cleanup

if.end79:                                         ; preds = %if.end76
  %flags80 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %7 = load i32, i32* %flags80, align 8
  %and81 = and i32 %7, 1
  %tobool82.not = icmp eq i32 %and81, 0
  br i1 %tobool82.not, label %cleanup, label %land.lhs.true83

land.lhs.true83:                                  ; preds = %if.end79
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %8 = load %struct.file*, %struct.file** %file, align 8
  %tobool84.not = icmp eq %struct.file* %8, null
  br i1 %tobool84.not, label %cleanup, label %if.then85

if.then85:                                        ; preds = %land.lhs.true83
  call fastcc void @io_iopoll_req_issued(%struct.io_kiocb* noundef %req) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end79, %land.lhs.true83, %if.then85, %if.end76
  ret i32 %ret.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %rb = alloca %struct.req_batch, align 8
  %submit_state = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11
  %compl_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 6
  %0 = load i32, i32* %compl_nr, align 8
  %1 = bitcast %struct.req_batch* %rb to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %1) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false), !annotation !14
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %cmp41 = icmp sgt i32 %0, 0
  br i1 %cmp41, label %for.body.preheader, label %for.end14.critedge

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 5, i64 %indvars.iv
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %arrayidx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %2, i64 0, i32 10
  %3 = load i64, i64* %user_data, align 8
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %2, i64 0, i32 5
  %4 = load i32, i32* %result, align 4
  %conv = zext i32 %4 to i64
  %cflags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %2, i64 0, i32 0, i32 0, i32 0, i32 1
  %5 = bitcast i64* %cflags to i32*
  %6 = load i32, i32* %5, align 8
  %call = call fastcc i1 @__io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %3, i64 noundef %conv, i32 noundef %6) #25
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_init_req_batch(%struct.req_batch* noundef nonnull %rb) #25
  br i1 %cmp41, label %for.body5.preheader, label %for.end14

for.body5.preheader:                              ; preds = %for.end
  %wide.trip.count49 = zext i32 %0 to i64
  br label %for.body5

for.body5:                                        ; preds = %for.body5.preheader, %if.end
  %indvars.iv46 = phi i64 [ 0, %for.body5.preheader ], [ %indvars.iv.next47, %if.end ]
  %arrayidx9 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 5, i64 %indvars.iv46
  %7 = load %struct.io_kiocb*, %struct.io_kiocb** %arrayidx9, align 8
  %call10 = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %7) #25
  br i1 %call10, label %if.then, label %if.end

if.then:                                          ; preds = %for.body5
  call fastcc void @io_req_free_batch(%struct.req_batch* noundef nonnull %rb, %struct.io_kiocb* noundef %7, %struct.io_submit_state* noundef %submit_state) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body5
  %indvars.iv.next47 = add nuw nsw i64 %indvars.iv46, 1
  %exitcond50.not = icmp eq i64 %indvars.iv.next47, %wide.trip.count49
  br i1 %exitcond50.not, label %for.end14, label %for.body5

for.end14.critedge:                               ; preds = %entry
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_init_req_batch(%struct.req_batch* noundef nonnull %rb) #25
  br label %for.end14

for.end14:                                        ; preds = %if.end, %for.end14.critedge, %for.end
  call fastcc void @io_req_free_batch_finish(%struct.io_ring_ctx* noundef %ctx, %struct.req_batch* noundef nonnull %rb) #25
  store i32 0, i32* %compl_nr, align 8
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %1) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @io_prep_linked_timeout(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1048576
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !8

if.end:                                           ; preds = %entry
  %call = call fastcc %struct.io_kiocb* @__io_prep_linked_timeout(%struct.io_kiocb* noundef %req) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.io_kiocb* [ %call, %if.end ], [ null, %entry ]
  ret %struct.io_kiocb* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %head = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %1 = bitcast i32* %head to %struct.io_kiocb**
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %1, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %2, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = bitcast i8** %async_data to %struct.io_timeout_data**
  %4 = load %struct.io_timeout_data*, %struct.io_timeout_data** %3, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %4, i64 0, i32 1
  %function = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %4, i64 0, i32 1, i32 2
  store i32 (%struct.hrtimer*)* @io_link_timeout_fn, i32 (%struct.hrtimer*)** %function, align 8
  %.elt = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %4, i64 0, i32 2, i32 0
  %.unpack = load i64, i64* %.elt, align 8
  %5 = insertvalue [2 x i64] undef, i64 %.unpack, 0
  %6 = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %4, i64 0, i32 2, i32 1
  %.unpack17 = load i64, i64* %6, align 8
  %7 = insertvalue [2 x i64] %5, i64 %.unpack17, 1
  %call = call fastcc i64 @timespec64_to_ktime([2 x i64] %7) #25
  %mode = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %4, i64 0, i32 3
  %8 = load i32, i32* %mode, align 8
  call fastcc void @hrtimer_start(%struct.hrtimer* noundef %timer, i64 noundef %call, i32 noundef %8) #25
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %9 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  %ltimeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 13
  call fastcc void @list_add_tail(%struct.list_head* noundef %9, %struct.list_head* noundef %ltimeout_list) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_put_req(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_arm_poll_handler(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ipt = alloca %struct.io_poll_table, align 8
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %idxprom = zext i8 %0 to i64
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %2 = bitcast %struct.io_poll_table* %ipt to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %2) #26
  %3 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0, i32 1
  %4 = bitcast i32* %3 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %4, i8 0, i64 24, i1 false), !annotation !14
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %5 = load %struct.file*, %struct.file** %file, align 8
  %tobool.not = icmp eq %struct.file* %5, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call = call fastcc i1 @file_can_poll(%struct.file* noundef nonnull %5) #25
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %6 = load i32, i32* %flags, align 8
  %and = and i32 %6, 16384
  %tobool3.not = icmp eq i32 %and, 0
  br i1 %tobool3.not, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %7 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom, i32 0
  %bf.load = load i16, i16* %7, align 4
  %8 = and i16 %bf.load, 48
  %9 = icmp eq i16 %8, 0
  br i1 %9, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end5
  %10 = and i16 %bf.load, 16
  %tobool6.not = icmp eq i16 %10, 0
  br i1 %tobool6.not, label %if.end29, label %if.then19

if.then19:                                        ; preds = %if.end13
  %cmp = icmp eq i8 %0, 10
  br i1 %cmp, label %land.lhs.true22, label %if.end29

land.lhs.true22:                                  ; preds = %if.then19
  %msg_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %11 = bitcast void (%struct.kiocb*, i64, i64)** %msg_flags to i32*
  %12 = load i32, i32* %11, align 8
  %and23 = and i32 %12, 8192
  %tobool24.not = icmp eq i32 %and23, 0
  %spec.select = select i1 %tobool24.not, i32 1073741899, i32 1073741898
  br label %if.end29

if.end29:                                         ; preds = %land.lhs.true22, %if.end13, %if.then19
  %mask.0 = phi i32 [ 1073741899, %if.then19 ], [ %spec.select, %land.lhs.true22 ], [ 1073742094, %if.end13 ]
  %rw.0 = phi i32 [ 0, %if.then19 ], [ 0, %land.lhs.true22 ], [ 1, %if.end13 ]
  %call30 = call fastcc i1 @io_file_supports_nowait(%struct.io_kiocb* noundef %req, i32 noundef %rw.0) #25
  br i1 %call30, label %if.end32, label %cleanup

if.end32:                                         ; preds = %if.end29
  %13 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %13, i32 noundef 2592) #27
  %tobool34.not = icmp eq i8* %call.i.i, null
  br i1 %tobool34.not, label %cleanup, label %if.end40, !prof !24

if.end40:                                         ; preds = %if.end32
  %double_poll = getelementptr inbounds i8, i8* %call.i.i, i64 64
  %14 = bitcast i8* %double_poll to %struct.io_poll_iocb**
  store %struct.io_poll_iocb* null, %struct.io_poll_iocb** %14, align 8
  %apoll41 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 16
  %15 = bitcast %struct.async_poll** %apoll41 to i8**
  store i8* %call.i.i, i8** %15, align 8
  %16 = load i32, i32* %flags, align 8
  %or43 = or i32 %16, 16384
  store i32 %or43, i32* %flags, align 8
  %_qproc = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0, i32 0
  store void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)* @io_async_queue_proc, void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8
  call fastcc void @io_req_set_refcount(%struct.io_kiocb* noundef %req) #25
  %poll = bitcast i8* %call.i.i to %struct.io_poll_iocb*
  %call44 = call fastcc i32 @__io_arm_poll_handler(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef nonnull %poll, %struct.io_poll_table* noundef nonnull %ipt, i32 noundef %mask.0, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef nonnull @io_async_wake) #25
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %tobool45 = icmp ne i32 %call44, 0
  %error = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 3
  %17 = load i32, i32* %error, align 4
  %tobool47 = icmp ne i32 %17, 0
  %or.cond = select i1 %tobool45, i1 true, i1 %tobool47
  %cond = select i1 %tobool45, i32 2, i32 1
  %spec.select92 = select i1 %or.cond, i32 %cond, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.end32, %if.end29, %if.end5, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ], [ 1, %if.end5 ], [ 1, %if.end29 ], [ 1, %if.end32 ], [ %spec.select92, %if.end40 ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %2) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_queue_async_work(%struct.io_kiocb* noundef %req, i8* nocapture noundef readnone %locked) #1 {
entry:
  %call = call fastcc %struct.io_kiocb* @io_prep_linked_timeout(%struct.io_kiocb* noundef %req) #25
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %0 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i64 0, i32 85
  %1 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %1, null
  br i1 %tobool.not, label %do.body5, label %do.body11, !prof !24

do.body5:                                         ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1452; .short 0; .popsection; 14471: brk 0x800", ""() #26, !srcloc !50
  unreachable

do.body11:                                        ; preds = %entry
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %1, i64 0, i32 4
  %2 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool12.not = icmp eq %struct.io_wq* %2, null
  br i1 %tobool12.not, label %do.body23, label %do.end31, !prof !24

do.body23:                                        ; preds = %do.body11
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1453; .short 0; .popsection; 14471: brk 0x800", ""() #26, !srcloc !51
  unreachable

do.end31:                                         ; preds = %do.body11
  call fastcc void @io_prep_async_link(%struct.io_kiocb* noundef %req) #25
  %3 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %4 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %5 = inttoptr i64 %4 to %struct.task_struct*
  %call34 = call fastcc i1 @same_thread_group(%struct.task_struct* noundef %3, %struct.task_struct* noundef %5) #25
  br i1 %call34, label %if.end60, label %if.then49, !prof !8

if.then49:                                        ; preds = %do.end31
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1465; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !52
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 17, i32 1
  %6 = load i32, i32* %flags, align 8
  %or = or i32 %6, 1
  store i32 %or, i32* %flags, align 8
  br label %if.end60

if.end60:                                         ; preds = %do.end31, %if.then49
  %work61 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 17
  %7 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  call void @io_wq_enqueue(%struct.io_wq* noundef %7, %struct.io_wq_work* noundef %work61) #27
  %tobool68.not = icmp eq %struct.io_kiocb* %call, null
  br i1 %tobool68.not, label %if.end70, label %if.then69

if.then69:                                        ; preds = %if.end60
  call fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef nonnull %call) #25
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %if.end60
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.cred* @override_creds(%struct.cred* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_nop(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef 0, i32 noundef 0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_read(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %inline_vecs = alloca [8 x %struct.iovec], align 8
  %iovec = alloca %struct.iovec*, align 8
  %__iter = alloca %struct.iov_iter, align 8
  %__state = alloca %struct.iov_iter_state, align 8
  %0 = bitcast [8 x %struct.iovec]* %inline_vecs to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(128) %0, i8 0, i64 128, i1 false), !annotation !14
  %1 = bitcast %struct.iovec** %iovec to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %1) #26
  %arraydecay = getelementptr inbounds [8 x %struct.iovec], [8 x %struct.iovec]* %inline_vecs, i64 0, i64 0
  store %struct.iovec* %arraydecay, %struct.iovec** %iovec, align 8
  %kiocb1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0
  %2 = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %__iter, i64 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %2) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(40) %2, i8 0, i64 40, i1 false), !annotation !14
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = bitcast i8** %async_data to %struct.io_async_rw**
  %4 = load %struct.io_async_rw*, %struct.io_async_rw** %3, align 8
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  %5 = bitcast %struct.iov_iter_state* %__state to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(24) %5, i8 0, i64 24, i1 false), !annotation !14
  %tobool3.not = icmp eq %struct.io_async_rw* %4, null
  br i1 %tobool3.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %iter4 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %4, i64 0, i32 2
  %iter_state = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %4, i64 0, i32 3
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter4, %struct.iov_iter_state* noundef %iter_state) #27
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  br label %if.end9

if.else:                                          ; preds = %entry
  %call = call fastcc i32 @io_import_iovec(i32 noundef 0, %struct.io_kiocb* noundef %req, %struct.iovec** noundef nonnull %iovec, %struct.iov_iter* noundef nonnull %__iter, i1 noundef %tobool.not) #25
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %if.else
  call fastcc void @iov_iter_save_state(%struct.iov_iter* noundef nonnull %__iter, %struct.iov_iter_state* noundef nonnull %__state) #25
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  %iter.0 = phi %struct.iov_iter* [ %iter4, %if.then ], [ %__iter, %if.end ]
  %state.0 = phi %struct.iov_iter_state* [ %iter_state, %if.then ], [ %__state, %if.end ]
  %call10 = call fastcc i64 @iov_iter_count(%struct.iov_iter* noundef %iter.0) #25
  %conv11 = trunc i64 %call10 to i32
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %conv11, i32* %result, align 4
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %6 = load i32, i32* %ki_flags, align 8
  br i1 %tobool.not, label %if.end17.thread, label %land.lhs.true

if.end17.thread:                                  ; preds = %if.end9
  %and14 = and i32 %6, -9
  store i32 %and14, i32* %ki_flags, align 8
  br label %if.end27

land.lhs.true:                                    ; preds = %if.end9
  %or = or i32 %6, 8
  store i32 %or, i32* %ki_flags, align 8
  %call20 = call fastcc i1 @io_file_supports_nowait(%struct.io_kiocb* noundef %req, i32 noundef 0) #25
  br i1 %call20, label %land.lhs.true.if.end27_crit_edge, label %if.then21

land.lhs.true.if.end27_crit_edge:                 ; preds = %land.lhs.true
  %.pre = load i32, i32* %result, align 4
  br label %if.end27

if.then21:                                        ; preds = %land.lhs.true
  %7 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %call23 = call fastcc i32 @io_setup_async_rw(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %7, %struct.iovec* noundef nonnull %arraydecay, %struct.iov_iter* noundef %iter.0, i1 noundef true) #25
  %tobool25.not = icmp eq i32 %call23, 0
  %narrow = select i1 %tobool25.not, i32 -11, i32 %call23
  br label %cleanup

if.end27:                                         ; preds = %land.lhs.true.if.end27_crit_edge, %if.end17.thread
  %8 = phi i32 [ %.pre, %land.lhs.true.if.end27_crit_edge ], [ %conv11, %if.end17.thread ]
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %9 = load %struct.file*, %struct.file** %file, align 8
  %call28 = call fastcc i64* @io_kiocb_ppos(%struct.kiocb* noundef %kiocb1) #25
  %conv30 = zext i32 %8 to i64
  %call31 = call i32 @rw_verify_area(i32 noundef 0, %struct.file* noundef %9, i64* noundef %call28, i64 noundef %conv30) #27
  %tobool33.not = icmp eq i32 %call31, 0
  br i1 %tobool33.not, label %if.end40, label %if.then38, !prof !8

if.then38:                                        ; preds = %if.end27
  %10 = bitcast %struct.iovec** %iovec to i8**
  %11 = load i8*, i8** %10, align 8
  call void @kfree(i8* noundef %11) #27
  br label %cleanup

if.end40:                                         ; preds = %if.end27
  %call41 = call fastcc i32 @io_iter_do_read(%struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter.0) #25
  %conv42 = sext i32 %call41 to i64
  %cmp43 = icmp ne i32 %call41, -11
  %flags48.phi.trans.insert = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %.pre208 = load i32, i32* %flags48.phi.trans.insert, align 8
  %and45 = and i32 %.pre208, 131072
  %tobool46.not = icmp eq i32 %and45, 0
  %or.cond209 = select i1 %cmp43, i1 %tobool46.not, i1 false
  br i1 %or.cond209, label %if.else62, label %if.then47

if.then47:                                        ; preds = %if.end40
  %flags48 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %and49 = and i32 %.pre208, -131073
  store i32 %and49, i32* %flags48, align 8
  br i1 %tobool.not, label %land.lhs.true51, label %if.end56

land.lhs.true51:                                  ; preds = %if.then47
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %12 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags52 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %12, i64 0, i32 0, i32 2
  %13 = load i32, i32* %flags52, align 8
  %and53 = and i32 %13, 1
  %tobool54.not = icmp ne i32 %and53, 0
  %and58 = and i32 %.pre208, 2048
  %tobool59.not = icmp eq i32 %and58, 0
  %or.cond207 = select i1 %tobool54.not, i1 %tobool59.not, i1 false
  br i1 %or.cond207, label %if.end85, label %done

if.end56:                                         ; preds = %if.then47
  %and58.old = and i32 %.pre208, 2048
  %tobool59.not.old = icmp eq i32 %and58.old, 0
  br i1 %tobool59.not.old, label %if.end85, label %done

if.else62:                                        ; preds = %if.end40
  %cmp63 = icmp eq i32 %call41, -529
  br i1 %cmp63, label %out_free, label %if.else66

if.else66:                                        ; preds = %if.else62
  %cmp67 = icmp slt i32 %call41, 1
  br i1 %cmp67, label %done, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %if.else66
  %14 = load i32, i32* %result, align 4
  %conv71 = zext i32 %14 to i64
  %cmp72 = icmp eq i64 %conv42, %conv71
  %brmerge = or i1 %tobool.not, %cmp72
  %brmerge.not = xor i1 %brmerge, true
  %and78 = and i32 %.pre208, 2048
  %tobool79.not = icmp eq i32 %and78, 0
  %or.cond = select i1 %brmerge.not, i1 %tobool79.not, i1 false
  br i1 %or.cond, label %lor.lhs.false80, label %done

lor.lhs.false80:                                  ; preds = %lor.lhs.false69
  %call81 = call fastcc i1 @need_read_all(%struct.io_kiocb* noundef %req) #25
  br i1 %call81, label %if.end85, label %done

if.end85:                                         ; preds = %land.lhs.true51, %if.end56, %lor.lhs.false80
  %ret.0 = phi i64 [ %conv42, %lor.lhs.false80 ], [ 0, %if.end56 ], [ 0, %land.lhs.true51 ]
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter.0, %struct.iov_iter_state* noundef %state.0) #27
  %15 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %call87 = call fastcc i32 @io_setup_async_rw(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %15, %struct.iovec* noundef nonnull %arraydecay, %struct.iov_iter* noundef %iter.0, i1 noundef true) #25
  %tobool89.not = icmp eq i32 %call87, 0
  br i1 %tobool89.not, label %if.end92, label %cleanup

if.end92:                                         ; preds = %if.end85
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  %16 = load %struct.io_async_rw*, %struct.io_async_rw** %3, align 8
  %iter94 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %16, i64 0, i32 2
  %cmp95.not = icmp eq %struct.iov_iter* %iter.0, %iter94
  %iter_state99 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %16, i64 0, i32 3
  %spec.select206 = select i1 %cmp95.not, %struct.iov_iter_state* %state.0, %struct.iov_iter_state* %iter_state99
  %bytes_done = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %16, i64 0, i32 4
  %ki_flags116 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  br label %do.body

do.body:                                          ; preds = %if.end115, %if.end92
  %ret.1 = phi i64 [ %ret.0, %if.end92 ], [ %conv111, %if.end115 ]
  call void @iov_iter_advance(%struct.iov_iter* noundef %iter94, i64 noundef %ret.1) #27
  %call101 = call fastcc i64 @iov_iter_count(%struct.iov_iter* noundef %iter94) #25
  %tobool102.not = icmp eq i64 %call101, 0
  br i1 %tobool102.not, label %done, label %if.end104

if.end104:                                        ; preds = %do.body
  %17 = load i64, i64* %bytes_done, align 8
  %add = add i64 %17, %ret.1
  store i64 %add, i64* %bytes_done, align 8
  call fastcc void @iov_iter_save_state(%struct.iov_iter* noundef %iter94, %struct.iov_iter_state* noundef %spec.select206) #25
  %call105 = call fastcc i1 @io_rw_should_retry(%struct.io_kiocb* noundef %req) #25
  br i1 %call105, label %if.end109, label %if.then106

if.then106:                                       ; preds = %if.end104
  %18 = load i32, i32* %ki_flags116, align 8
  %and108 = and i32 %18, -524289
  store i32 %and108, i32* %ki_flags116, align 8
  br label %cleanup

if.end109:                                        ; preds = %if.end104
  %call110 = call fastcc i32 @io_iter_do_read(%struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter94) #25
  %conv111 = sext i32 %call110 to i64
  %cmp112 = icmp eq i32 %call110, -529
  br i1 %cmp112, label %cleanup, label %if.end115

if.end115:                                        ; preds = %if.end109
  %19 = load i32, i32* %ki_flags116, align 8
  %and117 = and i32 %19, -524289
  store i32 %and117, i32* %ki_flags116, align 8
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter94, %struct.iov_iter_state* noundef %spec.select206) #27
  %cmp118 = icmp sgt i32 %call110, 0
  br i1 %cmp118, label %do.body, label %done

done:                                             ; preds = %if.end115, %do.body, %lor.lhs.false69, %if.else66, %lor.lhs.false80, %if.end56, %land.lhs.true51
  %ret.2 = phi i64 [ %conv42, %if.end56 ], [ %conv42, %land.lhs.true51 ], [ %conv42, %if.else66 ], [ %conv42, %lor.lhs.false69 ], [ %conv42, %lor.lhs.false80 ], [ %ret.1, %do.body ], [ %conv111, %if.end115 ]
  call fastcc void @kiocb_done(%struct.kiocb* noundef %kiocb1, i64 noundef %ret.2, i32 noundef %issue_flags) #25
  br label %out_free

out_free:                                         ; preds = %if.else62, %done
  %20 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %tobool120.not = icmp eq %struct.iovec* %20, null
  br i1 %tobool120.not, label %cleanup, label %if.then121

if.then121:                                       ; preds = %out_free
  %21 = bitcast %struct.iovec* %20 to i8*
  call void @kfree(i8* noundef nonnull %21) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end109, %out_free, %if.then121, %if.end85, %if.else, %if.then106, %if.then38, %if.then21
  %retval.0 = phi i32 [ %call31, %if.then38 ], [ -11, %if.then106 ], [ %narrow, %if.then21 ], [ %call, %if.else ], [ %call87, %if.end85 ], [ 0, %if.then121 ], [ 0, %out_free ], [ 0, %if.end109 ]
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #26
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %2) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %1) #26
  call void @llvm.lifetime.end.p0i8(i64 128, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_write(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %inline_vecs = alloca [8 x %struct.iovec], align 8
  %iovec = alloca %struct.iovec*, align 8
  %__iter = alloca %struct.iov_iter, align 8
  %__state = alloca %struct.iov_iter_state, align 8
  %0 = bitcast [8 x %struct.iovec]* %inline_vecs to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(128) %0, i8 0, i64 128, i1 false), !annotation !14
  %1 = bitcast %struct.iovec** %iovec to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %1) #26
  %arraydecay = getelementptr inbounds [8 x %struct.iovec], [8 x %struct.iovec]* %inline_vecs, i64 0, i64 0
  store %struct.iovec* %arraydecay, %struct.iovec** %iovec, align 8
  %kiocb1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0
  %2 = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %__iter, i64 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %2) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(40) %2, i8 0, i64 40, i1 false), !annotation !14
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = bitcast i8** %async_data to %struct.io_async_rw**
  %4 = load %struct.io_async_rw*, %struct.io_async_rw** %3, align 8
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  %5 = bitcast %struct.iov_iter_state* %__state to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(24) %5, i8 0, i64 24, i1 false), !annotation !14
  %tobool3.not = icmp eq %struct.io_async_rw* %4, null
  br i1 %tobool3.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %iter4 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %4, i64 0, i32 2
  %iter_state = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %4, i64 0, i32 3
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter4, %struct.iov_iter_state* noundef %iter_state) #27
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  br label %if.end9

if.else:                                          ; preds = %entry
  %call = call fastcc i32 @io_import_iovec(i32 noundef 1, %struct.io_kiocb* noundef %req, %struct.iovec** noundef nonnull %iovec, %struct.iov_iter* noundef nonnull %__iter, i1 noundef %tobool.not) #25
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %if.else
  call fastcc void @iov_iter_save_state(%struct.iov_iter* noundef nonnull %__iter, %struct.iov_iter_state* noundef nonnull %__state) #25
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  %iter.0 = phi %struct.iov_iter* [ %iter4, %if.then ], [ %__iter, %if.end ]
  %state.0 = phi %struct.iov_iter_state* [ %iter_state, %if.then ], [ %__state, %if.end ]
  %call10 = call fastcc i64 @iov_iter_count(%struct.iov_iter* noundef %iter.0) #25
  %conv11 = trunc i64 %call10 to i32
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %conv11, i32* %result, align 4
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %6 = load i32, i32* %ki_flags, align 8
  br i1 %tobool.not, label %if.end17.thread, label %land.lhs.true

if.end17.thread:                                  ; preds = %if.end9
  %and14 = and i32 %6, -9
  store i32 %and14, i32* %ki_flags, align 8
  br label %if.end33

land.lhs.true:                                    ; preds = %if.end9
  %or = or i32 %6, 8
  store i32 %or, i32* %ki_flags, align 8
  %call20 = call fastcc i1 @io_file_supports_nowait(%struct.io_kiocb* noundef %req, i32 noundef 1) #25
  br i1 %call20, label %land.lhs.true25, label %copy_iov

land.lhs.true25:                                  ; preds = %land.lhs.true
  %7 = load i32, i32* %ki_flags, align 8
  %and27 = and i32 %7, 131072
  %tobool28.not = icmp eq i32 %and27, 0
  br i1 %tobool28.not, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %land.lhs.true25
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %8 = load i32, i32* %flags, align 8
  %and30 = and i32 %8, 8388608
  %tobool31.not = icmp eq i32 %and30, 0
  br i1 %tobool31.not, label %if.end33, label %copy_iov

if.end33:                                         ; preds = %if.end17.thread, %land.lhs.true29, %land.lhs.true25
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %9 = load %struct.file*, %struct.file** %file, align 8
  %call34 = call fastcc i64* @io_kiocb_ppos(%struct.kiocb* noundef %kiocb1) #25
  %10 = load i32, i32* %result, align 4
  %conv36 = zext i32 %10 to i64
  %call37 = call i32 @rw_verify_area(i32 noundef 1, %struct.file* noundef %9, i64* noundef %call34, i64 noundef %conv36) #27
  %tobool39.not = icmp eq i32 %call37, 0
  br i1 %tobool39.not, label %if.end45, label %out_free, !prof !8

if.end45:                                         ; preds = %if.end33
  %flags46 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %11 = load i32, i32* %flags46, align 8
  %and47 = and i32 %11, 8388608
  %tobool48.not = icmp eq i32 %and47, 0
  br i1 %tobool48.not, label %if.end55, label %__here

__here:                                           ; preds = %if.end45
  %12 = load %struct.file*, %struct.file** %file, align 8
  %call51 = call fastcc %struct.inode* @file_inode(%struct.file* noundef %12) #25
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %call51, i64 0, i32 6
  %13 = load %struct.super_block*, %struct.super_block** %i_sb, align 8
  call fastcc void @sb_start_write(%struct.super_block* noundef %13) #25
  br label %if.end55

if.end55:                                         ; preds = %__here, %if.end45
  %ki_flags56 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %14 = load i32, i32* %ki_flags56, align 8
  %or57 = or i32 %14, 262144
  store i32 %or57, i32* %ki_flags56, align 8
  %15 = load %struct.file*, %struct.file** %file, align 8
  %f_op = getelementptr inbounds %struct.file, %struct.file* %15, i64 0, i32 3
  %16 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %write_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %16, i64 0, i32 5
  %17 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %write_iter, align 8
  %tobool59.not = icmp eq i64 (%struct.kiocb*, %struct.iov_iter*)* %17, null
  br i1 %tobool59.not, label %if.else63, label %if.then60

if.then60:                                        ; preds = %if.end55
  %call62 = call fastcc i64 @call_write_iter(%struct.file* noundef %15, %struct.kiocb* noundef %kiocb1, %struct.iov_iter* noundef %iter.0) #25
  br label %if.end71

if.else63:                                        ; preds = %if.end55
  %write = getelementptr inbounds %struct.file_operations, %struct.file_operations* %16, i64 0, i32 3
  %18 = load i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)** %write, align 8
  %tobool66.not = icmp eq i64 (%struct.file*, i8*, i64, i64*)* %18, null
  br i1 %tobool66.not, label %if.end71, label %if.then67

if.then67:                                        ; preds = %if.else63
  %call68 = call fastcc i64 @loop_rw_iter(i32 noundef 1, %struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter.0) #25
  br label %if.end71

if.end71:                                         ; preds = %if.else63, %if.then67, %if.then60
  %ret2.0 = phi i64 [ %call62, %if.then60 ], [ %call68, %if.then67 ], [ -22, %if.else63 ]
  %19 = load i32, i32* %flags46, align 8
  %and73 = and i32 %19, 131072
  %tobool74.not = icmp eq i32 %and73, 0
  br i1 %tobool74.not, label %if.end78, label %if.end78.thread

if.end78.thread:                                  ; preds = %if.end71
  %and77 = and i32 %19, -131073
  store i32 %and77, i32* %flags46, align 8
  br label %land.lhs.true89

if.end78:                                         ; preds = %if.end71
  switch i64 %ret2.0, label %done [
    i64 -95, label %land.lhs.true81
    i64 -11, label %land.lhs.true89
  ]

land.lhs.true81:                                  ; preds = %if.end78
  %20 = load i32, i32* %ki_flags56, align 8
  %and83 = and i32 %20, 8
  %tobool84.not = icmp eq i32 %and83, 0
  br i1 %tobool84.not, label %done, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %if.end78, %if.end78.thread, %land.lhs.true81
  %21 = phi i32 [ %19, %if.end78 ], [ %and77, %if.end78.thread ], [ %19, %land.lhs.true81 ]
  %and91 = and i32 %21, 2048
  %tobool92.not = icmp eq i32 %and91, 0
  br i1 %tobool92.not, label %if.end94, label %done

if.end94:                                         ; preds = %land.lhs.true89
  br i1 %tobool.not, label %if.then98, label %copy_iov

if.then98:                                        ; preds = %if.end94
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %22 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags99 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %22, i64 0, i32 0, i32 2
  %23 = load i32, i32* %flags99, align 8
  %and100 = and i32 %23, 1
  %tobool101.not = icmp eq i32 %and100, 0
  br i1 %tobool101.not, label %done, label %copy_iov

done:                                             ; preds = %if.end78, %land.lhs.true81, %if.then98, %land.lhs.true89
  %ret2.2190 = phi i64 [ -11, %if.then98 ], [ -11, %land.lhs.true89 ], [ -95, %land.lhs.true81 ], [ %ret2.0, %if.end78 ]
  call fastcc void @kiocb_done(%struct.kiocb* noundef %kiocb1, i64 noundef %ret2.2190, i32 noundef %issue_flags) #25
  br label %out_free

copy_iov:                                         ; preds = %if.end94, %if.then98, %land.lhs.true29, %land.lhs.true
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter.0, %struct.iov_iter_state* noundef %state.0) #27
  %24 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %call109 = call fastcc i32 @io_setup_async_rw(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %24, %struct.iovec* noundef nonnull %arraydecay, %struct.iov_iter* noundef %iter.0, i1 noundef false) #25
  %tobool111.not = icmp eq i32 %call109, 0
  %narrow = select i1 %tobool111.not, i32 -11, i32 %call109
  br label %cleanup

out_free:                                         ; preds = %if.end33, %done
  %25 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %tobool114.not = icmp eq %struct.iovec* %25, null
  br i1 %tobool114.not, label %cleanup, label %if.then115

if.then115:                                       ; preds = %out_free
  %26 = bitcast %struct.iovec* %25 to i8*
  call void @kfree(i8* noundef nonnull %26) #27
  br label %cleanup

cleanup:                                          ; preds = %out_free, %if.then115, %if.else, %copy_iov
  %retval.0 = phi i32 [ %narrow, %copy_iov ], [ %call, %if.else ], [ %call37, %if.then115 ], [ %call37, %out_free ]
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #26
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %2) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %1) #26
  call void @llvm.lifetime.end.p0i8(i64 128, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_fsync(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %off = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %0 = bitcast void (%struct.kiocb*, i64, i64)** %off to i64*
  %1 = load i64, i64* %0, align 8
  %2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %add = add i64 %3, %1
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  %cmp = icmp sgt i64 %add, 0
  %cond = select i1 %cmp, i64 %add, i64 9223372036854775807
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %flags to i32*
  %6 = load i32, i32* %5, align 8
  %and5 = and i32 %6, 1
  %call = call i32 @vfs_fsync_range(%struct.file* noundef %4, i64 noundef %1, i64 noundef %cond, i32 noundef %and5) #27
  %cmp6 = icmp slt i32 %call, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_poll_add(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ipt = alloca %struct.io_poll_table, align 8
  %poll1 = bitcast %struct.io_kiocb* %req to %struct.io_poll_iocb*
  %ctx2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %1 = bitcast %struct.io_poll_table* %ipt to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %1) #26
  %2 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0, i32 1
  %3 = bitcast i32* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %3, i8 0, i64 24, i1 false), !annotation !14
  %_qproc = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0, i32 0
  store void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)* @io_poll_queue_proc, void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8
  %events = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %4 = bitcast void (%struct.kiocb*, i64, i64)** %events to i32*
  %5 = load i32, i32* %4, align 8
  %call = call fastcc i32 @__io_arm_poll_handler(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %poll1, %struct.io_poll_table* noundef nonnull %ipt, i32 noundef %5, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef nonnull @io_poll_wake) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end.thread, label %if.then6

if.end.thread:                                    ; preds = %entry
  %rlock.i3 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i3) #27
  br label %if.end10

if.then6:                                         ; preds = %entry
  %error = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 3
  store i32 0, i32* %error, align 4
  %call4 = call fastcc i1 @io_poll_complete(%struct.io_kiocb* noundef %req, i32 noundef %call) #25
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %0) #25
  br i1 %call4, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  call fastcc void @io_put_req(%struct.io_kiocb* noundef %req) #25
  br label %if.end10

if.end10:                                         ; preds = %if.end.thread, %if.then6, %if.then8
  %error11 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 3
  %6 = load i32, i32* %error11, align 4
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %1) #26
  ret i32 %6
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_poll_update(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %poll_update = bitcast %struct.io_kiocb* %req to %struct.io_poll_update*
  %1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %2 = load i64, i64* %1, align 8
  %call = call fastcc %struct.io_kiocb* @io_poll_find(%struct.io_ring_ctx* noundef %0, i64 noundef %2, i1 noundef true) #25
  %tobool.not = icmp eq %struct.io_kiocb* %call, null
  br i1 %tobool.not, label %if.then16, label %if.end

if.end:                                           ; preds = %entry
  %update_events = getelementptr inbounds %struct.io_poll_update, %struct.io_poll_update* %poll_update, i64 0, i32 4
  %3 = load i8, i8* %update_events, align 4, !range !18
  %tobool3.not = icmp eq i8 %3, 0
  br i1 %tobool3.not, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end
  %update_user_data = getelementptr inbounds %struct.io_poll_update, %struct.io_poll_update* %poll_update, i64 0, i32 5
  %4 = load i8, i8* %update_user_data, align 1, !range !18
  %tobool5.not = icmp eq i8 %4, 0
  br i1 %tobool5.not, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %call7 = call fastcc i1 @io_poll_remove_one(%struct.io_kiocb* noundef nonnull %call) #25
  br i1 %call7, label %if.end18, label %if.then16

if.end8:                                          ; preds = %land.lhs.true, %if.end
  %poll = bitcast %struct.io_kiocb* %call to %struct.io_poll_iocb*
  %call9 = call fastcc i1 @__io_poll_remove_one(%struct.io_kiocb* noundef nonnull %call, %struct.io_poll_iocb* noundef nonnull %poll, i1 noundef false) #25
  br i1 %call9, label %if.end18, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %if.end8
  %events = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 0, i32 0, i32 0, i32 2
  %5 = bitcast void (%struct.kiocb*, i64, i64)** %events to i32*
  %6 = load i32, i32* %5, align 8
  %and = and i32 %6, 1073741824
  %tobool13.not = icmp eq i32 %and, 0
  br i1 %tobool13.not, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.then6, %entry, %land.lhs.true11
  %ret.0.ph = phi i64 [ -114, %land.lhs.true11 ], [ -2, %entry ], [ -114, %if.then6 ]
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %ret.0.ph) #25
  br label %cleanup

if.end18:                                         ; preds = %if.then6, %if.end8, %land.lhs.true11
  %completing.0.shrunk = phi i1 [ true, %land.lhs.true11 ], [ false, %if.end8 ], [ true, %if.then6 ]
  %7 = load i8, i8* %update_events, align 4, !range !18
  %tobool21.not = icmp eq i8 %7, 0
  br i1 %tobool21.not, label %if.end34, label %if.then22

if.then22:                                        ; preds = %if.end18
  %events24 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 0, i32 0, i32 0, i32 2
  %8 = bitcast void (%struct.kiocb*, i64, i64)** %events24 to i32*
  %9 = load i32, i32* %8, align 8
  %and25 = and i32 %9, -65536
  store i32 %and25, i32* %8, align 8
  %events27 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %10 = bitcast i8** %events27 to i32*
  %11 = load i32, i32* %10, align 8
  %and28 = and i32 %11, 57287
  %or = or i32 %and25, %and28
  %or33 = or i32 %or, 8248
  store i32 %or33, i32* %8, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then22, %if.end18
  %update_user_data36 = getelementptr inbounds %struct.io_poll_update, %struct.io_poll_update* %poll_update, i64 0, i32 5
  %12 = load i8, i8* %update_user_data36, align 1, !range !18
  %tobool37.not = icmp eq i8 %12, 0
  br i1 %tobool37.not, label %if.end40, label %if.then38

if.then38:                                        ; preds = %if.end34
  %new_user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %new_user_data to i64*
  %14 = load i64, i64* %13, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 10
  store i64 %14, i64* %user_data, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end34
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef 0) #25
  br i1 %completing.0.shrunk, label %cleanup, label %if.then44

if.then44:                                        ; preds = %if.end40
  %call45 = call fastcc i32 @io_poll_add(%struct.io_kiocb* noundef nonnull %call) #25
  %cmp46 = icmp slt i32 %call45, 0
  br i1 %cmp46, label %if.then48, label %cleanup

if.then48:                                        ; preds = %if.then44
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef nonnull %call) #25
  %conv49 = sext i32 %call45 to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef nonnull %call, i64 noundef %conv49) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.then48, %if.then44, %if.then16
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sync_file_range(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %off = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %1 = bitcast void (%struct.kiocb*, i64, i64)** %off to i64*
  %2 = load i64, i64* %1, align 8
  %3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %flags to i32*
  %6 = load i32, i32* %5, align 8
  %call = call i32 @sync_file_range(%struct.file* noundef %0, i64 noundef %2, i64 noundef %4, i32 noundef %6) #27
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_timeout(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %1 = bitcast i8** %async_data to %struct.io_timeout_data**
  %2 = load %struct.io_timeout_data*, %struct.io_timeout_data** %1, align 8
  %off3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %3 = bitcast i64* %off3 to i32*
  %4 = load i32, i32* %3, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %call = call fastcc i1 @io_is_timeout_noseq(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %prev = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 12, i32 1
  %5 = load %struct.list_head*, %struct.list_head** %prev, align 8
  br label %add19

if.end:                                           ; preds = %entry
  %timeout = bitcast %struct.io_kiocb* %req to %struct.io_timeout*
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 0
  %6 = load i32, i32* %cached_cq_tail, align 64
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 6, i32 0
  %7 = load volatile i32, i32* %counter.i, align 4
  %sub = sub i32 %6, %7
  %add = add i32 %sub, %4
  %target_seq = getelementptr inbounds %struct.io_timeout, %struct.io_timeout* %timeout, i64 0, i32 2
  store i32 %add, i32* %target_seq, align 4
  %cq_last_tm_flush = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 7
  store i32 %sub, i32* %cq_last_tm_flush, align 8
  %timeout_list6 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 12
  %prev7 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 12, i32 1
  %entry2.08 = load %struct.list_head*, %struct.list_head** %prev7, align 8
  %cmp.not9 = icmp eq %struct.list_head* %entry2.08, %timeout_list6
  br i1 %cmp.not9, label %add19, label %for.body

for.body:                                         ; preds = %if.end, %for.inc
  %entry2.010 = phi %struct.list_head* [ %entry2.0, %for.inc ], [ %entry2.08, %if.end ]
  %add.ptr3 = getelementptr %struct.list_head, %struct.list_head* %entry2.010, i64 -1
  %8 = bitcast %struct.list_head* %add.ptr3 to %struct.io_kiocb*
  %call9 = call fastcc i1 @io_is_timeout_noseq(%struct.io_kiocb* noundef %8) #25
  br i1 %call9, label %for.inc, label %cleanup

cleanup:                                          ; preds = %for.body
  %timeout12 = bitcast %struct.list_head* %add.ptr3 to %struct.io_timeout*
  %target_seq13 = getelementptr inbounds %struct.io_timeout, %struct.io_timeout* %timeout12, i64 0, i32 2
  %9 = load i32, i32* %target_seq13, align 4
  %sub14 = sub i32 %9, %sub
  %cmp15.not.not = icmp ult i32 %4, %sub14
  br i1 %cmp15.not.not, label %for.inc, label %add19

for.inc:                                          ; preds = %for.body, %cleanup
  %prev18 = getelementptr inbounds %struct.list_head, %struct.list_head* %entry2.010, i64 0, i32 1
  %entry2.0 = load %struct.list_head*, %struct.list_head** %prev18, align 8
  %cmp.not = icmp eq %struct.list_head* %entry2.0, %timeout_list6
  br i1 %cmp.not, label %add19, label %for.body

add19:                                            ; preds = %for.inc, %cleanup, %if.end, %if.then
  %entry2.1 = phi %struct.list_head* [ %5, %if.then ], [ %timeout_list6, %if.end ], [ %timeout_list6, %for.inc ], [ %entry2.010, %cleanup ]
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %10 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @list_add(%struct.list_head* noundef %10, %struct.list_head* noundef %entry2.1) #25
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %2, i64 0, i32 1
  %function = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %2, i64 0, i32 1, i32 2
  store i32 (%struct.hrtimer*)* @io_timeout_fn, i32 (%struct.hrtimer*)** %function, align 8
  %.elt = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %2, i64 0, i32 2, i32 0
  %.unpack = load i64, i64* %.elt, align 8
  %11 = insertvalue [2 x i64] undef, i64 %.unpack, 0
  %12 = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %2, i64 0, i32 2, i32 1
  %.unpack2 = load i64, i64* %12, align 8
  %13 = insertvalue [2 x i64] %11, i64 %.unpack2, 1
  %call22 = call fastcc i64 @timespec64_to_ktime([2 x i64] %13) #25
  %mode = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %2, i64 0, i32 3
  %14 = load i32, i32* %mode, align 8
  call fastcc void @hrtimer_start(%struct.hrtimer* noundef %timer, i64 noundef %call22, i32 noundef %14) #25
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_timeout_remove(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %2 = load i32, i32* %1, align 8
  %and = and i32 %2, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %rlock.i1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i1) #27
  %3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %call = call fastcc i32 @io_timeout_cancel(%struct.io_ring_ctx* noundef %0, i64 noundef %4) #25
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i1) #27
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end17

if.else:                                          ; preds = %entry
  %call6 = call fastcc i32 @io_translate_timeout_mode(i32 noundef %2) #25
  %rlock.i4 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i4) #27
  %ltimeout = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 5
  %5 = bitcast i16* %ltimeout to i8*
  %6 = load i8, i8* %5, align 4, !range !18
  %tobool8.not = icmp eq i8 %6, 0
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %ts14 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %9 = bitcast void (%struct.kiocb*, i64, i64)** %ts14 to %struct.timespec64*
  br i1 %tobool8.not, label %if.else12, label %if.then9

if.then9:                                         ; preds = %if.else
  %call11 = call fastcc i32 @io_linked_timeout_update(%struct.io_ring_ctx* noundef %0, i64 noundef %8, %struct.timespec64* noundef %9, i32 noundef %call6) #25
  br label %if.end

if.else12:                                        ; preds = %if.else
  %call15 = call fastcc i32 @io_timeout_update(%struct.io_ring_ctx* noundef %0, i64 noundef %8, %struct.timespec64* noundef %9, i32 noundef %call6) #25
  br label %if.end

if.end:                                           ; preds = %if.else12, %if.then9
  %ret.0 = phi i32 [ %call11, %if.then9 ], [ %call15, %if.else12 ]
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i4) #27
  br label %if.end17

if.end17:                                         ; preds = %if.end, %if.then
  %ret.1 = phi i32 [ %ret.0, %if.end ], [ %call, %if.then ]
  %cmp = icmp slt i32 %ret.1, 0
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end17
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end17
  %conv = sext i32 %ret.1 to i64
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %conv, i32 noundef 0) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_async_cancel(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %2 = load i64, i64* %1, align 8
  %call = call fastcc i32 @io_try_cancel_userdata(%struct.io_kiocb* noundef %req, i64 noundef %2) #25
  %cmp.not = icmp eq i32 %call, -2
  br i1 %cmp.not, label %if.end, label %done

if.end:                                           ; preds = %entry
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %tctx_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 14, i32 6
  %3 = bitcast %struct.list_head* %tctx_list to %struct.io_tctx_node**
  %node.01 = load %struct.io_tctx_node*, %struct.io_tctx_node** %3, align 8
  %ctx_node2 = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.01, i64 0, i32 0
  %cmp3.not3 = icmp eq %struct.list_head* %ctx_node2, %tctx_list
  br i1 %cmp3.not3, label %for.end, label %for.body

for.body:                                         ; preds = %if.end, %for.inc
  %node.04 = phi %struct.io_tctx_node* [ %node.0, %for.inc ], [ %node.01, %if.end ]
  %task = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.04, i64 0, i32 1
  %4 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 85
  %5 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %6 = load i64, i64* %1, align 8
  %call7 = call fastcc i32 @io_async_cancel_one(%struct.io_uring_task* noundef %5, i64 noundef %6, %struct.io_ring_ctx* noundef %0) #25
  %cmp8.not = icmp eq i32 %call7, -2
  br i1 %cmp8.not, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.body
  %7 = bitcast %struct.io_tctx_node* %node.04 to %struct.io_tctx_node**
  %node.0 = load %struct.io_tctx_node*, %struct.io_tctx_node** %7, align 8
  %ctx_node = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.0, i64 0, i32 0
  %cmp3.not = icmp eq %struct.list_head* %ctx_node, %tctx_list
  br i1 %cmp3.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %for.body, %if.end
  %ret.1 = phi i32 [ -2, %if.end ], [ %call7, %for.body ], [ -2, %for.inc ]
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  br label %done

done:                                             ; preds = %entry, %for.end
  %ret.2 = phi i32 [ %call, %entry ], [ %ret.1, %for.end ]
  %cmp22 = icmp slt i32 %ret.2, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %done
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %done
  %conv = sext i32 %ret.2 to i64
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %conv, i32 noundef 0) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_fallocate(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %sync = bitcast %struct.io_kiocb* %req to %struct.io_sync*
  %mode = getelementptr inbounds %struct.io_sync, %struct.io_sync* %sync, i64 0, i32 4
  %1 = load i32, i32* %mode, align 4
  %off = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %2 = bitcast void (%struct.kiocb*, i64, i64)** %off to i64*
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call i32 @vfs_fallocate(%struct.file* noundef %0, i32 noundef %1, i64 noundef %3, i64 noundef %5) #27
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_openat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %call = call fastcc i32 @io_openat2(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_close(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %file = alloca %struct.file*, align 8
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %files1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 84
  %2 = load %struct.files_struct*, %struct.files_struct** %files1, align 16
  %close2 = bitcast %struct.io_kiocb* %req to %struct.io_close*
  %3 = bitcast %struct.file** %file to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #26
  store %struct.file* null, %struct.file** %file, align 8
  %file_slot = getelementptr inbounds %struct.io_close, %struct.io_close* %close2, i64 0, i32 2
  %4 = load i32, i32* %file_slot, align 4
  %tobool.not = icmp eq i32 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call fastcc i32 @io_close_fixed(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) #25
  br label %err

if.end:                                           ; preds = %entry
  %rlock.i = getelementptr inbounds %struct.files_struct, %struct.files_struct* %2, i64 0, i32 6, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %fdt5 = getelementptr inbounds %struct.files_struct, %struct.files_struct* %2, i64 0, i32 3
  %5 = load volatile %struct.fdtable*, %struct.fdtable** %fdt5, align 32
  %fd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %6 = bitcast i64* %fd to i32*
  %7 = load i32, i32* %6, align 8
  %max_fds = getelementptr inbounds %struct.fdtable, %struct.fdtable* %5, i64 0, i32 0
  %8 = load i32, i32* %max_fds, align 8
  %cmp.not = icmp ult i32 %7, %8
  br i1 %cmp.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.then39

if.end12:                                         ; preds = %if.end
  %fd13 = getelementptr inbounds %struct.fdtable, %struct.fdtable* %5, i64 0, i32 1
  %9 = load %struct.file**, %struct.file*** %fd13, align 8
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.file*, %struct.file** %9, i64 %idxprom
  %10 = load %struct.file*, %struct.file** %arrayidx, align 8
  store %struct.file* %10, %struct.file** %file, align 8
  %tobool15.not = icmp eq %struct.file* %10, null
  br i1 %tobool15.not, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %f_op = getelementptr inbounds %struct.file, %struct.file* %10, i64 0, i32 3
  %11 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp16 = icmp eq %struct.file_operations* %11, @io_uring_fops
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %lor.lhs.false, %if.end12
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  store %struct.file* null, %struct.file** %file, align 8
  br label %if.then39

if.end19:                                         ; preds = %lor.lhs.false
  %flush = getelementptr inbounds %struct.file_operations, %struct.file_operations* %11, i64 0, i32 15
  %12 = load i32 (%struct.file*, i8*)*, i32 (%struct.file*, i8*)** %flush, align 8
  %tobool21.not = icmp eq i32 (%struct.file*, i8*)* %12, null
  %and = and i32 %issue_flags, 1
  %tobool22.not = icmp eq i32 %and, 0
  %or.cond = or i1 %tobool22.not, %tobool21.not
  br i1 %or.cond, label %if.end25, label %if.then23

if.then23:                                        ; preds = %if.end19
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup

if.end25:                                         ; preds = %if.end19
  %call27 = call i32 @__close_fd_get_file(i32 noundef %7, %struct.file** noundef nonnull %file) #27
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %cmp29 = icmp slt i32 %call27, 0
  br i1 %cmp29, label %if.then30, label %if.end34

if.then30:                                        ; preds = %if.end25
  %cmp31 = icmp eq i32 %call27, -2
  %spec.store.select = select i1 %cmp31, i32 -9, i32 %call27
  br label %if.then39

if.end34:                                         ; preds = %if.end25
  %13 = load %struct.file*, %struct.file** %file, align 8
  %14 = bitcast %struct.files_struct** %files1 to i8**
  %15 = load i8*, i8** %14, align 16
  %call37 = call i32 @filp_close(%struct.file* noundef %13, i8* noundef %15) #27
  br label %err

err:                                              ; preds = %if.end34, %if.then
  %ret.0 = phi i32 [ %call4, %if.then ], [ %call37, %if.end34 ]
  %cmp38 = icmp slt i32 %ret.0, 0
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.then30, %if.then17, %if.then10, %err
  %ret.080 = phi i32 [ %ret.0, %err ], [ %spec.store.select, %if.then30 ], [ -9, %if.then17 ], [ -9, %if.then10 ]
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %err
  %ret.079 = phi i32 [ %ret.080, %if.then39 ], [ %ret.0, %err ]
  %16 = load %struct.file*, %struct.file** %file, align 8
  %tobool41.not = icmp eq %struct.file* %16, null
  br i1 %tobool41.not, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.end40
  call void @fput(%struct.file* noundef nonnull %16) #27
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end40
  %conv = sext i32 %ret.079 to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv, i32 noundef 0) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end43, %if.then23
  %retval.0 = phi i32 [ 0, %if.end43 ], [ -11, %if.then23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_files_update(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %up = alloca %struct.io_uring_rsrc_update2, align 8
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %1 = bitcast %struct.io_uring_rsrc_update2* %up to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %1) #26
  %2 = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 4
  %3 = bitcast i32* %2 to i64*, !annotation !14
  store i64 0, i64* %3, align 8, !annotation !14
  %rsrc_update = bitcast %struct.io_kiocb* %req to %struct.io_rsrc_update*
  %offset = getelementptr inbounds %struct.io_rsrc_update, %struct.io_rsrc_update* %rsrc_update, i64 0, i32 3
  %4 = load i32, i32* %offset, align 4
  %offset2 = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 0
  store i32 %4, i32* %offset2, align 8
  %5 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %data = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 2
  store i64 %6, i64* %data, align 8
  %tags = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 3
  store i64 0, i64* %tags, align 8
  %resv = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 1
  store i32 0, i32* %resv, align 4
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %nr_args = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %7 = bitcast void (%struct.kiocb*, i64, i64)** %nr_args to i32*
  %8 = load i32, i32* %7, align 8
  %call = call fastcc i32 @__io_register_rsrc_update(%struct.io_ring_ctx* noundef %0, i32 noundef 0, %struct.io_uring_rsrc_update2* noundef nonnull %up, i32 noundef %8) #25
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv = sext i32 %call to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv, i32 noundef 0) #25
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %1) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_statx(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %statx = bitcast %struct.io_kiocb* %req to %struct.io_statx*
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %dfd to i32*
  %1 = load i32, i32* %0, align 8
  %2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %3 = load i8*, i8** %2, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %4 = bitcast void (%struct.kiocb*, i64, i64)** %flags to i32*
  %5 = load i32, i32* %4, align 8
  %mask = getelementptr inbounds %struct.io_statx, %struct.io_statx* %statx, i64 0, i32 2
  %6 = load i32, i32* %mask, align 4
  %buffer = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %7 = bitcast i32* %buffer to %struct.statx**
  %8 = load %struct.statx*, %struct.statx** %7, align 8
  %call = call i32 @do_statx(i32 noundef %1, i8* noundef %3, i32 noundef %5, i32 noundef %6, %struct.statx* noundef %8) #27
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end2
  %retval.0 = phi i32 [ 0, %if.end2 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_fadvise(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %fadvise = bitcast %struct.io_kiocb* %req to %struct.io_fadvise*
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  %advice1.phi.trans.insert = getelementptr inbounds %struct.io_fadvise, %struct.io_fadvise* %fadvise, i64 0, i32 3
  %.pre = load i32, i32* %advice1.phi.trans.insert, align 4
  %switch = icmp ult i32 %.pre, 3
  %or.cond = select i1 %tobool.not, i1 true, i1 %switch
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %2 = load i64, i64* %1, align 8
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %3 = bitcast void (%struct.kiocb*, i64, i64)** %len to i32*
  %4 = load i32, i32* %3, align 8
  %conv = zext i32 %4 to i64
  %call = call i32 @vfs_fadvise(%struct.file* noundef %0, i64 noundef %2, i64 noundef %conv, i32 noundef %.pre) #27
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv5 = sext i32 %call to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv5, i32 noundef 0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_madvise(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %madvise = bitcast %struct.io_kiocb* %req to %struct.io_madvise*
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %mm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 35
  %2 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  %3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %5 = bitcast void (%struct.kiocb*, i64, i64)** %len to i32*
  %6 = load i32, i32* %5, align 8
  %conv = zext i32 %6 to i64
  %advice = getelementptr inbounds %struct.io_madvise, %struct.io_madvise* %madvise, i64 0, i32 3
  %7 = load i32, i32* %advice, align 4
  %call1 = call i32 @do_madvise(%struct.mm_struct* noundef %2, i64 noundef %4, i64 noundef %conv, i32 noundef %7) #27
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv5 = sext i32 %call1 to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv5) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_openat2(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %op = alloca %struct.open_flags, align 4
  %0 = bitcast %struct.open_flags* %op to i8*
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(20) %0, i8 0, i64 20, i1 false), !annotation !14
  %open = bitcast %struct.io_kiocb* %req to %struct.io_open*
  %file_slot = getelementptr inbounds %struct.io_open, %struct.io_open* %open, i64 0, i32 2
  %1 = load i32, i32* %file_slot, align 4
  %tobool.not = icmp eq i32 %1, 0
  %how = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %2 = bitcast i8** %how to %struct.open_how*
  %call = call i32 @build_open_flags(%struct.open_how* noundef %2, %struct.open_flags* noundef nonnull %op) #27
  %tobool3.not = icmp eq i32 %call, 0
  br i1 %tobool3.not, label %if.end, label %err

if.end:                                           ; preds = %entry
  %open_flag = getelementptr inbounds %struct.open_flags, %struct.open_flags* %op, i64 0, i32 0
  %3 = load i32, i32* %open_flag, align 4
  %and = and i32 %3, 2048
  %tobool4.not = icmp ne i32 %and, 0
  %resolve = getelementptr inbounds i8*, i8** %how, i64 2
  %4 = bitcast i8** %resolve to i64*
  %5 = load i64, i64* %4, align 8
  %and8 = and i64 %5, 32
  %tobool9.not = icmp ne i64 %and8, 0
  %and11 = and i32 %issue_flags, 1
  %tobool12.not = icmp eq i32 %and11, 0
  br i1 %tobool12.not, label %if.end22, label %if.then13

if.then13:                                        ; preds = %if.end
  %flags = bitcast i8** %how to i64*
  %6 = load i64, i64* %flags, align 8
  %and16 = and i64 %6, 4211264
  %tobool17.not = icmp eq i64 %and16, 0
  br i1 %tobool17.not, label %if.end19, label %cleanup

if.end19:                                         ; preds = %if.then13
  %lookup_flags = getelementptr inbounds %struct.open_flags, %struct.open_flags* %op, i64 0, i32 4
  %7 = load i32, i32* %lookup_flags, align 4
  %or = or i32 %7, 2097152
  store i32 %or, i32* %lookup_flags, align 4
  %or21 = or i32 %3, 2048
  store i32 %or21, i32* %open_flag, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.end19, %if.end
  br i1 %tobool.not, label %if.then24, label %if.end33

if.then24:                                        ; preds = %if.end22
  %flags27 = bitcast i8** %how to i64*
  %8 = load i64, i64* %flags27, align 8
  %conv = trunc i64 %8 to i32
  %9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call29 = call i32 @__get_unused_fd_flags(i32 noundef %conv, i64 noundef %10) #27
  %cmp = icmp slt i32 %call29, 0
  br i1 %cmp, label %err, label %if.end33

if.end33:                                         ; preds = %if.then24, %if.end22
  %ret.0 = phi i32 [ 0, %if.end22 ], [ %call29, %if.then24 ]
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %11 = bitcast i64* %dfd to i32*
  %12 = load i32, i32* %11, align 8
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  %14 = load %struct.filename*, %struct.filename** %13, align 8
  %call36 = call %struct.file* @do_filp_open(i32 noundef %12, %struct.filename* noundef %14, %struct.open_flags* noundef nonnull %op) #27
  %15 = bitcast %struct.file* %call36 to i8*
  %call37 = call fastcc i1 @IS_ERR(i8* noundef %15) #25
  br i1 %call37, label %if.then38, label %if.end52

if.then38:                                        ; preds = %if.end33
  br i1 %tobool.not, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.then38
  call void @put_unused_fd(i32 noundef %ret.0) #27
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %if.then38
  %call42 = call fastcc i64 @PTR_ERR(i8* noundef %15) #25
  %conv43 = trunc i64 %call42 to i32
  %cmp44 = icmp ne i32 %conv43, -11
  %brmerge = select i1 %cmp44, i1 true, i1 %tobool9.not
  %brmerge112 = or i1 %tobool12.not, %brmerge
  %conv43.mux.mux = select i1 %brmerge, i32 %conv43, i32 -11
  br i1 %brmerge112, label %err, label %cleanup

if.end52:                                         ; preds = %if.end33
  %brmerge113 = select i1 %tobool12.not, i1 true, i1 %tobool4.not
  br i1 %brmerge113, label %if.end59, label %if.then57

if.then57:                                        ; preds = %if.end52
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %call36, i64 0, i32 7
  %16 = load i32, i32* %f_flags, align 8
  %and58 = and i32 %16, -2049
  store i32 %and58, i32* %f_flags, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.end52, %if.then57
  call fastcc void @fsnotify_open(%struct.file* noundef %call36) #25
  br i1 %tobool.not, label %if.then61, label %if.else

if.then61:                                        ; preds = %if.end59
  call void @fd_install(i32 noundef %ret.0, %struct.file* noundef %call36) #27
  br label %err

if.else:                                          ; preds = %if.end59
  %17 = load i32, i32* %file_slot, align 4
  %sub = add i32 %17, -1
  %call64 = call fastcc i32 @io_install_fixed_file(%struct.io_kiocb* noundef %req, %struct.file* noundef %call36, i32 noundef %issue_flags, i32 noundef %sub) #25
  br label %err

err:                                              ; preds = %if.end41, %if.then61, %if.else, %if.then24, %entry
  %ret.1 = phi i32 [ %call, %entry ], [ %conv43.mux.mux, %if.end41 ], [ %call64, %if.else ], [ %ret.0, %if.then61 ], [ %call29, %if.then24 ]
  %filename67 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %18 = bitcast void (%struct.kiocb*, i64, i64)** %filename67 to %struct.filename**
  %19 = load %struct.filename*, %struct.filename** %18, align 8
  call void @putname(%struct.filename* noundef %19) #27
  %flags68 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %20 = load i32, i32* %flags68, align 8
  %and69 = and i32 %20, -8193
  store i32 %and69, i32* %flags68, align 8
  %cmp70 = icmp slt i32 %ret.1, 0
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %err
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %err
  %conv74 = sext i32 %ret.1 to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv74, i32 noundef 0) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end41, %if.then13, %if.end73
  %retval.0 = phi i32 [ 0, %if.end73 ], [ -11, %if.then13 ], [ -11, %if.end41 ]
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_epoll_ctl(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %epoll = bitcast %struct.io_kiocb* %req to %struct.io_epoll*
  %and = and i32 %issue_flags, 1
  %tobool = icmp ne i32 %and, 0
  %epfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %epfd to i32*
  %1 = load i32, i32* %0, align 8
  %op = getelementptr inbounds %struct.io_epoll, %struct.io_epoll* %epoll, i64 0, i32 2
  %2 = load i32, i32* %op, align 4
  %fd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %3 = bitcast void (%struct.kiocb*, i64, i64)** %fd to i32*
  %4 = load i32, i32* %3, align 8
  %event = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %event to %struct.epoll_event*
  %call = call i32 @do_epoll_ctl(i32 noundef %1, i32 noundef %2, i32 noundef %4, %struct.epoll_event* noundef %5, i1 noundef %tobool) #27
  %cmp = icmp eq i32 %call, -11
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp slt i32 %call, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv, i32 noundef 0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end5
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_splice(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %file_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %file_in to %struct.file**
  %1 = load %struct.file*, %struct.file** %0, align 8
  %file_out = getelementptr %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %2 = load %struct.file*, %struct.file** %file_out, align 8
  %flags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %3 = bitcast %union.anon.40* %flags1 to i32*
  %4 = load i32, i32* %3, align 8
  %and = and i32 %4, 2147483647
  %and2 = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and2, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %off_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %off_in to i64*
  %off_out = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %6 = bitcast void (%struct.kiocb*, i64, i64)** %off_out to i64*
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %7 = bitcast i32* %len to i64*
  %8 = load i64, i64* %7, align 8
  %tobool10.not = icmp eq i64 %8, 0
  br i1 %tobool10.not, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end
  %9 = load i64, i64* %6, align 8
  %cmp4 = icmp eq i64 %9, -1
  %cond9 = select i1 %cmp4, i64* null, i64* %6
  %10 = load i64, i64* %5, align 8
  %cmp = icmp eq i64 %10, -1
  %cond = select i1 %cmp, i64* null, i64* %5
  %call = call i64 @do_splice(%struct.file* noundef %1, i64* noundef %cond, %struct.file* noundef %2, i64* noundef %cond9, i64 noundef %8, i32 noundef %and) #27
  %.pre = load i32, i32* %3, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end
  %11 = phi i32 [ %.pre, %if.then11 ], [ %4, %if.end ]
  %ret.0 = phi i64 [ %call, %if.then11 ], [ 0, %if.end ]
  %tobool16.not = icmp sgt i32 %11, -1
  br i1 %tobool16.not, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end13
  call fastcc void @io_put_file(%struct.file* noundef %1) #25
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end13
  %flags19 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %12 = load i32, i32* %flags19, align 8
  %and20 = and i32 %12, -8193
  store i32 %and20, i32* %flags19, align 8
  %13 = load i64, i64* %7, align 8
  %cmp22.not = icmp eq i64 %ret.0, %13
  br i1 %cmp22.not, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end18
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end18
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %ret.0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end24
  %retval.0 = phi i32 [ 0, %if.end24 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_provide_buffers(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %head = alloca %struct.io_buffer*, align 8
  %pbuf = bitcast %struct.io_kiocb* %req to %struct.io_provide_buf*
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %1 = bitcast %struct.io_buffer** %head to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %1) #26
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %io_buffers = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 15
  %bgid = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 3
  %2 = load i32, i32* %bgid, align 4
  %conv = zext i32 %2 to i64
  %call = call i8* @xa_load(%struct.xarray* noundef %io_buffers, i64 noundef %conv) #27
  %3 = bitcast %struct.io_buffer** %head to i8**
  store i8* %call, i8** %3, align 8
  %call3 = call fastcc i32 @io_add_buffers(%struct.io_provide_buf* noundef %pbuf, %struct.io_buffer** noundef nonnull %head) #25
  %cmp = icmp slt i32 %call3, 0
  %tobool5 = icmp ne i8* %call, null
  %or.cond = select i1 %cmp, i1 true, i1 %tobool5
  br i1 %or.cond, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %bgid, align 4
  %conv8 = zext i32 %4 to i64
  %5 = load i8*, i8** %3, align 8
  %call9 = call fastcc i32 @xa_insert(%struct.xarray* noundef %io_buffers, i64 noundef %conv8, i8* noundef %5) #25
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %if.end15.thread, label %if.end19

if.end15.thread:                                  ; preds = %if.then
  %6 = bitcast i8* %5 to %struct.io_buffer*
  %7 = load i32, i32* %bgid, align 4
  %call14 = call fastcc i32 @__io_remove_buffers(%struct.io_ring_ctx* noundef %0, %struct.io_buffer* noundef %6, i32 noundef %7, i32 noundef -1) #25
  br label %if.then18

if.end15:                                         ; preds = %entry
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15.thread, %if.end15
  %ret.04 = phi i32 [ %call9, %if.end15.thread ], [ %call3, %if.end15 ]
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end19

if.end19:                                         ; preds = %if.then, %if.then18, %if.end15
  %ret.03 = phi i32 [ %ret.04, %if.then18 ], [ %call3, %if.end15 ], [ %call9, %if.then ]
  %conv20 = sext i32 %ret.03 to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv20, i32 noundef 0) #25
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %1) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_remove_buffers(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %pbuf = bitcast %struct.io_kiocb* %req to %struct.io_provide_buf*
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %io_buffers = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 15
  %bgid = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 3
  %1 = load i32, i32* %bgid, align 4
  %conv = zext i32 %1 to i64
  %call = call i8* @xa_load(%struct.xarray* noundef %io_buffers, i64 noundef %conv) #27
  %tobool3.not = icmp eq i8* %call, null
  br i1 %tobool3.not, label %if.then8, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %call to %struct.io_buffer*
  %3 = load i32, i32* %bgid, align 4
  %nbufs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %4 = bitcast i8** %nbufs to i16*
  %5 = load i16, i16* %4, align 8
  %conv5 = zext i16 %5 to i32
  %call6 = call fastcc i32 @__io_remove_buffers(%struct.io_ring_ctx* noundef %0, %struct.io_buffer* noundef nonnull %2, i32 noundef %3, i32 noundef %conv5) #25
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %entry, %if.end
  %ret.04 = phi i32 [ %call6, %if.end ], [ -2, %entry ]
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end
  %ret.03 = phi i32 [ %ret.04, %if.then8 ], [ %call6, %if.end ]
  %conv10 = sext i32 %ret.03 to i64
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv10, i32 noundef 0) #25
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_tee(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %file_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %file_in to %struct.file**
  %1 = load %struct.file*, %struct.file** %0, align 8
  %file_out = getelementptr %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %2 = load %struct.file*, %struct.file** %file_out, align 8
  %flags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %3 = bitcast %union.anon.40* %flags1 to i32*
  %4 = load i32, i32* %3, align 8
  %and = and i32 %4, 2147483647
  %and2 = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and2, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %5 = bitcast i32* %len to i64*
  %6 = load i64, i64* %5, align 8
  %tobool3.not = icmp eq i64 %6, 0
  br i1 %tobool3.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %call = call i64 @do_tee(%struct.file* noundef %1, %struct.file* noundef %2, i64 noundef %6, i32 noundef %and) #27
  %.pre = load i32, i32* %3, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %7 = phi i32 [ %.pre, %if.then4 ], [ %4, %if.end ]
  %ret.0 = phi i64 [ %call, %if.then4 ], [ 0, %if.end ]
  %tobool9.not = icmp sgt i32 %7, -1
  br i1 %tobool9.not, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  call fastcc void @io_put_file(%struct.file* noundef %1) #25
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end6
  %flags12 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %8 = load i32, i32* %flags12, align 8
  %and13 = and i32 %8, -8193
  store i32 %and13, i32* %flags12, align 8
  %9 = load i64, i64* %5, align 8
  %cmp.not = icmp eq i64 %ret.0, %9
  br i1 %cmp.not, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end11
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end11
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %ret.0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end16
  %retval.0 = phi i32 [ 0, %if.end16 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_renameat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %rename = bitcast %struct.io_kiocb* %req to %struct.io_rename*
  %old_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %old_dfd to i32*
  %1 = load i32, i32* %0, align 8
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %2 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  %3 = load %struct.filename*, %struct.filename** %2, align 8
  %new_dfd = getelementptr inbounds %struct.io_rename, %struct.io_rename* %rename, i64 0, i32 2
  %4 = load i32, i32* %new_dfd, align 4
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %newpath to %struct.filename**
  %6 = load %struct.filename*, %struct.filename** %5, align 8
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %8 = load i32, i32* %7, align 8
  %call = call i32 @do_renameat2(i32 noundef %1, %struct.filename* noundef %3, i32 noundef %4, %struct.filename* noundef %6, i32 noundef %8) #27
  %flags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %9 = load i32, i32* %flags1, align 8
  %and2 = and i32 %9, -8193
  store i32 %and2, i32* %flags1, align 8
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_unlinkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %unlink = bitcast %struct.io_kiocb* %req to %struct.io_unlink*
  %flags = getelementptr inbounds %struct.io_unlink, %struct.io_unlink* %unlink, i64 0, i32 2
  %0 = load i32, i32* %flags, align 4
  %and1 = and i32 %0, 512
  %tobool2.not = icmp eq i32 %and1, 0
  %dfd4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %1 = bitcast i64* %dfd4 to i32*
  %2 = load i32, i32* %1, align 8
  %filename5 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %3 = bitcast void (%struct.kiocb*, i64, i64)** %filename5 to %struct.filename**
  %4 = load %struct.filename*, %struct.filename** %3, align 8
  br i1 %tobool2.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  %call = call i32 @do_rmdir(i32 noundef %2, %struct.filename* noundef %4) #27
  br label %if.end7

if.else:                                          ; preds = %if.end
  %call6 = call i32 @do_unlinkat(i32 noundef %2, %struct.filename* noundef %4) #27
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3
  %ret.0 = phi i32 [ %call, %if.then3 ], [ %call6, %if.else ]
  %flags8 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %5 = load i32, i32* %flags8, align 8
  %and9 = and i32 %5, -8193
  store i32 %and9, i32* %flags8, align 8
  %cmp = icmp slt i32 %ret.0, 0
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end7
  %conv = sext i32 %ret.0 to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end11
  %retval.0 = phi i32 [ 0, %if.end11 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_mkdirat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %mkdir = bitcast %struct.io_kiocb* %req to %struct.io_mkdir*
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %dfd to i32*
  %1 = load i32, i32* %0, align 8
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %2 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  %3 = load %struct.filename*, %struct.filename** %2, align 8
  %mode = getelementptr inbounds %struct.io_mkdir, %struct.io_mkdir* %mkdir, i64 0, i32 2
  %4 = load i16, i16* %mode, align 4
  %call = call i32 @do_mkdirat(i32 noundef %1, %struct.filename* noundef %3, i16 noundef %4) #27
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %5 = load i32, i32* %flags, align 8
  %and1 = and i32 %5, -8193
  store i32 %and1, i32* %flags, align 8
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end3
  %retval.0 = phi i32 [ 0, %if.end3 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_symlinkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %0 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  %1 = load %struct.filename*, %struct.filename** %0, align 8
  %new_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %2 = bitcast i64* %new_dfd to i32*
  %3 = load i32, i32* %2, align 8
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %4 = bitcast i8** %newpath to %struct.filename**
  %5 = load %struct.filename*, %struct.filename** %4, align 8
  %call = call i32 @do_symlinkat(%struct.filename* noundef %1, i32 noundef %3, %struct.filename* noundef %5) #27
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %6 = load i32, i32* %flags, align 8
  %and1 = and i32 %6, -8193
  store i32 %and1, i32* %flags, align 8
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end3
  %retval.0 = phi i32 [ 0, %if.end3 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_linkat(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %hardlink = bitcast %struct.io_kiocb* %req to %struct.io_hardlink*
  %old_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %old_dfd to i32*
  %1 = load i32, i32* %0, align 8
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %2 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  %3 = load %struct.filename*, %struct.filename** %2, align 8
  %new_dfd = getelementptr inbounds %struct.io_hardlink, %struct.io_hardlink* %hardlink, i64 0, i32 2
  %4 = load i32, i32* %new_dfd, align 4
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %newpath to %struct.filename**
  %6 = load %struct.filename*, %struct.filename** %5, align 8
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %8 = load i32, i32* %7, align 8
  %call = call i32 @do_linkat(i32 noundef %1, %struct.filename* noundef %3, i32 noundef %4, %struct.filename* noundef %6, i32 noundef %8) #27
  %flags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %9 = load i32, i32* %flags1, align 8
  %and2 = and i32 %9, -8193
  store i32 %and2, i32* %flags1, align 8
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %conv = sext i32 %call to i64
  call fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @revert_creds(%struct.cred* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_iopoll_req_issued(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %call = call fastcc i1 @io_wq_current_is_worker() #25
  br i1 %call, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 2
  %call4 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool5.not = icmp eq i32 %call4, 0
  %poll_multi_queue7 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 5
  br i1 %tobool5.not, label %if.else, label %do.end31.sink.split

if.else:                                          ; preds = %if.end
  %1 = load i8, i8* %poll_multi_queue7, align 4, !range !18
  %tobool8.not = icmp eq i8 %1, 0
  br i1 %tobool8.not, label %if.then9, label %do.end31

if.then9:                                         ; preds = %if.else
  %2 = bitcast %struct.list_head* %iopoll_list to i8**
  %3 = load i8*, i8** %2, align 8
  %add.ptr = getelementptr i8, i8* %3, i64 -128
  %file = bitcast i8* %add.ptr to %struct.file**
  %4 = load %struct.file*, %struct.file** %file, align 8
  %file11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %5 = load %struct.file*, %struct.file** %file11, align 8
  %cmp.not = icmp eq %struct.file* %4, %5
  br i1 %cmp.not, label %if.else15, label %do.end31.sink.split

if.else15:                                        ; preds = %if.then9
  %6 = getelementptr i8, i8* %3, i64 -88
  %ki_cookie = bitcast i8* %6 to i32*
  %7 = load i32, i32* %ki_cookie, align 8
  %call16 = call fastcc i32 @blk_qc_t_to_queue_num(i32 noundef %7) #25
  %8 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %ki_cookie19 = bitcast %union.anon.40* %8 to i32*
  %9 = load i32, i32* %ki_cookie19, align 8
  %call20 = call fastcc i32 @blk_qc_t_to_queue_num(i32 noundef %9) #25
  %cmp21.not = icmp eq i32 %call16, %call20
  br i1 %cmp21.not, label %do.end31, label %do.end31.sink.split

do.end31.sink.split:                              ; preds = %if.else15, %if.then9, %if.end
  %.sink = phi i8 [ 0, %if.end ], [ 1, %if.then9 ], [ 1, %if.else15 ]
  store i8 %.sink, i8* %poll_multi_queue7, align 4
  br label %do.end31

do.end31:                                         ; preds = %do.end31.sink.split, %if.else15, %if.else
  %iopoll_completed = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 3
  %10 = load volatile i8, i8* %iopoll_completed, align 1
  %tobool33.not = icmp eq i8 %10, 0
  %inflight_entry37 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 13
  br i1 %tobool33.not, label %if.else36, label %if.then34

if.then34:                                        ; preds = %do.end31
  call fastcc void @list_add(%struct.list_head* noundef %inflight_entry37, %struct.list_head* noundef %iopoll_list) #25
  br label %if.end39

if.else36:                                        ; preds = %do.end31
  call fastcc void @list_add_tail(%struct.list_head* noundef %inflight_entry37, %struct.list_head* noundef %iopoll_list) #25
  br label %if.end39

if.end39:                                         ; preds = %if.else36, %if.then34
  br i1 %call, label %if.then48, label %if.end57, !prof !24

if.then48:                                        ; preds = %if.end39
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %11 = load i32, i32* %flags, align 8
  %and = and i32 %11, 2
  %tobool49.not = icmp eq i32 %and, 0
  br i1 %tobool49.not, label %if.end55, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then48
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 5
  %12 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %wait = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %12, i64 0, i32 5
  %call50 = call fastcc i1 @wq_has_sleeper(%struct.wait_queue_head* noundef %wait) #25
  br i1 %call50, label %if.then52, label %if.end55

if.then52:                                        ; preds = %land.lhs.true
  %13 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %wait54 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %13, i64 0, i32 5
  call void @__wake_up(%struct.wait_queue_head* noundef %wait54, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %land.lhs.true, %if.then48
  %uring_lock56 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock56) #27
  br label %if.end57

if.end57:                                         ; preds = %if.end55, %if.end39
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %and = and i32 %issue_flags, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_req_complete_state(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef %cflags) #25
  br label %if.end

if.else:                                          ; preds = %entry
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef %cflags) #25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_complete_state(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @io_req_needs_clean(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @io_clean_op(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv = trunc i64 %res to i32
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %conv, i32* %result, align 4
  %cflags1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %cflags1 to i32*
  store i32 %cflags, i32* %0, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %or = or i32 %1, 65536
  store i32 %or, i32* %flags, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef %cflags) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  %1 = load i64, i64* %user_data, align 8
  %call = call fastcc i1 @__io_cqring_fill_event(%struct.io_ring_ctx* noundef %0, i64 noundef %1, i64 noundef %res, i32 noundef %cflags) #25
  %call2 = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) #25
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 12
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end14, label %if.then3

if.then3:                                         ; preds = %if.then
  %and5 = and i32 %2, 1052928
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then3
  %call8 = call fastcc i1 @io_disarm_next(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then3
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %tobool9.not = icmp eq %struct.io_kiocb* %3, null
  br i1 %tobool9.not, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end
  call fastcc void @io_req_task_queue(%struct.io_kiocb* noundef nonnull %3) #25
  store %struct.io_kiocb* null, %struct.io_kiocb** %link, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then10, %if.then
  call fastcc void @io_dismantle_req(%struct.io_kiocb* noundef %req) #25
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %4 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  call fastcc void @io_put_task(%struct.task_struct* noundef %4, i32 noundef 1) #25
  %inflight_entry = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 13
  %locked_free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 2
  call fastcc void @list_add(%struct.list_head* noundef %inflight_entry, %struct.list_head* noundef %locked_free_list) #25
  %locked_free_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 3
  %5 = load i32, i32* %locked_free_nr, align 16
  %inc = add i32 %5, 1
  store i32 %inc, i32* %locked_free_nr, align 16
  br label %if.end18

if.else:                                          ; preds = %entry
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 0
  %call15 = call fastcc i1 @percpu_ref_tryget(%struct.percpu_ref* noundef %refs) #25
  %spec.select = select i1 %call15, %struct.io_kiocb* %req, %struct.io_kiocb* null
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.end14
  %req.addr.0 = phi %struct.io_kiocb* [ %req, %if.end14 ], [ %spec.select, %if.else ]
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %0) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  %tobool20.not = icmp eq %struct.io_kiocb* %req.addr.0, null
  br i1 %tobool20.not, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end18
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %0) #25
  %refs22 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs22) #25
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end18
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @io_req_needs_clean(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #3 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 320000
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_clean_op(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 32768
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %1 = load i8, i8* %opcode, align 8
  switch i8 %1, label %if.end [
    i8 1, label %sw.bb
    i8 4, label %sw.bb
    i8 22, label %sw.bb
    i8 10, label %sw.bb1
    i8 27, label %sw.bb1
  ]

sw.bb:                                            ; preds = %if.then, %if.then, %if.then
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %2 = load i64, i64* %addr, align 8
  %3 = inttoptr i64 %2 to i8*
  br label %if.end.sink.split

sw.bb1:                                           ; preds = %if.then, %if.then
  %kbuf = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %4 = bitcast i32* %kbuf to i8**
  %5 = load i8*, i8** %4, align 8
  br label %if.end.sink.split

if.end.sink.split:                                ; preds = %sw.bb1, %sw.bb
  %.sink = phi i8* [ %3, %sw.bb ], [ %5, %sw.bb1 ]
  call void @kfree(i8* noundef %.sink) #27
  br label %if.end

if.end:                                           ; preds = %if.end.sink.split, %if.then, %entry
  %6 = load i32, i32* %flags, align 8
  %and3 = and i32 %6, 8192
  %tobool4.not = icmp eq i32 %and3, 0
  br i1 %tobool4.not, label %if.end40, label %if.then5

if.then5:                                         ; preds = %if.end
  %opcode6 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %7 = load i8, i8* %opcode6, align 8
  switch i8 %7, label %if.end40 [
    i8 1, label %sw.bb8
    i8 4, label %sw.bb8
    i8 22, label %sw.bb8
    i8 2, label %sw.bb8
    i8 5, label %sw.bb8
    i8 23, label %sw.bb8
    i8 10, label %sw.bb9
    i8 9, label %sw.bb9
    i8 30, label %sw.bb12
    i8 33, label %sw.bb12
    i8 18, label %sw.bb19
    i8 28, label %sw.bb19
    i8 35, label %sw.bb25
    i8 36, label %sw.bb27
    i8 37, label %sw.bb29
    i8 38, label %sw.bb31
    i8 39, label %sw.bb35
  ]

sw.bb8:                                           ; preds = %if.then5, %if.then5, %if.then5, %if.then5, %if.then5, %if.then5
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %8 = bitcast i8** %async_data to %struct.io_async_rw**
  %9 = load %struct.io_async_rw*, %struct.io_async_rw** %8, align 8
  %free_iovec = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %9, i64 0, i32 1
  %10 = bitcast %struct.iovec** %free_iovec to i8**
  %11 = load i8*, i8** %10, align 8
  call void @kfree(i8* noundef %11) #27
  br label %if.end40

sw.bb9:                                           ; preds = %if.then5, %if.then5
  %async_data11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %12 = bitcast i8** %async_data11 to %struct.io_async_msghdr**
  %13 = load %struct.io_async_msghdr*, %struct.io_async_msghdr** %12, align 8
  %free_iov = getelementptr inbounds %struct.io_async_msghdr, %struct.io_async_msghdr* %13, i64 0, i32 1
  %14 = bitcast %struct.iovec** %free_iov to i8**
  %15 = load i8*, i8** %14, align 8
  call void @kfree(i8* noundef %15) #27
  br label %if.end40

sw.bb12:                                          ; preds = %if.then5, %if.then5
  %flags13 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %16 = bitcast %union.anon.40* %flags13 to i32*
  %17 = load i32, i32* %16, align 8
  %tobool15.not = icmp sgt i32 %17, -1
  br i1 %tobool15.not, label %if.then16, label %if.end40

if.then16:                                        ; preds = %sw.bb12
  %file_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %18 = bitcast i64* %file_in to %struct.file**
  %19 = load %struct.file*, %struct.file** %18, align 8
  call fastcc void @io_put_file(%struct.file* noundef %19) #25
  br label %if.end40

sw.bb19:                                          ; preds = %if.then5, %if.then5
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %20 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  %21 = load %struct.filename*, %struct.filename** %20, align 8
  %tobool20.not = icmp eq %struct.filename* %21, null
  br i1 %tobool20.not, label %if.end40, label %if.then21

if.then21:                                        ; preds = %sw.bb19
  call void @putname(%struct.filename* noundef nonnull %21) #27
  br label %if.end40

sw.bb25:                                          ; preds = %if.then5
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %22 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  %23 = load %struct.filename*, %struct.filename** %22, align 8
  call void @putname(%struct.filename* noundef %23) #27
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %24 = bitcast i8** %newpath to %struct.filename**
  %25 = load %struct.filename*, %struct.filename** %24, align 8
  call void @putname(%struct.filename* noundef %25) #27
  br label %if.end40

sw.bb27:                                          ; preds = %if.then5
  %filename28 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %26 = bitcast void (%struct.kiocb*, i64, i64)** %filename28 to %struct.filename**
  %27 = load %struct.filename*, %struct.filename** %26, align 8
  call void @putname(%struct.filename* noundef %27) #27
  br label %if.end40

sw.bb29:                                          ; preds = %if.then5
  %filename30 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %28 = bitcast void (%struct.kiocb*, i64, i64)** %filename30 to %struct.filename**
  %29 = load %struct.filename*, %struct.filename** %28, align 8
  call void @putname(%struct.filename* noundef %29) #27
  br label %if.end40

sw.bb31:                                          ; preds = %if.then5
  %oldpath32 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %30 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath32 to %struct.filename**
  %31 = load %struct.filename*, %struct.filename** %30, align 8
  call void @putname(%struct.filename* noundef %31) #27
  %newpath34 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %32 = bitcast i8** %newpath34 to %struct.filename**
  %33 = load %struct.filename*, %struct.filename** %32, align 8
  call void @putname(%struct.filename* noundef %33) #27
  br label %if.end40

sw.bb35:                                          ; preds = %if.then5
  %oldpath36 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %34 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath36 to %struct.filename**
  %35 = load %struct.filename*, %struct.filename** %34, align 8
  call void @putname(%struct.filename* noundef %35) #27
  %newpath38 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %36 = bitcast i8** %newpath38 to %struct.filename**
  %37 = load %struct.filename*, %struct.filename** %36, align 8
  call void @putname(%struct.filename* noundef %37) #27
  br label %if.end40

if.end40:                                         ; preds = %sw.bb8, %sw.bb9, %sw.bb25, %sw.bb27, %sw.bb29, %sw.bb31, %sw.bb35, %if.then5, %if.then16, %sw.bb12, %if.then21, %sw.bb19, %if.end
  %38 = load i32, i32* %flags, align 8
  %and42 = and i32 %38, 16384
  %tobool43.not = icmp eq i32 %and42, 0
  br i1 %tobool43.not, label %if.end49, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end40
  %apoll = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 16
  %39 = load %struct.async_poll*, %struct.async_poll** %apoll, align 8
  %tobool44.not = icmp eq %struct.async_poll* %39, null
  br i1 %tobool44.not, label %if.end49, label %if.then45

if.then45:                                        ; preds = %land.lhs.true
  %double_poll = getelementptr inbounds %struct.async_poll, %struct.async_poll* %39, i64 0, i32 1
  %40 = bitcast %struct.io_poll_iocb** %double_poll to i8**
  %41 = load i8*, i8** %40, align 8
  call void @kfree(i8* noundef %41) #27
  %42 = bitcast %struct.async_poll** %apoll to i8**
  %43 = load i8*, i8** %42, align 8
  call void @kfree(i8* noundef %43) #27
  store %struct.async_poll* null, %struct.async_poll** %apoll, align 8
  %.pre = load i32, i32* %flags, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.then45, %land.lhs.true, %if.end40
  %44 = phi i32 [ %.pre, %if.then45 ], [ %38, %land.lhs.true ], [ %38, %if.end40 ]
  %and51 = and i32 %44, 512
  %tobool52.not = icmp eq i32 %and51, 0
  br i1 %tobool52.not, label %if.end54, label %if.then53

if.then53:                                        ; preds = %if.end49
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %45 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %45, i64 0, i32 85
  %46 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %inflight_tracked = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %46, i64 0, i32 6
  call fastcc void @__ll_sc_atomic_sub(%struct.atomic_t* noundef %inflight_tracked) #27
  %.pre95 = load i32, i32* %flags, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end49
  %47 = phi i32 [ %.pre95, %if.then53 ], [ %44, %if.end49 ]
  %and56 = and i32 %47, 262144
  %tobool57.not = icmp eq i32 %and56, 0
  br i1 %tobool57.not, label %if.end59, label %if.then58

if.then58:                                        ; preds = %if.end54
  %creds = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 18
  %48 = load %struct.cred*, %struct.cred** %creds, align 8
  call fastcc void @put_cred(%struct.cred* noundef %48) #25
  %.pre96 = load i32, i32* %flags, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.end54
  %49 = phi i32 [ %.pre96, %if.then58 ], [ %47, %if.end54 ]
  %and61 = and i32 %49, -320001
  store i32 %and61, i32* %flags, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_put_file(%struct.file* noundef %file) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.file* %file, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @fput(%struct.file* noundef nonnull %file) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @putname(%struct.filename* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @put_cred(%struct.cred* noundef %_cred) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.cred* %_cred, null
  br i1 %tobool.not, label %if.end2, label %if.then

if.then:                                          ; preds = %entry
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %_cred, i64 0, i32 0
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %usage) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.i.i, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.then
  call void @__put_cred(%struct.cred* noundef nonnull %_cred) #27
  br label %if.end2

if.end2:                                          ; preds = %if.then, %if.then1, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @fput(%struct.file* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__put_cred(%struct.cred* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @percpu_ref_tryget(%struct.percpu_ref* noundef %ref) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @percpu_ref_tryget_many(%struct.percpu_ref* noundef %ref, i64 noundef 1) #25
  ret i1 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @percpu_ref_tryget_many(%struct.percpu_ref* noundef %ref, i64 noundef %nr) unnamed_addr #1 {
entry:
  %percpu_count = alloca i64*, align 8
  %0 = bitcast i64** %percpu_count to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64* null, i64** %percpu_count, align 8, !annotation !14
  call fastcc void @__rcu_read_lock() #27
  %call = call fastcc i1 @__ref_is_percpu(%struct.percpu_ref* noundef %ref, i64** noundef nonnull %percpu_count) #25
  br i1 %call, label %do.body1, label %if.else

do.body1:                                         ; preds = %entry
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !53
  %1 = load i64*, i64** %percpu_count, align 8
  %2 = ptrtoint i64* %1 to i64
  %call7 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add = add i64 %call7, %2
  %3 = inttoptr i64 %add to i8*
  call fastcc void @__percpu_add_case_64(i8* noundef %3, i64 noundef %nr) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !54
  br label %if.end

if.else:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 0, i32 1
  %4 = load %struct.percpu_ref_data*, %struct.percpu_ref_data** %data, align 8
  %counter.i.i.i.i = getelementptr inbounds %struct.percpu_ref_data, %struct.percpu_ref_data* %4, i64 0, i32 0, i32 0
  %5 = load volatile i64, i64* %counter.i.i.i.i, align 8
  %6 = bitcast %struct.percpu_ref_data* %4 to i8*
  br label %do.body.i.i.i.i

do.body.i.i.i.i:                                  ; preds = %do.cond.i.i.i.i, %if.else
  %c.0.i.i.i.i = phi i64 [ %5, %if.else ], [ %call14.i.i.i.i.i.i, %do.cond.i.i.i.i ]
  %cmp.i.i.i.i = icmp eq i64 %c.0.i.i.i.i, 0
  br i1 %cmp.i.i.i.i, label %atomic_long_add_unless.exit, label %do.cond.i.i.i.i, !prof !24

do.cond.i.i.i.i:                                  ; preds = %do.body.i.i.i.i
  %add.i.i.i.i = add i64 %c.0.i.i.i.i, %nr
  %call14.i.i.i.i.i.i = call fastcc i64 @__cmpxchg_case_mb_64(i8* noundef %6, i64 noundef %c.0.i.i.i.i, i64 noundef %add.i.i.i.i) #27
  %cmp.not.i.i.i.i.i = icmp eq i64 %call14.i.i.i.i.i.i, %c.0.i.i.i.i
  br i1 %cmp.not.i.i.i.i.i, label %atomic_long_add_unless.exit, label %do.body.i.i.i.i, !prof !8

atomic_long_add_unless.exit:                      ; preds = %do.body.i.i.i.i, %do.cond.i.i.i.i
  %7 = xor i1 %cmp.i.i.i.i, true
  br label %if.end

if.end:                                           ; preds = %atomic_long_add_unless.exit, %do.body1
  %ret.0.off0 = phi i1 [ true, %do.body1 ], [ %7, %atomic_long_add_unless.exit ]
  call fastcc void @rcu_read_unlock() #25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret i1 %ret.0.off0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__cmpxchg_case_mb_32(i8* noundef %ptr, i32 noundef %old, i32 noundef %new) unnamed_addr #1 {
entry:
  %conv = zext i32 %old to i64
  %call = call fastcc i32 @__ll_sc__cmpxchg_case_mb_32(i8* noundef %ptr, i64 noundef %conv, i32 noundef %new) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__cmpxchg_case_mb_64(i8* noundef %ptr, i64 noundef %old, i64 noundef %new) unnamed_addr #1 {
entry:
  %call = call fastcc i64 @__ll_sc__cmpxchg_case_mb_64(i8* noundef %ptr, i64 noundef %old, i64 noundef %new) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__ll_sc__cmpxchg_case_mb_32(i8* noundef %ptr, i64 noundef %old, i32 noundef %new) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i32*
  %1 = call { i64, i32 } asm sideeffect "\09prfm\09pstl1strm, $2\0A1:\09ldxr\09${1:w}, $2\0A\09eor\09${0:w}, ${1:w}, ${3:w}\0A\09cbnz\09${0:w}, 2f\0A\09stlxr\09${0:w}, ${4:w}, $2\0A\09cbnz\09${0:w}, 1b\0A\09dmb ish\0A2:", "=&r,=&r,=*Q,Kr,r,*Q,~{memory}"(i32* elementtype(i32) %0, i64 %old, i32 %new, i32* elementtype(i32) %0) #26, !srcloc !55
  %asmresult1 = extractvalue { i64, i32 } %1, 1
  ret i32 %asmresult1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__ll_sc__cmpxchg_case_mb_64(i8* noundef %ptr, i64 noundef %old, i64 noundef %new) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i64*
  %1 = call { i64, i64 } asm sideeffect "\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$1, $2\0A\09eor\09$0, $1, $3\0A\09cbnz\09$0, 2f\0A\09stlxr\09${0:w}, $4, $2\0A\09cbnz\09${0:w}, 1b\0A\09dmb ish\0A2:", "=&r,=&r,=*Q,Lr,r,*Q,~{memory}"(i64* elementtype(i64) %0, i64 %old, i64 %new, i64* elementtype(i64) %0) #26, !srcloc !56
  %asmresult1 = extractvalue { i64, i64 } %1, 1
  ret i64 %asmresult1
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @iov_iter_restore(%struct.iov_iter* noundef, %struct.iov_iter_state* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_import_iovec(i32 noundef %rw, %struct.io_kiocb* nocapture noundef %req, %struct.iovec** noundef %iovec, %struct.iov_iter* noundef %iter, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  %sqe_len = alloca i64, align 8
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %0 = load i64, i64* %addr, align 8
  %1 = inttoptr i64 %0 to i8*
  %2 = bitcast i64* %sqe_len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %2) #26
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 2
  %3 = load i64, i64* %len, align 8
  store i64 %3, i64* %sqe_len, align 8
  %opcode4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %4 = load i8, i8* %opcode4, align 8
  %5 = and i8 %4, -2
  %6 = icmp eq i8 %5, 4
  br i1 %6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  %call = call fastcc i32 @io_import_fixed(%struct.io_kiocb* noundef %req, i32 noundef %rw, %struct.iov_iter* noundef %iter) #25
  br label %cleanup

if.end:                                           ; preds = %entry
  %buf_index = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 4
  %7 = load i16, i16* %buf_index, align 2
  %tobool.not = icmp eq i16 %7, 0
  br i1 %tobool.not, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %8 = load i32, i32* %flags, align 8
  %and = and i32 %8, 32
  %tobool12.not = icmp eq i32 %and, 0
  br i1 %tobool12.not, label %cleanup, label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %if.end
  %9 = icmp eq i8 %5, 22
  %flags23 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %10 = load i32, i32* %flags23, align 8
  %and24 = and i32 %10, 32
  %tobool25.not = icmp eq i32 %and24, 0
  br i1 %9, label %if.then22, label %if.end40

if.then22:                                        ; preds = %if.end14
  br i1 %tobool25.not, label %if.end36, label %if.then26

if.then26:                                        ; preds = %if.then22
  %call28 = call fastcc i8* @io_rw_buffer_select(%struct.io_kiocb* noundef %req, i64* noundef nonnull %sqe_len, i1 noundef %needs_lock) #25
  %call29 = call fastcc i1 @IS_ERR(i8* noundef %call28) #25
  br i1 %call29, label %if.then30, label %if.end33

if.then30:                                        ; preds = %if.then26
  %call31 = call fastcc i64 @PTR_ERR(i8* noundef %call28) #25
  %conv32 = trunc i64 %call31 to i32
  br label %cleanup

if.end33:                                         ; preds = %if.then26
  %11 = load i64, i64* %sqe_len, align 8
  store i64 %11, i64* %len, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end33, %if.then22
  %12 = phi i64 [ %11, %if.end33 ], [ %3, %if.then22 ]
  %buf.0 = phi i8* [ %call28, %if.end33 ], [ %1, %if.then22 ]
  %13 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %call37 = call i32 @import_single_range(i32 noundef %rw, i8* noundef %buf.0, i64 noundef %12, %struct.iovec* noundef %13, %struct.iov_iter* noundef %iter) #27
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  br label %cleanup

if.end40:                                         ; preds = %if.end14
  br i1 %tobool25.not, label %if.end51, label %if.then44

if.then44:                                        ; preds = %if.end40
  %14 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %call46 = call fastcc i64 @io_iov_buffer_select(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %14, i1 noundef %needs_lock) #25
  %tobool47.not = icmp eq i64 %call46, 0
  br i1 %tobool47.not, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.then44
  %15 = load %struct.iovec*, %struct.iovec** %iovec, align 8
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %15, i64 0, i32 1
  %16 = load i64, i64* %iov_len, align 8
  call void @iov_iter_init(%struct.iov_iter* noundef %iter, i32 noundef %rw, %struct.iovec* noundef %15, i64 noundef 1, i64 noundef %16) #27
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %if.then44
  store %struct.iovec* null, %struct.iovec** %iovec, align 8
  %conv50 = trunc i64 %call46 to i32
  br label %cleanup

if.end51:                                         ; preds = %if.end40
  %17 = inttoptr i64 %0 to %struct.iovec*
  %conv52 = trunc i64 %3 to i32
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %18 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %compat = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %18, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %compat, align 4
  %bf.clear = and i8 %bf.load, 1
  %tobool53 = icmp ne i8 %bf.clear, 0
  %call54 = call i64 @__import_iovec(i32 noundef %rw, %struct.iovec* noundef %17, i32 noundef %conv52, i32 noundef 8, %struct.iovec** noundef %iovec, %struct.iov_iter* noundef %iter, i1 noundef %tobool53) #27
  %conv55 = trunc i64 %call54 to i32
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true, %if.end51, %if.end49, %if.end36, %if.then30, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %conv32, %if.then30 ], [ %call37, %if.end36 ], [ %conv50, %if.end49 ], [ %conv55, %if.end51 ], [ -22, %land.lhs.true ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %2) #26
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @iov_iter_save_state(%struct.iov_iter* nocapture noundef readonly %iter, %struct.iov_iter_state* nocapture noundef writeonly %state) unnamed_addr #12 {
entry:
  %iov_offset = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 2
  %0 = load i64, i64* %iov_offset, align 8
  %iov_offset1 = getelementptr inbounds %struct.iov_iter_state, %struct.iov_iter_state* %state, i64 0, i32 0
  store i64 %0, i64* %iov_offset1, align 8
  %count = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 3
  %1 = load i64, i64* %count, align 8
  %count2 = getelementptr inbounds %struct.iov_iter_state, %struct.iov_iter_state* %state, i64 0, i32 1
  store i64 %1, i64* %count2, align 8
  %nr_segs = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 5, i32 0
  %2 = load i64, i64* %nr_segs, align 8
  %nr_segs3 = getelementptr inbounds %struct.iov_iter_state, %struct.iov_iter_state* %state, i64 0, i32 2
  store i64 %2, i64* %nr_segs3, align 8
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i64 @iov_iter_count(%struct.iov_iter* nocapture noundef readonly %i) unnamed_addr #3 {
entry:
  %count = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %i, i64 0, i32 3
  %0 = load i64, i64* %count, align 8
  ret i64 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_file_supports_nowait(%struct.io_kiocb* nocapture noundef readonly %req, i32 noundef %rw) unnamed_addr #1 {
entry:
  switch i32 %rw, label %if.end7 [
    i32 0, label %land.lhs.true
    i32 1, label %land.lhs.true2
  ]

land.lhs.true:                                    ; preds = %entry
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 2097152
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end7, label %return

land.lhs.true2:                                   ; preds = %entry
  %flags3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags3, align 8
  %and4 = and i32 %1, 4194304
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end7, label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %land.lhs.true2
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %2 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc i1 @__io_file_supports_nowait(%struct.file* noundef %2, i32 noundef %rw) #25
  br label %return

return:                                           ; preds = %land.lhs.true2, %land.lhs.true, %if.end7
  %retval.0 = phi i1 [ %call, %if.end7 ], [ true, %land.lhs.true ], [ true, %land.lhs.true2 ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_setup_async_rw(%struct.io_kiocb* nocapture noundef %req, %struct.iovec* noundef %iovec, %struct.iovec* noundef %fast_iov, %struct.iov_iter* noundef %iter, i1 noundef %force) unnamed_addr #1 {
entry:
  br i1 %force, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %idxprom = zext i8 %0 to i64
  %1 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom, i32 0
  %bf.load = load i16, i16* %1, align 4
  %2 = and i16 %bf.load, 128
  %tobool1.not = icmp eq i16 %2, 0
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = load i8*, i8** %async_data, align 8
  %tobool2.not = icmp eq i8* %3, null
  br i1 %tobool2.not, label %if.then3, label %return

if.then3:                                         ; preds = %if.end
  %call = call fastcc i32 @io_alloc_async_data(%struct.io_kiocb* noundef %req) #25
  %tobool4.not = icmp eq i32 %call, 0
  br i1 %tobool4.not, label %cleanup.thread, label %cleanup

cleanup.thread:                                   ; preds = %if.then3
  call fastcc void @io_req_map_rw(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %iovec, %struct.iovec* noundef %fast_iov, %struct.iov_iter* noundef %iter) #25
  %4 = bitcast i8** %async_data to %struct.io_async_rw**
  %5 = load %struct.io_async_rw*, %struct.io_async_rw** %4, align 8
  %iter8 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %5, i64 0, i32 2
  %iter_state = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %5, i64 0, i32 3
  call fastcc void @iov_iter_save_state(%struct.iov_iter* noundef %iter8, %struct.iov_iter_state* noundef %iter_state) #25
  br label %return

cleanup:                                          ; preds = %if.then3
  %6 = bitcast %struct.iovec* %iovec to i8*
  call void @kfree(i8* noundef %6) #27
  br label %return

return:                                           ; preds = %if.end, %cleanup.thread, %cleanup, %land.lhs.true
  %retval.1 = phi i32 [ -12, %cleanup ], [ 0, %land.lhs.true ], [ 0, %cleanup.thread ], [ 0, %if.end ]
  ret i32 %retval.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rw_verify_area(i32 noundef, %struct.file* noundef, i64* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i64* @io_kiocb_ppos(%struct.kiocb* noundef readonly %kiocb) unnamed_addr #3 {
entry:
  %ki_filp = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 0
  %0 = load %struct.file*, %struct.file** %ki_filp, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 8
  %1 = load i32, i32* %f_mode, align 4
  %and = and i32 %1, 2097152
  %tobool.not = icmp eq i32 %and, 0
  %ki_pos = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 1
  %cond = select i1 %tobool.not, i64* %ki_pos, i64* null
  ret i64* %cond
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_iter_do_read(%struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %f_op = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %read_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i64 0, i32 4
  %2 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %read_iter, align 8
  %tobool.not = icmp eq i64 (%struct.kiocb*, %struct.iov_iter*)* %2, null
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %kiocb = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0
  %call = call fastcc i64 @call_read_iter(%struct.file* noundef %0, %struct.kiocb* noundef %kiocb, %struct.iov_iter* noundef %iter) #25
  %conv = trunc i64 %call to i32
  br label %return

if.else:                                          ; preds = %entry
  %read = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i64 0, i32 2
  %3 = load i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)** %read, align 8
  %tobool4.not = icmp eq i64 (%struct.file*, i8*, i64, i64*)* %3, null
  br i1 %tobool4.not, label %return, label %if.then5

if.then5:                                         ; preds = %if.else
  %call6 = call fastcc i64 @loop_rw_iter(i32 noundef 0, %struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter) #25
  %conv7 = trunc i64 %call6 to i32
  br label %return

return:                                           ; preds = %if.else, %if.then5, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %conv7, %if.then5 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @need_read_all(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #3 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 8388608
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %1 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %1) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 0
  %2 = load i16, i16* %i_mode, align 8
  %3 = and i16 %2, -4096
  %cmp = icmp eq i16 %3, 24576
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @iov_iter_advance(%struct.iov_iter* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc i1 @io_rw_should_retry(%struct.io_kiocb* noundef %req) unnamed_addr #9 {
entry:
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %0 = bitcast i8** %async_data to %struct.io_async_rw**
  %1 = load %struct.io_async_rw*, %struct.io_async_rw** %0, align 8
  %wpq = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 5
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 2048
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %3 = load i32, i32* %ki_flags, align 8
  %and3 = and i32 %3, 131073
  %tobool4.not = icmp eq i32 %and3, 0
  br i1 %tobool4.not, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc i1 @file_can_poll(%struct.file* noundef %4) #25
  br i1 %call, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %4, i64 0, i32 8
  %5 = load i32, i32* %f_mode, align 4
  %and8 = and i32 %5, 1073741824
  %tobool9.not = icmp eq i32 %and8, 0
  br i1 %tobool9.not, label %cleanup, label %if.end11

if.end11:                                         ; preds = %lor.lhs.false
  %func = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 5, i32 2, i32 2
  store i32 (%struct.wait_queue_entry*, i32, i32, i8*)* @io_async_buf_func, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func, align 8
  %private = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 5, i32 2, i32 1
  %6 = bitcast i8** %private to %struct.io_kiocb**
  store %struct.io_kiocb* %req, %struct.io_kiocb** %6, align 8
  %flags15 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 5, i32 2, i32 0
  store i32 0, i32* %flags15, align 8
  %entry17 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 5, i32 2, i32 3
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %entry17) #25
  %7 = load i32, i32* %ki_flags, align 8
  %or = and i32 %7, -524297
  %and20 = or i32 %or, 524288
  store i32 %and20, i32* %ki_flags, align 8
  %ki_waitq = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7, i32 0
  store %struct.wait_page_queue* %wpq, %struct.wait_page_queue** %ki_waitq, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %lor.lhs.false, %if.end, %entry, %if.end11
  %retval.0 = phi i1 [ true, %if.end11 ], [ false, %entry ], [ false, %if.end ], [ false, %lor.lhs.false ], [ false, %if.end6 ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @kiocb_done(%struct.kiocb* noundef %kiocb, i64 noundef %ret, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.kiocb* %kiocb to %struct.io_kiocb*
  %async_data = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 1, i32 2
  %1 = bitcast void (%struct.kiocb*, i64, i64)** %async_data to %struct.io_async_rw**
  %2 = load %struct.io_async_rw*, %struct.io_async_rw** %1, align 8
  %tobool.not = icmp eq %struct.io_async_rw* %2, null
  br i1 %tobool.not, label %if.end5, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %bytes_done = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %2, i64 0, i32 4
  %3 = load i64, i64* %bytes_done, align 8
  %cmp.not = icmp eq i64 %3, 0
  br i1 %cmp.not, label %if.end5, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = icmp sgt i64 %ret, 0
  %add = select i1 %4, i64 %ret, i64 0
  %spec.select = add i64 %3, %add
  br label %if.end5

if.end5:                                          ; preds = %if.then, %land.lhs.true, %entry
  %ret.addr.0 = phi i64 [ %ret, %land.lhs.true ], [ %ret, %entry ], [ %spec.select, %if.then ]
  %flags = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 1, i32 7
  %5 = bitcast %union.anon.40* %flags to i32*
  %6 = load i32, i32* %5, align 8
  %and = and i32 %6, 1024
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  %ki_pos = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 1
  %7 = load i64, i64* %ki_pos, align 8
  %file = getelementptr %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 0
  %8 = load %struct.file*, %struct.file** %file, align 8
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %8, i64 0, i32 10
  store i64 %7, i64* %f_pos, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  %cmp9 = icmp sgt i64 %ret.addr.0, -1
  br i1 %cmp9, label %land.lhs.true10, label %if.else13

land.lhs.true10:                                  ; preds = %if.end8
  %ki_complete = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 2
  %9 = load void (%struct.kiocb*, i64, i64)*, void (%struct.kiocb*, i64, i64)** %ki_complete, align 8
  %cmp11 = icmp eq void (%struct.kiocb*, i64, i64)* %9, @io_complete_rw
  br i1 %cmp11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %land.lhs.true10
  call fastcc void @__io_complete_rw(%struct.io_kiocb* noundef %0, i64 noundef %ret.addr.0, i32 noundef %issue_flags) #25
  br label %if.end14

if.else13:                                        ; preds = %land.lhs.true10, %if.end8
  call fastcc void @io_rw_done(%struct.kiocb* noundef %kiocb, i64 noundef %ret.addr.0) #25
  br label %if.end14

if.end14:                                         ; preds = %if.else13, %if.then12
  %10 = load i32, i32* %5, align 8
  %and16 = and i32 %10, 131072
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %if.end32, label %if.then18

if.then18:                                        ; preds = %if.end14
  %and20 = and i32 %10, -131073
  store i32 %and20, i32* %5, align 8
  %call = call fastcc i1 @io_resubmit_prep(%struct.io_kiocb* noundef %0) #25
  br i1 %call, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.then18
  call fastcc void @io_req_task_queue_reissue(%struct.io_kiocb* noundef %0) #25
  br label %if.end32

if.else22:                                        ; preds = %if.then18
  %call23 = call fastcc i32 @io_put_rw_kbuf(%struct.io_kiocb* noundef %0) #25
  %ctx24 = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 1, i32 4
  %11 = bitcast i32* %ctx24 to %struct.io_ring_ctx**
  %12 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %11, align 8
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %0) #25
  %and25 = and i32 %issue_flags, 1
  %tobool26.not = icmp eq i32 %and25, 0
  br i1 %tobool26.not, label %if.then27, label %if.else29

if.then27:                                        ; preds = %if.else22
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %12, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %0, i32 noundef %issue_flags, i64 noundef %ret.addr.0, i32 noundef %call23) #25
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end32

if.else29:                                        ; preds = %if.else22
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %0, i32 noundef %issue_flags, i64 noundef %ret.addr.0, i32 noundef %call23) #25
  br label %if.end32

if.end32:                                         ; preds = %if.then27, %if.else29, %if.then21, %if.end14
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_import_fixed(%struct.io_kiocb* nocapture noundef %req, i32 noundef %rw, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %imu2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 19
  %0 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %imu2, align 8
  %buf_index3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 4
  %1 = load i16, i16* %buf_index3, align 2
  %tobool.not = icmp eq %struct.io_mapped_ubuf* %0, null
  br i1 %tobool.not, label %if.then, label %if.end30, !prof !8

if.then:                                          ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %conv7 = zext i16 %1 to i32
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 1, i32 9
  %3 = load i32, i32* %nr_user_bufs, align 4
  %cmp.not = icmp ugt i32 %3, %conv7
  br i1 %cmp.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %if.then
  %conv18 = zext i16 %1 to i64
  %conv19 = zext i32 %3 to i64
  %call = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv18, i64 noundef %conv19) #25
  %4 = trunc i64 %call to i16
  %conv24 = and i16 %1, %4
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 1, i32 10
  %5 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %idxprom = zext i16 %conv24 to i64
  %arrayidx = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %5, i64 %idxprom
  %6 = load volatile %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %arrayidx, align 8
  store %struct.io_mapped_ubuf* %6, %struct.io_mapped_ubuf** %imu2, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end, %entry
  %imu.0 = phi %struct.io_mapped_ubuf* [ %6, %if.end ], [ %0, %entry ]
  %call31 = call fastcc i32 @__io_import_fixed(%struct.io_kiocb* noundef %req, i32 noundef %rw, %struct.iov_iter* noundef %iter, %struct.io_mapped_ubuf* noundef %imu.0) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end30
  %retval.0 = phi i32 [ %call31, %if.end30 ], [ -14, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @io_rw_buffer_select(%struct.io_kiocb* nocapture noundef %req, i64* nocapture noundef %len, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %0 = load i64, i64* %addr, align 8
  %1 = inttoptr i64 %0 to %struct.io_buffer*
  %buf_index = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 4
  %2 = load i16, i16* %buf_index, align 2
  %conv = zext i16 %2 to i32
  %call = call fastcc %struct.io_buffer* @io_buffer_select(%struct.io_kiocb* noundef %req, i64* noundef %len, i32 noundef %conv, %struct.io_buffer* noundef %1, i1 noundef %needs_lock) #25
  %3 = bitcast %struct.io_buffer* %call to i8*
  %call1 = call fastcc i1 @IS_ERR(i8* noundef %3) #25
  br i1 %call1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = ptrtoint %struct.io_buffer* %call to i64
  store i64 %4, i64* %addr, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %5 = load i32, i32* %flags, align 8
  %or = or i32 %5, 32768
  store i32 %or, i32* %flags, align 8
  %addr6 = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %call, i64 0, i32 1
  %6 = load i64, i64* %addr6, align 8
  %7 = inttoptr i64 %6 to i8*
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i8* [ %7, %if.end ], [ %3, %entry ]
  ret i8* %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i1 @IS_ERR(i8* noundef readnone %ptr) unnamed_addr #0 {
entry:
  %cmp = icmp ugt i8* %ptr, inttoptr (i64 -4096 to i8*)
  ret i1 %cmp
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @PTR_ERR(i8* noundef %ptr) unnamed_addr #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @import_single_range(i32 noundef, i8* noundef, i64 noundef, %struct.iovec* noundef, %struct.iov_iter* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @io_iov_buffer_select(%struct.io_kiocb* nocapture noundef %req, %struct.iovec* noundef %iov, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 32768
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %1 = load i64, i64* %addr, align 8
  %2 = inttoptr i64 %1 to %struct.io_buffer*
  %addr2 = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %2, i64 0, i32 1
  %3 = load i64, i64* %addr2, align 8
  %4 = inttoptr i64 %3 to i8*
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  store i8* %4, i8** %iov_base, align 8
  %len = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %2, i64 0, i32 2
  %5 = load i32, i32* %len, align 8
  %conv3 = zext i32 %5 to i64
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 1
  store i64 %conv3, i64* %iov_len, align 8
  br label %return

if.end:                                           ; preds = %entry
  %len6 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 2
  %6 = load i64, i64* %len6, align 8
  %cmp7.not = icmp eq i64 %6, 1
  br i1 %cmp7.not, label %if.end10, label %return

if.end10:                                         ; preds = %if.end
  %call = call fastcc i64 @__io_iov_buffer_select(%struct.io_kiocb* noundef %req, %struct.iovec* noundef %iov, i1 noundef %needs_lock) #25
  br label %return

return:                                           ; preds = %if.end, %if.end10, %if.then
  %retval.0 = phi i64 [ 0, %if.then ], [ %call, %if.end10 ], [ -22, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @iov_iter_init(%struct.iov_iter* noundef, i32 noundef, %struct.iovec* noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__import_iovec(i32 noundef, %struct.iovec* noundef, i32 noundef, i32 noundef, %struct.iovec** noundef, %struct.iov_iter* noundef, i1 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @array_index_mask_nospec(i64 noundef %idx, i64 noundef %sz) unnamed_addr #1 {
entry:
  %0 = call i64 asm sideeffect "\09cmp\09$1, $2\0A\09sbc\09$0, xzr, xzr\0A", "=r,r,Ir,~{cc}"(i64 %idx, i64 %sz) #26, !srcloc !57
  call void asm sideeffect "hint #20", "~{memory}"() #26, !srcloc !58
  ret i64 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_import_fixed(%struct.io_kiocb* nocapture noundef readonly %req, i32 noundef %rw, %struct.iov_iter* noundef %iter, %struct.io_mapped_ubuf* noundef %imu) unnamed_addr #1 {
entry:
  %len2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 2
  %0 = load i64, i64* %len2, align 8
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %1 = load i64, i64* %addr, align 8
  %2 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %1, i64 %0)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  br i1 %3, label %cleanup, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %ubuf = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 0
  %5 = load i64, i64* %ubuf, align 8
  %cmp9 = icmp ult i64 %1, %5
  br i1 %cmp9, label %cleanup, label %lor.rhs, !prof !24

lor.rhs:                                          ; preds = %if.end
  %ubuf_end = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 1
  %6 = load i64, i64* %ubuf_end, align 8
  %cmp11 = icmp ugt i64 %4, %6
  br i1 %cmp11, label %cleanup, label %if.end21, !prof !24

if.end21:                                         ; preds = %lor.rhs
  %sub = sub i64 %1, %5
  %arraydecay = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 4, i64 0
  %nr_bvecs = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 2
  %7 = load i32, i32* %nr_bvecs, align 8
  %conv23 = zext i32 %7 to i64
  %add = add i64 %sub, %0
  call void @iov_iter_bvec(%struct.iov_iter* noundef %iter, i32 noundef %rw, %struct.bio_vec* noundef %arraydecay, i64 noundef %conv23, i64 noundef %add) #27
  %tobool24.not = icmp eq i64 %sub, 0
  br i1 %tobool24.not, label %cleanup, label %if.then25

if.then25:                                        ; preds = %if.end21
  %bv_len = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 4, i64 0, i32 1
  %8 = load i32, i32* %bv_len, align 8
  %conv29 = zext i32 %8 to i64
  %cmp30.not = icmp ugt i64 %sub, %conv29
  br i1 %cmp30.not, label %if.else, label %if.then32

if.then32:                                        ; preds = %if.then25
  call void @iov_iter_advance(%struct.iov_iter* noundef %iter, i64 noundef %sub) #27
  br label %cleanup

if.else:                                          ; preds = %if.then25
  %sub35 = sub i64 %sub, %conv29
  %shr = lshr i64 %sub35, 12
  %add36 = add nuw nsw i64 %shr, 1
  %add.ptr = getelementptr %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 4, i64 %add36
  %9 = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 4
  %bvec37 = bitcast %union.anon.4* %9 to %struct.bio_vec**
  store %struct.bio_vec* %add.ptr, %struct.bio_vec** %bvec37, align 8
  %nr_segs = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 5, i32 0
  %10 = load i64, i64* %nr_segs, align 8
  %sub38 = sub i64 %10, %add36
  store i64 %sub38, i64* %nr_segs, align 8
  %11 = load i32, i32* %bv_len, align 8
  %conv40 = zext i32 %11 to i64
  %count = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 3
  %12 = load i64, i64* %count, align 8
  %13 = add i64 %sub35, %conv40
  %sub42 = sub i64 %12, %13
  store i64 %sub42, i64* %count, align 8
  %and = and i64 %sub35, 4095
  %iov_offset = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 2
  store i64 %and, i64* %iov_offset, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end21, %if.else, %if.then32, %lor.rhs, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ -14, %lor.rhs ], [ 0, %if.then32 ], [ 0, %if.else ], [ 0, %if.end21 ], [ -14, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #11

; Function Attrs: null_pointer_is_valid
declare dso_local void @iov_iter_bvec(%struct.iov_iter* noundef, i32 noundef, %struct.bio_vec* noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_buffer* @io_buffer_select(%struct.io_kiocb* nocapture noundef readonly %req, i64* nocapture noundef %len, i32 noundef %bgid, %struct.io_buffer* noundef readnone %kbuf, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 32768
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %1, i1 noundef %needs_lock) #25
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %io_buffers = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 1, i32 15
  %3 = zext i32 %bgid to i64
  %call = call i8* @xa_load(%struct.xarray* noundef %io_buffers, i64 noundef %3) #27
  %4 = bitcast i8* %call to %struct.io_buffer*
  %tobool4.not = icmp eq i8* %call, null
  br i1 %tobool4.not, label %if.else26, label %if.then5

if.then5:                                         ; preds = %if.end
  %list = bitcast i8* %call to %struct.list_head*
  %call6 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %list) #25
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then5
  %prev = getelementptr inbounds i8, i8* %call, i64 8
  %5 = bitcast i8* %prev to %struct.io_buffer**
  %6 = load %struct.io_buffer*, %struct.io_buffer** %5, align 8
  %list13 = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %6, i64 0, i32 0
  call fastcc void @list_del(%struct.list_head* noundef %list13) #25
  br label %if.end18

if.else:                                          ; preds = %if.then5
  %7 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %io_buffers15 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %7, i64 0, i32 1, i32 15
  %call17 = call i8* @xa_erase(%struct.xarray* noundef %io_buffers15, i64 noundef %3) #27
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then8
  %kbuf.addr.0 = phi %struct.io_buffer* [ %4, %if.else ], [ %6, %if.then8 ]
  %8 = load i64, i64* %len, align 8
  %len19 = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %kbuf.addr.0, i64 0, i32 2
  %9 = load i32, i32* %len19, align 8
  %conv20 = zext i32 %9 to i64
  %cmp = icmp ugt i64 %8, %conv20
  br i1 %cmp, label %if.then22, label %if.end28

if.then22:                                        ; preds = %if.end18
  store i64 %conv20, i64* %len, align 8
  br label %if.end28

if.else26:                                        ; preds = %if.end
  %call27 = call fastcc i8* @ERR_PTR(i64 noundef -105) #25
  %10 = bitcast i8* %call27 to %struct.io_buffer*
  br label %if.end28

if.end28:                                         ; preds = %if.end18, %if.then22, %if.else26
  %kbuf.addr.1 = phi %struct.io_buffer* [ %kbuf.addr.0, %if.then22 ], [ %kbuf.addr.0, %if.end18 ], [ %10, %if.else26 ]
  %11 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %11, i1 noundef %needs_lock) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end28
  %retval.0 = phi %struct.io_buffer* [ %kbuf.addr.1, %if.end28 ], [ %kbuf, %entry ]
  ret %struct.io_buffer* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %ctx, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  br i1 %needs_lock, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @xa_load(%struct.xarray* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @xa_erase(%struct.xarray* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i8* @ERR_PTR(i64 noundef %error) unnamed_addr #0 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %ctx, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  br i1 %needs_lock, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__io_iov_buffer_select(%struct.io_kiocb* nocapture noundef %req, %struct.iovec* noundef %iov, i1 noundef %needs_lock) unnamed_addr #1 {
entry:
  %len = alloca i64, align 8
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %0 = load i64, i64* %addr, align 8
  %1 = inttoptr i64 %0 to i8*
  %2 = bitcast i64* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %2) #26
  %3 = bitcast %struct.iovec* %iov to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef %3, i8* noundef %1, i64 noundef 16) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 1
  %4 = load i64, i64* %iov_len, align 8
  store i64 %4, i64* %len, align 8
  %cmp2 = icmp slt i64 %4, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call7 = call fastcc i8* @io_rw_buffer_select(%struct.io_kiocb* noundef %req, i64* noundef nonnull %len, i1 noundef %needs_lock) #25
  %call8 = call fastcc i1 @IS_ERR(i8* noundef %call7) #25
  br i1 %call8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end5
  %call10 = call fastcc i64 @PTR_ERR(i8* noundef %call7) #25
  br label %cleanup

if.end11:                                         ; preds = %if.end5
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  store i8* %call7, i8** %iov_base, align 8
  %5 = load i64, i64* %len, align 8
  store i64 %5, i64* %iov_len, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end11, %if.then9
  %retval.0 = phi i64 [ %call10, %if.then9 ], [ 0, %if.end11 ], [ -14, %entry ], [ -22, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %2) #26
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @_copy_from_user(i8* noundef %to, i8* noundef %from, i64 noundef %n) unnamed_addr #1 {
entry:
  %call1 = call fastcc i64 @__range_ok(i8* noundef %from, i64 noundef %n) #25
  %tobool.not = icmp eq i64 %call1, 0
  br i1 %tobool.not, label %if.end, label %if.then, !prof !24

if.then:                                          ; preds = %entry
  %call5 = call fastcc i8* @__uaccess_mask_ptr(i8* noundef %from) #25
  %call6 = call i64 @__arch_copy_from_user(i8* noundef %to, i8* noundef %call5, i64 noundef %n) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %res.0 = phi i64 [ %call6, %if.then ], [ %n, %entry ]
  %tobool8.not = icmp eq i64 %res.0, 0
  br i1 %tobool8.not, label %if.end18, label %if.then16, !prof !8

if.then16:                                        ; preds = %if.end
  %sub = sub i64 %n, %res.0
  %add.ptr = getelementptr i8, i8* %to, i64 %sub
  %call17 = call i8* @memset(i8* noundef %add.ptr, i32 noundef 0, i64 noundef %res.0) #27
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end
  ret i64 %res.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__range_ok(i8* noundef %addr, i64 noundef %size) unnamed_addr #1 {
entry:
  %0 = call { i64, i64 } asm sideeffect "\09adds\09$0, $3, $2\0A\09csel\09$1, xzr, $1, hi\0A\09csinv\09$0, $0, xzr, cc\0A\09sbcs\09xzr, $0, $1\0A\09cset\09$0, ls\0A", "=&r,=r,Ir,0,1,~{cc}"(i64 %size, i8* %addr, i64 549755813887) #26, !srcloc !59
  %asmresult = extractvalue { i64, i64 } %0, 0
  ret i64 %asmresult
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__arch_copy_from_user(i8* noundef, i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @__uaccess_mask_ptr(i8* noundef %ptr) unnamed_addr #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %shl.i = shl i64 %0, 8
  %shr.i = ashr exact i64 %shl.i, 8
  %and = and i64 %shr.i, %0
  %1 = inttoptr i64 %and to i8*
  %2 = call i8* asm sideeffect "\09bics\09xzr, $3, $2\0A\09csel\09$0, $1, xzr, eq\0A", "=&r,r,r,r,~{cc}"(i8* %ptr, i64 549755813887, i8* %1) #26, !srcloc !60
  call void asm sideeffect "hint #20", "~{memory}"() #26, !srcloc !61
  ret i8* %2
}

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @memset(i8* noundef, i32 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_file_supports_nowait(%struct.file* nocapture noundef readonly %file, i32 noundef %rw) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %file) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 0
  %0 = load i16, i16* %i_mode, align 8
  %1 = and i16 %0, -4096
  switch i16 %1, label %if.end24 [
    i16 24576, label %if.then
    i16 -16384, label %cleanup
    i16 -32768, label %if.then17
  ]

if.then:                                          ; preds = %entry
  %f_mapping = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 17
  %2 = load %struct.address_space*, %struct.address_space** %f_mapping, align 8
  %host = getelementptr inbounds %struct.address_space, %struct.address_space* %2, i64 0, i32 0
  %3 = load %struct.inode*, %struct.inode** %host, align 8
  %call2 = call %struct.block_device* @I_BDEV(%struct.inode* noundef %3) #27
  %call3 = call fastcc i1 @io_bdev_nowait(%struct.block_device* noundef %call2) #25
  br label %cleanup

if.then17:                                        ; preds = %entry
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 2
  %4 = load %struct.inode*, %struct.inode** %f_inode, align 8
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %4, i64 0, i32 6
  %5 = load %struct.super_block*, %struct.super_block** %i_sb, align 8
  %s_bdev = getelementptr inbounds %struct.super_block, %struct.super_block* %5, i64 0, i32 20
  %6 = load %struct.block_device*, %struct.block_device** %s_bdev, align 64
  %call18 = call fastcc i1 @io_bdev_nowait(%struct.block_device* noundef %6) #25
  br i1 %call18, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.then17
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp20.not = icmp eq %struct.file_operations* %7, @io_uring_fops
  br i1 %cmp20.not, label %if.end23, label %cleanup

if.end23:                                         ; preds = %land.lhs.true, %if.then17
  br label %cleanup

if.end24:                                         ; preds = %entry
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 7
  %8 = load i32, i32* %f_flags, align 8
  %and25 = and i32 %8, 2048
  %tobool.not = icmp eq i32 %and25, 0
  br i1 %tobool.not, label %if.end27, label %cleanup

if.end27:                                         ; preds = %if.end24
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 8
  %9 = load i32, i32* %f_mode, align 4
  %and28 = and i32 %9, 134217728
  %tobool29.not = icmp eq i32 %and28, 0
  br i1 %tobool29.not, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end27
  %cmp32 = icmp eq i32 %rw, 0
  %f_op35 = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %10 = load %struct.file_operations*, %struct.file_operations** %f_op35, align 8
  br i1 %cmp32, label %if.then34, label %if.end38

if.then34:                                        ; preds = %if.end31
  %read_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %10, i64 0, i32 4
  %11 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %read_iter, align 8
  %cmp36 = icmp ne i64 (%struct.kiocb*, %struct.iov_iter*)* %11, null
  br label %cleanup

if.end38:                                         ; preds = %if.end31
  %write_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %10, i64 0, i32 5
  %12 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %write_iter, align 8
  %cmp40 = icmp ne i64 (%struct.kiocb*, %struct.iov_iter*)* %12, null
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %if.end24, %land.lhs.true, %entry, %if.then, %if.end38, %if.then34, %if.end23
  %retval.0 = phi i1 [ false, %if.end23 ], [ %cmp36, %if.then34 ], [ %cmp40, %if.end38 ], [ %call3, %if.then ], [ true, %entry ], [ true, %land.lhs.true ], [ true, %if.end24 ], [ false, %if.end27 ]
  ret i1 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.inode* @file_inode(%struct.file* nocapture noundef readonly %f) unnamed_addr #3 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i64 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8
  ret %struct.inode* %0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @io_bdev_nowait(%struct.block_device* noundef readonly %bdev) unnamed_addr #8 {
entry:
  %tobool.not = icmp eq %struct.block_device* %bdev, null
  br i1 %tobool.not, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call = call fastcc %struct.request_queue* @bdev_get_queue(%struct.block_device* noundef nonnull %bdev) #25
  %queue_flags = getelementptr inbounds %struct.request_queue, %struct.request_queue* %call, i64 0, i32 11
  %0 = load volatile i64, i64* %queue_flags, align 8
  %1 = and i64 %0, 536870912
  %tobool2 = icmp ne i64 %1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %tobool2, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.block_device* @I_BDEV(%struct.inode* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.request_queue* @bdev_get_queue(%struct.block_device* nocapture noundef readonly %bdev) unnamed_addr #3 {
entry:
  %bd_disk = getelementptr inbounds %struct.block_device, %struct.block_device* %bdev, i64 0, i32 16
  %0 = load %struct.gendisk*, %struct.gendisk** %bd_disk, align 8
  %queue = getelementptr inbounds %struct.gendisk, %struct.gendisk* %0, i64 0, i32 9
  %1 = load %struct.request_queue*, %struct.request_queue** %queue, align 8
  ret %struct.request_queue* %1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_uring_poll(%struct.file* noundef %file, %struct.poll_table_struct* noundef %wait) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 15
  %0 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  %poll_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 10, i32 3
  call fastcc void @poll_wait(%struct.file* noundef %file, %struct.wait_queue_head* noundef %poll_wait, %struct.poll_table_struct* noundef %wait) #25
  call void asm sideeffect "dmb ishld", "~{memory}"() #26, !srcloc !62
  %call = call fastcc i1 @io_sqring_full(%struct.io_ring_ctx* noundef %1) #25
  %spec.select = select i1 %call, i32 0, i32 260
  %call1 = call fastcc i32 @io_cqring_events(%struct.io_ring_ctx* noundef %1) #25
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %lor.lhs.false, label %if.then4

lor.lhs.false:                                    ; preds = %entry
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 8
  %2 = load volatile i64, i64* %check_cq_overflow, align 8
  %conv.i15 = and i64 %2, 1
  %tobool3.not = icmp eq i64 %conv.i15, 0
  br i1 %tobool3.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %lor.lhs.false, %entry
  %or5 = or i32 %spec.select, 65
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %lor.lhs.false
  %mask.1 = phi i32 [ %or5, %if.then4 ], [ %spec.select, %lor.lhs.false ]
  ret i32 %mask.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_uring_mmap(%struct.file* nocapture noundef readonly %file, %struct.vm_area_struct* noundef %vma) #1 {
entry:
  %vm_end = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i64 0, i32 1
  %0 = load i64, i64* %vm_end, align 8
  %vm_start = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i64 0, i32 0
  %1 = load i64, i64* %vm_start, align 8
  %sub = sub i64 %0, %1
  %vm_pgoff = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i64 0, i32 13
  %2 = load i64, i64* %vm_pgoff, align 8
  %call = call fastcc i8* @io_uring_validate_mmap_request(%struct.file* noundef %file, i64 noundef %2, i64 noundef %sub) #25
  %call1 = call fastcc i1 @IS_ERR(i8* noundef %call) #25
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call fastcc i64 @PTR_ERR(i8* noundef %call) #25
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call fastcc i64 @virt_to_phys(i8* noundef %call) #25
  %shr = lshr i64 %call3, 12
  %3 = load i64, i64* %vm_start, align 8
  %coerce.dive = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i64 0, i32 7, i32 0
  %4 = load i64, i64* %coerce.dive, align 8
  %call5 = call i32 @remap_pfn_range(%struct.vm_area_struct* noundef %vma, i64 noundef %3, i64 noundef %shr, i64 noundef %sub, i64 %4) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %call5, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_uring_release(%struct.inode* nocapture noundef readnone %inode, %struct.file* nocapture noundef %file) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 15
  %0 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  store i8* null, i8** %private_data, align 8
  call fastcc void @io_ring_ctx_wait_and_kill(%struct.io_ring_ctx* noundef %1) #25
  ret i32 0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_uring_show_fdinfo(%struct.seq_file* noundef %m, %struct.file* nocapture noundef readonly %f) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %f, i64 0, i32 15
  %0 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 0
  %call = call fastcc i1 @percpu_ref_tryget(%struct.percpu_ref* noundef %refs) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @__io_uring_show_fdinfo(%struct.io_ring_ctx* noundef %1, %struct.seq_file* noundef %m) #25
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @poll_wait(%struct.file* noundef %filp, %struct.wait_queue_head* noundef %wait_address, %struct.poll_table_struct* noundef %p) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.poll_table_struct* %p, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i64 0, i32 0
  %0 = load void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8
  %tobool1 = icmp ne void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool3, %tobool1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void %0(%struct.file* noundef %filp, %struct.wait_queue_head* noundef nonnull %wait_address, %struct.poll_table_struct* noundef nonnull %p) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @io_sqring_full(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #8 {
entry:
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %tail = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 0, i32 2
  %1 = load volatile i32, i32* %tail, align 64
  %cached_sq_head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 3
  %2 = load i32, i32* %cached_sq_head, align 16
  %sub = sub i32 %1, %2
  %sq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 4
  %3 = load i32, i32* %sq_entries, align 4
  %cmp = icmp eq i32 %sub, %3
  ret i1 %cmp
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_cqring_events(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #1 {
entry:
  call void asm sideeffect "dmb ishld", "~{memory}"() #26, !srcloc !63
  %call = call fastcc i32 @__io_cqring_events(%struct.io_ring_ctx* noundef %ctx) #25
  ret i32 %call
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i8* @io_uring_validate_mmap_request(%struct.file* nocapture noundef readonly %file, i64 noundef %pgoff, i64 noundef %sz) unnamed_addr #8 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 15
  %0 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  %shl = shl i64 %pgoff, 12
  switch i64 %shl, label %cleanup.sink.split [
    i64 0, label %sw.bb
    i64 134217728, label %sw.bb
    i64 268435456, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 1
  %2 = bitcast %struct.io_rings** %rings to i8**
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %sq_sqes = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 2
  %3 = bitcast %struct.io_uring_sqe** %sq_sqes to i8**
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb
  %ptr.0.in = phi i8** [ %3, %sw.bb1 ], [ %2, %sw.bb ]
  %ptr.0 = load i8*, i8** %ptr.0.in, align 8
  %call2 = call fastcc %struct.page* @virt_to_head_page(i8* noundef %ptr.0) #25
  %call3 = call fastcc i64 @page_size(%struct.page* noundef %call2) #25
  %cmp = icmp ult i64 %call3, %sz
  br i1 %cmp, label %cleanup.sink.split, label %cleanup

cleanup.sink.split:                               ; preds = %sw.epilog, %entry
  %call4 = call fastcc i8* @ERR_PTR(i64 noundef -22) #25
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %sw.epilog
  %retval.0 = phi i8* [ %ptr.0, %sw.epilog ], [ %call4, %cleanup.sink.split ]
  ret i8* %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i64 @virt_to_phys(i8* noundef %x) unnamed_addr #3 {
entry:
  %0 = ptrtoint i8* %x to i64
  %sub = add i64 %0, 549755813888
  %cmp = icmp ult i64 %sub, 274877906944
  %1 = load i64, i64* @memstart_addr, align 8
  %add = add i64 %1, %sub
  %2 = load i64, i64* @kimage_voffset, align 8
  %sub3 = sub i64 %0, %2
  %cond = select i1 %cmp, i64 %add, i64 %sub3
  ret i64 %cond
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @remap_pfn_range(%struct.vm_area_struct* noundef, i64 noundef, i64 noundef, i64 noundef, i64) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc %struct.page* @virt_to_head_page(i8* noundef %x) unnamed_addr #8 {
entry:
  %0 = ptrtoint i8* %x to i64
  %sub = add i64 %0, 549755813888
  %1 = lshr i64 %sub, 6
  %mul = and i64 %1, 288230376151711680
  %add = add nsw i64 %mul, -8589934592
  %2 = inttoptr i64 %add to %struct.page*
  %call = call fastcc i64 @_compound_head(%struct.page* noundef %2) #25
  %3 = inttoptr i64 %call to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i64 @page_size(%struct.page* noundef %page) unnamed_addr #8 {
entry:
  %call = call fastcc i32 @compound_order(%struct.page* noundef %page) #25
  %sh_prom = zext i32 %call to i64
  %shl = shl i64 4096, %sh_prom
  ret i64 %shl
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i64 @_compound_head(%struct.page* noundef %page) unnamed_addr #8 {
entry:
  %0 = getelementptr inbounds %struct.page, %struct.page* %page, i64 0, i32 1
  %compound_head = bitcast %union.anon.5* %0 to i64*
  %1 = load volatile i64, i64* %compound_head, align 8
  %and = and i64 %1, 1
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  %sub = add i64 %1, -1
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = ptrtoint %struct.page* %page to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %sub, %if.then ], [ %2, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @compound_order(%struct.page* noundef %page) unnamed_addr #8 {
entry:
  %flags.i = getelementptr inbounds %struct.page, %struct.page* %page, i64 0, i32 0
  %0 = load volatile i64, i64* %flags.i, align 8
  %1 = and i64 %0, 65536
  %tobool.not = icmp eq i64 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %2 = getelementptr %struct.page, %struct.page* %page, i64 1, i32 1
  %3 = bitcast %union.anon.5* %2 to %struct.anon.128*
  %compound_order = getelementptr inbounds %struct.anon.128, %struct.anon.128* %3, i64 0, i32 2
  %4 = load i8, i8* %compound_order, align 1
  %conv = zext i8 %4 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_ctx_wait_and_kill(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %index = alloca i64, align 8
  %0 = bitcast i64* %index to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_kill(%struct.percpu_ref* noundef %refs) #25
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %tobool.not = icmp eq %struct.io_rings* %1, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call fastcc i1 @__io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx, i1 noundef true) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i64 0, i64* %index, align 8
  %personalities = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 16
  %call1 = call i8* @xa_find(%struct.xarray* noundef %personalities, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool2.not31 = icmp eq i8* %call1, null
  br i1 %tobool2.not31, label %for.end, label %for.body

for.body:                                         ; preds = %if.end, %for.body
  %2 = load i64, i64* %index, align 8
  %conv = trunc i64 %2 to i32
  %call3 = call fastcc i32 @io_unregister_personality(%struct.io_ring_ctx* noundef %ctx, i32 noundef %conv) #25
  %call5 = call i8* @xa_find_after(%struct.xarray* noundef %personalities, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool2.not = icmp eq i8* %call5, null
  br i1 %tobool2.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %if.end
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %call7 = call fastcc i1 @io_kill_timeouts(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef null, i1 noundef true) #25
  %call8 = call fastcc i1 @io_poll_remove_all(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef null, i1 noundef true) #25
  call fastcc void @io_iopoll_try_reap_events(%struct.io_ring_ctx* noundef %ctx) #25
  %exit_work = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 5
  %.compoundliteral.sroa.0.0..sroa_idx = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 5, i32 0, i32 0
  store i64 68719476704, i64* %.compoundliteral.sroa.0.0..sroa_idx, align 8
  %entry11 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 5, i32 1
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %entry11) #25
  %func = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 5, i32 2
  store void (%struct.work_struct*)* @io_ring_exit_work, void (%struct.work_struct*)** %func, align 8
  %3 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_unbound_wq, align 8
  call fastcc void @queue_work(%struct.workqueue_struct* noundef %3, %struct.work_struct* noundef %exit_work) #25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_ref_kill(%struct.percpu_ref* noundef %ref) unnamed_addr #1 {
entry:
  call void @percpu_ref_kill_and_confirm(%struct.percpu_ref* noundef %ref, void (%struct.percpu_ref*)* noundef null) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx, i1 noundef %force) unnamed_addr #1 {
entry:
  br i1 %force, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = call fastcc i32 @__io_cqring_events(%struct.io_ring_ctx* noundef %ctx) #25
  %cq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 1
  %0 = load i32, i32* %cq_entries, align 4
  %cmp = icmp eq i32 %call, %0
  br i1 %cmp, label %cleanup42, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %cq_overflow_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 14
  %call175 = call fastcc i32 @list_empty(%struct.list_head* noundef %cq_overflow_list) #25
  %tobool2.not76 = icmp eq i32 %call175, 0
  br i1 %tobool2.not76, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %if.end
  %1 = bitcast %struct.list_head* %cq_overflow_list to i8**
  %call381 = call fastcc %struct.io_uring_cqe* @io_get_cqe(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool4.not82 = icmp eq %struct.io_uring_cqe* %call381, null
  %tobool4.not.not83 = xor i1 %tobool4.not82, true
  %brmerge84 = or i1 %tobool4.not.not83, %force
  br i1 %brmerge84, label %if.end8, label %while.end

while.body:                                       ; preds = %cleanup
  %call3 = call fastcc %struct.io_uring_cqe* @io_get_cqe(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool4.not = icmp eq %struct.io_uring_cqe* %call3, null
  %tobool4.not.not = xor i1 %tobool4.not, true
  %brmerge = or i1 %tobool4.not.not, %force
  br i1 %brmerge, label %if.end8, label %while.end

if.end8:                                          ; preds = %while.body.lr.ph, %while.body
  %tobool4.not86 = phi i1 [ %tobool4.not, %while.body ], [ %tobool4.not82, %while.body.lr.ph ]
  %call385 = phi %struct.io_uring_cqe* [ %call3, %while.body ], [ %call381, %while.body.lr.ph ]
  %2 = load i8*, i8** %1, align 8
  %add.ptr = getelementptr i8, i8* %2, i64 -16
  br i1 %tobool4.not86, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end8
  %3 = bitcast %struct.io_uring_cqe* %call385 to i8*
  %call13 = call i8* @memcpy(i8* noundef nonnull %3, i8* noundef %add.ptr, i64 noundef 16) #27
  br label %cleanup

if.else:                                          ; preds = %if.end8
  call fastcc void @io_account_cq_overflow(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %if.else
  %4 = bitcast i8* %2 to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %4) #25
  call void @kfree(i8* noundef %add.ptr) #27
  %call1 = call fastcc i32 @list_empty(%struct.list_head* noundef %cq_overflow_list) #25
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %cleanup, %while.body.lr.ph, %if.end
  %posted.0.off0.lcssa = phi i1 [ false, %if.end ], [ false, %while.body.lr.ph ], [ true, %cleanup ], [ true, %while.body ]
  %call17 = call fastcc i32 @list_empty(%struct.list_head* noundef %cq_overflow_list) #25
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then21, label %if.end33

if.then21:                                        ; preds = %while.end
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 8
  call fastcc void @clear_bit(i64 noundef 0, i64* noundef %check_cq_overflow) #25
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %5 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %sq_flags = getelementptr inbounds %struct.io_rings, %struct.io_rings* %5, i64 0, i32 7
  %6 = load i32, i32* %sq_flags, align 4
  %and = and i32 %6, -3
  store volatile i32 %and, i32* %sq_flags, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then21, %while.end
  br i1 %posted.0.off0.lcssa, label %if.then35, label %if.end40.critedge

if.then35:                                        ; preds = %if.end33
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup42

if.end40.critedge:                                ; preds = %if.end33
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup42

cleanup42:                                        ; preds = %if.then35, %if.end40.critedge, %land.lhs.true
  %retval.0 = phi i1 [ false, %land.lhs.true ], [ %tobool18, %if.end40.critedge ], [ %tobool18, %if.then35 ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_unregister_personality(%struct.io_ring_ctx* noundef %ctx, i32 noundef %id) unnamed_addr #1 {
entry:
  %personalities = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 16
  %conv = zext i32 %id to i64
  %call = call i8* @xa_erase(%struct.xarray* noundef %personalities, i64 noundef %conv) #27
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup, label %if.then

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %call to %struct.cred*
  call fastcc void @put_cred(%struct.cred* noundef nonnull %0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #15

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %list) unnamed_addr #9 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 0
  store volatile %struct.list_head* %list, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_ring_exit_work(%struct.work_struct* noundef %work) #1 {
entry:
  %exit = alloca %struct.io_tctx_exit, align 8
  %add.ptr = getelementptr %struct.work_struct, %struct.work_struct* %work, i64 -48, i32 2
  %0 = bitcast void (%struct.work_struct*)** %add.ptr to i8*
  %1 = bitcast void (%struct.work_struct*)** %add.ptr to %struct.io_ring_ctx*
  %2 = load volatile i64, i64* @jiffies, align 64
  %add = add i64 %2, 75000
  %3 = bitcast %struct.io_tctx_exit* %exit to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %3) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(56) %3, i8 0, i64 56, i1 false), !annotation !14
  %sq_data = getelementptr inbounds void (%struct.work_struct*)*, void (%struct.work_struct*)** %add.ptr, i64 116
  %4 = bitcast void (%struct.work_struct*)** %sq_data to %struct.io_sq_data**
  %ref_comp = getelementptr inbounds void (%struct.work_struct*)*, void (%struct.work_struct*)** %add.ptr, i64 195
  %5 = bitcast void (%struct.work_struct*)** %ref_comp to %struct.completion*
  br label %do.body1

do.body1:                                         ; preds = %if.end20, %entry
  %interval.0 = phi i64 [ 12, %entry ], [ %spec.select, %if.end20 ]
  call fastcc void @io_uring_try_cancel_requests(%struct.io_ring_ctx* noundef %1, %struct.task_struct* noundef null, i1 noundef true) #25
  %6 = load %struct.io_sq_data*, %struct.io_sq_data** %4, align 32
  %tobool.not = icmp eq %struct.io_sq_data* %6, null
  br i1 %tobool.not, label %if.end11, label %if.then

if.then:                                          ; preds = %do.body1
  call fastcc void @io_sq_thread_park(%struct.io_sq_data* noundef nonnull %6) #25
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %6, i64 0, i32 4
  %7 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool3.not = icmp eq %struct.task_struct* %7, null
  br i1 %tobool3.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %7, i64 0, i32 85
  %8 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool4.not = icmp eq %struct.io_uring_task* %8, null
  br i1 %tobool4.not, label %if.end, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %8, i64 0, i32 4
  %9 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool7.not = icmp eq %struct.io_wq* %9, null
  br i1 %tobool7.not, label %if.end, label %if.then8

if.then8:                                         ; preds = %land.lhs.true5
  %call = call i32 @io_wq_cancel_cb(%struct.io_wq* noundef nonnull %9, i1 (%struct.io_wq_work*, i8*)* noundef nonnull @io_cancel_ctx_cb, i8* noundef %0, i1 noundef true) #27
  br label %if.end

if.end:                                           ; preds = %if.then8, %land.lhs.true5, %land.lhs.true, %if.then
  call fastcc void @io_sq_thread_unpark(%struct.io_sq_data* noundef nonnull %6) #25
  br label %if.end11

if.end11:                                         ; preds = %if.end, %do.body1
  %10 = load volatile i64, i64* @jiffies, align 64
  %sub = sub i64 %add, %10
  %cmp = icmp slt i64 %sub, 0
  br i1 %cmp, label %if.then19, label %if.end20, !prof !24

if.then19:                                        ; preds = %if.end11
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9410; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !64
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end11
  %spec.select = phi i64 [ 15000, %if.then19 ], [ %interval.0, %if.end11 ]
  %call33 = call i64 @wait_for_completion_timeout(%struct.completion* noundef %5, i64 noundef %spec.select) #27
  %tobool34.not = icmp eq i64 %call33, 0
  br i1 %tobool34.not, label %do.body1, label %do.end37

do.end37:                                         ; preds = %if.end20
  %completion = getelementptr inbounds %struct.io_tctx_exit, %struct.io_tctx_exit* %exit, i64 0, i32 1
  call fastcc void @init_completion(%struct.completion* noundef %completion) #25
  %task_work = getelementptr inbounds %struct.io_tctx_exit, %struct.io_tctx_exit* %exit, i64 0, i32 0
  call fastcc void @init_task_work(%struct.callback_head* noundef nonnull %task_work, void (%struct.callback_head*)* noundef nonnull @io_tctx_exit_cb) #25
  %ctx38 = getelementptr inbounds %struct.io_tctx_exit, %struct.io_tctx_exit* %exit, i64 0, i32 2
  %11 = bitcast %struct.io_ring_ctx** %ctx38 to void (%struct.work_struct*)***
  store void (%struct.work_struct*)** %add.ptr, void (%struct.work_struct*)*** %11, align 8
  %12 = getelementptr inbounds void (%struct.work_struct*)*, void (%struct.work_struct*)** %add.ptr, i64 8
  %uring_lock = bitcast void (%struct.work_struct*)** %12 to %struct.mutex*
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %tctx_list = getelementptr inbounds void (%struct.work_struct*)*, void (%struct.work_struct*)** %add.ptr, i64 193
  %13 = bitcast void (%struct.work_struct*)** %tctx_list to %struct.list_head*
  %call39154 = call fastcc i32 @list_empty(%struct.list_head* noundef %13) #25
  %tobool40.not155 = icmp eq i32 %call39154, 0
  br i1 %tobool40.not155, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %do.end37
  %14 = bitcast void (%struct.work_struct*)** %tctx_list to %struct.io_tctx_node**
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %15 = load volatile i64, i64* @jiffies, align 64
  %sub44 = sub i64 %add, %15
  %cmp45 = icmp slt i64 %sub44, 0
  br i1 %cmp45, label %if.then59, label %if.end60, !prof !24

if.then59:                                        ; preds = %while.body
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9427; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !65
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %while.body
  %16 = load %struct.io_tctx_node*, %struct.io_tctx_node** %14, align 8
  call fastcc void @list_rotate_left(%struct.list_head* noundef %13) #25
  %task = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %16, i64 0, i32 1
  %17 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %call78 = call i32 @task_work_add(%struct.task_struct* noundef %17, %struct.callback_head* noundef nonnull %task_work, i32 noundef 2) #27
  %tobool80.not = icmp eq i32 %call78, 0
  br i1 %tobool80.not, label %if.end105, label %if.then93, !prof !8

if.then93:                                        ; preds = %if.end60
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9434; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !66
  br label %while.cond.backedge

if.end105:                                        ; preds = %if.end60
  %18 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %call107 = call i32 @wake_up_process(%struct.task_struct* noundef %18) #27
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  call void @wait_for_completion(%struct.completion* noundef %completion) #27
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end105, %if.then93
  %call39 = call fastcc i32 @list_empty(%struct.list_head* noundef %13) #25
  %tobool40.not = icmp eq i32 %call39, 0
  br i1 %tobool40.not, label %while.body, label %while.end

while.end:                                        ; preds = %while.cond.backedge, %do.end37
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %19 = getelementptr inbounds void (%struct.work_struct*)*, void (%struct.work_struct*)** %add.ptr, i64 144
  %rlock.i = bitcast void (%struct.work_struct*)** %19 to %struct.raw_spinlock*
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_ring_ctx_free(%struct.io_ring_ctx* noundef %1) #25
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %3) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @queue_work(%struct.workqueue_struct* noundef %wq, %struct.work_struct* noundef %work) unnamed_addr #1 {
entry:
  %call = call i1 @queue_work_on(i32 noundef 256, %struct.workqueue_struct* noundef %wq, %struct.work_struct* noundef %work) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_kill_and_confirm(%struct.percpu_ref* noundef, void (%struct.percpu_ref*)* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @memcpy(i8* noundef, i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @clear_bit(i64 noundef %nr, i64* noundef %addr) unnamed_addr #1 {
entry:
  %rem.i = and i64 %nr, 63
  %shl.i = shl nuw i64 1, %rem.i
  %0 = bitcast i64* %addr to %struct.atomic64_t*
  call fastcc void @__ll_sc_atomic64_andnot(i64 noundef %shl.i, %struct.atomic64_t* noundef %0) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic64_andnot(i64 noundef %i, %struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64 } asm sideeffect "// atomic64_andnot\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09bic\09$0, $0, $3\0A\09stxr\09${1:w}, $0, $2\0A\09cbnz\09${1:w}, 1b", "=&r,=&r,=*Q,r,*Q"(i64* elementtype(i64) %counter, i64 %i, i64* elementtype(i64) %counter) #26, !srcloc !67
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_sq_thread_park(%struct.io_sq_data* noundef %sqd) unnamed_addr #1 {
entry:
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 4
  %0 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %cmp = icmp eq %struct.task_struct* %0, %2
  br i1 %cmp, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7896; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !68
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %park_pending = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 1
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %park_pending) #27
  %state = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 10
  call fastcc void @set_bit(i64 noundef 1, i64* noundef %state) #25
  %lock = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 2
  call void @mutex_lock(%struct.mutex* noundef %lock) #27
  %3 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool15.not = icmp eq %struct.task_struct* %3, null
  br i1 %tobool15.not, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end
  %call18 = call i32 @wake_up_process(%struct.task_struct* noundef nonnull %3) #27
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_sq_thread_unpark(%struct.io_sq_data* noundef %sqd) unnamed_addr #1 {
entry:
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 4
  %0 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %cmp = icmp eq %struct.task_struct* %0, %2
  br i1 %cmp, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7881; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !69
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %state = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 10
  call fastcc void @clear_bit(i64 noundef 1, i64* noundef %state) #25
  %park_pending = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 1
  %call.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %park_pending) #27
  %tobool15.not = icmp eq i32 %call.i.i.i, 0
  br i1 %tobool15.not, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end
  call fastcc void @set_bit(i64 noundef 1, i64* noundef %state) #25
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end
  %lock = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 2
  call void @mutex_unlock(%struct.mutex* noundef %lock) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @wait_for_completion_timeout(%struct.completion* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @init_completion(%struct.completion* noundef %x) unnamed_addr #1 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i64 0, i32 0
  store i32 0, i32* %done, align 8
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i64 0, i32 1
  call void @__init_swait_queue_head(%struct.swait_queue_head* noundef %wait, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @init_completion.__key) #27
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @init_task_work(%struct.callback_head* nocapture noundef writeonly %twork, void (%struct.callback_head*)* noundef %func) unnamed_addr #10 {
entry:
  %func1 = getelementptr inbounds %struct.callback_head, %struct.callback_head* %twork, i64 0, i32 1
  store void (%struct.callback_head*)* %func, void (%struct.callback_head*)** %func1, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_tctx_exit_cb(%struct.callback_head* noundef %cb) #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %counter.i = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 7, i32 0
  %3 = load volatile i32, i32* %counter.i, align 4
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %ctx = getelementptr inbounds %struct.callback_head, %struct.callback_head* %cb, i64 3
  %4 = bitcast %struct.callback_head* %ctx to %struct.io_ring_ctx**
  %5 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %4, align 8
  %6 = ptrtoint %struct.io_ring_ctx* %5 to i64
  call fastcc void @io_uring_del_tctx_node(i64 noundef %6) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %completion = getelementptr inbounds %struct.callback_head, %struct.callback_head* %cb, i64 1
  %7 = bitcast %struct.callback_head* %completion to %struct.completion*
  call void @complete(%struct.completion* noundef %7) #27
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_rotate_left(%struct.list_head* noundef %head) unnamed_addr #9 {
entry:
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %head) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  call fastcc void @list_move_tail(%struct.list_head* noundef %0, %struct.list_head* noundef %head) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @wait_for_completion(%struct.completion* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_ctx_free(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  call fastcc void @io_sq_thread_finish(%struct.io_ring_ctx* noundef %ctx) #25
  %mm_account = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 2
  %0 = load %struct.mm_struct*, %struct.mm_struct** %mm_account, align 16
  %tobool.not = icmp eq %struct.mm_struct* %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @mmdrop(%struct.mm_struct* noundef nonnull %0) #25
  store %struct.mm_struct* null, %struct.mm_struct** %mm_account, align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %buf_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 3
  %1 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  call fastcc void @io_wait_rsrc_data(%struct.io_rsrc_data* noundef %1) #25
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 2
  %2 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  call fastcc void @io_wait_rsrc_data(%struct.io_rsrc_data* noundef %2) #25
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %3 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %tobool4.not = icmp eq %struct.io_rsrc_data* %3, null
  br i1 %tobool4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  call fastcc void @__io_sqe_buffers_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %4 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %tobool8.not = icmp eq %struct.io_rsrc_data* %4, null
  br i1 %tobool8.not, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  call fastcc void @__io_sqe_files_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end6
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %5 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %tobool11.not = icmp eq %struct.io_rings* %5, null
  br i1 %tobool11.not, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end10
  %call = call fastcc i1 @__io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx, i1 noundef true) #25
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %call15 = call fastcc i32 @io_eventfd_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_destroy_buffers(%struct.io_ring_ctx* noundef %ctx) #25
  %sq_creds = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 4
  %6 = load %struct.cred*, %struct.cred** %sq_creds, align 8
  %tobool16.not = icmp eq %struct.cred* %6, null
  br i1 %tobool16.not, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end13
  call fastcc void @put_cred(%struct.cred* noundef nonnull %6) #25
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end13
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 6
  %7 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %tobool20.not = icmp eq %struct.io_rsrc_node* %7, null
  br i1 %tobool20.not, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end19
  call fastcc void @io_rsrc_node_destroy(%struct.io_rsrc_node* noundef nonnull %7) #25
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %rsrc_backup_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 0
  %8 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  %tobool24.not = icmp eq %struct.io_rsrc_node* %8, null
  br i1 %tobool24.not, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end23
  call fastcc void @io_rsrc_node_destroy(%struct.io_rsrc_node* noundef nonnull %8) #25
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end23
  %rsrc_put_work = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 4
  %call28 = call i1 @flush_delayed_work(%struct.delayed_work* noundef %rsrc_put_work) #27
  %rsrc_ref_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 6
  %call29 = call fastcc i32 @list_empty(%struct.list_head* noundef %rsrc_ref_list) #25
  %tobool30.not = icmp eq i32 %call29, 0
  br i1 %tobool30.not, label %if.then39, label %if.end40, !prof !24

if.then39:                                        ; preds = %if.end27
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9283; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !70
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.end27
  %rsrc_put_llist = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 5
  %call49 = call fastcc i1 @llist_empty(%struct.llist_head* noundef %rsrc_put_llist) #25
  br i1 %call49, label %if.end65, label %if.then64, !prof !8

if.then64:                                        ; preds = %if.end40
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9284; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !71
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end40
  %ltimeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 13
  %call75 = call fastcc i32 @list_empty(%struct.list_head* noundef %ltimeout_list) #25
  %tobool76.not = icmp eq i32 %call75, 0
  br i1 %tobool76.not, label %if.then91, label %if.end92, !prof !24

if.then91:                                        ; preds = %if.end65
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9292; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !72
  br label %if.end92

if.end92:                                         ; preds = %if.then91, %if.end65
  %9 = bitcast %struct.io_rings** %rings to i8**
  %10 = load i8*, i8** %9, align 16
  call fastcc void @io_mem_free(i8* noundef %10) #25
  %sq_sqes = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 2
  %11 = bitcast %struct.io_uring_sqe** %sq_sqes to i8**
  %12 = load i8*, i8** %11, align 8
  call fastcc void @io_mem_free(i8* noundef %12) #25
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  call void @percpu_ref_exit(%struct.percpu_ref* noundef %refs) #27
  %user = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 1
  %13 = load %struct.user_struct*, %struct.user_struct** %user, align 8
  call void @free_uid(%struct.user_struct* noundef %13) #27
  call fastcc void @io_req_caches_free(%struct.io_ring_ctx* noundef %ctx) #25
  %hash_map = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 0
  %14 = load %struct.io_wq_hash*, %struct.io_wq_hash** %hash_map, align 16
  %tobool102.not = icmp eq %struct.io_wq_hash* %14, null
  br i1 %tobool102.not, label %if.end105, label %if.then103

if.then103:                                       ; preds = %if.end92
  call fastcc void @io_wq_put_hash(%struct.io_wq_hash* noundef nonnull %14) #25
  br label %if.end105

if.end105:                                        ; preds = %if.then103, %if.end92
  %cancel_hash = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 3
  %15 = bitcast %struct.hlist_head** %cancel_hash to i8**
  %16 = load i8*, i8** %15, align 8
  call void @kfree(i8* noundef %16) #27
  %dummy_ubuf = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 1
  %17 = bitcast %struct.io_mapped_ubuf** %dummy_ubuf to i8**
  %18 = load i8*, i8** %17, align 8
  call void @kfree(i8* noundef %18) #27
  %19 = bitcast %struct.io_ring_ctx* %ctx to i8*
  call void @kfree(i8* noundef %19) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__init_swait_queue_head(%struct.swait_queue_head* noundef, i8* noundef, %struct.lock_class_key* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_del_tctx_node(i64 noundef %index) unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %2, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %xa = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 1
  %call1 = call i8* @xa_erase(%struct.xarray* noundef %xa, i64 noundef %index) #27
  %tobool2.not = icmp eq i8* %call1, null
  br i1 %tobool2.not, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %task = getelementptr inbounds i8, i8* %call1, i64 16
  %3 = bitcast i8* %task to %struct.task_struct**
  %4 = load %struct.task_struct*, %struct.task_struct** %3, align 8
  %cmp.not = icmp eq %struct.task_struct* %4, %1
  br i1 %cmp.not, label %if.end14, label %if.then13, !prof !8

if.then13:                                        ; preds = %if.end4
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9697; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !73
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end4
  %ctx_node = bitcast i8* %call1 to %struct.list_head*
  %call23 = call fastcc i32 @list_empty(%struct.list_head* noundef nonnull %ctx_node) #25
  %tobool24.not = icmp eq i32 %call23, 0
  br i1 %tobool24.not, label %if.end38, label %if.then37, !prof !8

if.then37:                                        ; preds = %if.end14
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9698; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !74
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end14
  %ctx = getelementptr inbounds i8, i8* %call1, i64 24
  %5 = bitcast i8* %ctx to %struct.io_ring_ctx**
  %6 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %5, align 8
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %6, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  call fastcc void @list_del(%struct.list_head* noundef nonnull %ctx_node) #25
  %7 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %5, align 8
  %uring_lock49 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %7, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock49) #27
  %last = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 3
  %8 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %last, align 8
  %9 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %5, align 8
  %cmp51 = icmp eq %struct.io_ring_ctx* %8, %9
  br i1 %cmp51, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end38
  store %struct.io_ring_ctx* null, %struct.io_ring_ctx** %last, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end38
  call void @kfree(i8* noundef nonnull %call1) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end55
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @complete(%struct.completion* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_sq_thread_finish(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %0 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool.not = icmp eq %struct.io_sq_data* %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_sq_thread_park(%struct.io_sq_data* noundef nonnull %0) #25
  %sqd_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 7
  call fastcc void @list_del_init(%struct.list_head* noundef %sqd_list) #25
  call fastcc void @io_sqd_update_thread_idle(%struct.io_sq_data* noundef nonnull %0) #25
  call fastcc void @io_sq_thread_unpark(%struct.io_sq_data* noundef nonnull %0) #25
  call fastcc void @io_put_sq_data(%struct.io_sq_data* noundef nonnull %0) #25
  store %struct.io_sq_data* null, %struct.io_sq_data** %sq_data, align 32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @mmdrop(%struct.mm_struct* noundef %mm) unnamed_addr #1 {
entry:
  %mm_count = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %mm, i64 0, i32 0, i32 11
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %mm_count) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.i.i, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void @__mmdrop(%struct.mm_struct* noundef %mm) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_wait_rsrc_data(%struct.io_rsrc_data* noundef %data) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.io_rsrc_data* %data, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %refs = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 4
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %refs) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.i.i, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %done = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 5
  call void @wait_for_completion(%struct.completion* noundef %done) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_sqe_buffers_unregister(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #1 {
entry:
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  %0 = load i32, i32* %nr_user_bufs, align 4
  %cmp15.not = icmp eq i32 %0, 0
  br i1 %cmp15.not, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %1 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %arrayidx = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %1, i64 %indvars.iv
  call fastcc void @io_buffer_unmap(%struct.io_ring_ctx* noundef %ctx, %struct.io_mapped_ubuf** noundef %arrayidx) #25
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %2 = load i32, i32* %nr_user_bufs, align 4
  %3 = zext i32 %2 to i64
  %cmp = icmp ult i64 %indvars.iv.next, %3
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %user_bufs1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  %4 = bitcast %struct.io_mapped_ubuf*** %user_bufs1 to i8**
  %5 = load i8*, i8** %4, align 32
  call void @kfree(i8* noundef %5) #27
  %buf_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 3
  %6 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  call fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef %6) #25
  store %struct.io_mapped_ubuf** null, %struct.io_mapped_ubuf*** %user_bufs1, align 32
  store %struct.io_rsrc_data* null, %struct.io_rsrc_data** %buf_data, align 8
  store i32 0, i32* %nr_user_bufs, align 4
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_sqe_files_unregister(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #1 {
entry:
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 8
  %0 = load i32, i32* %nr_user_files, align 8
  %cmp13.not = icmp eq i32 %0, 0
  br i1 %cmp13.not, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %if.end
  %1 = phi i32 [ %2, %if.end ], [ %0, %entry ]
  %i.014 = phi i32 [ %inc, %if.end ], [ 0, %entry ]
  %call = call fastcc %struct.file* @io_file_from_index(%struct.io_ring_ctx* noundef %ctx, i32 noundef %i.014) #25
  %tobool.not = icmp eq %struct.file* %call, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  call void @fput(%struct.file* noundef nonnull %call) #27
  %.pre = load i32, i32* %nr_user_files, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %2 = phi i32 [ %.pre, %if.then ], [ %1, %for.body ]
  %inc = add nuw i32 %i.014, 1
  %cmp = icmp ult i32 %inc, %2
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end, %entry
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 7
  call fastcc void @io_free_file_tables(%struct.io_file_table* noundef %file_table) #25
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 2
  %3 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  call fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef %3) #25
  store %struct.io_rsrc_data* null, %struct.io_rsrc_data** %file_data, align 8
  store i32 0, i32* %nr_user_files, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_eventfd_unregister(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #1 {
entry:
  %cq_ev_fd = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 2
  %0 = load %struct.eventfd_ctx*, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %tobool.not = icmp eq %struct.eventfd_ctx* %0, null
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  call void @eventfd_ctx_put(%struct.eventfd_ctx* noundef nonnull %0) #27
  store %struct.eventfd_ctx* null, %struct.eventfd_ctx** %cq_ev_fd, align 8
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ -6, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_destroy_buffers(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %index = alloca i64, align 8
  %0 = bitcast i64* %index to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64 0, i64* %index, align 8
  %io_buffers = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 15
  %call = call i8* @xa_find(%struct.xarray* noundef %io_buffers, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool.not9 = icmp eq i8* %call, null
  br i1 %tobool.not9, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %buf.0.in10 = phi i8* [ %call4, %for.body ], [ %call, %entry ]
  %buf.0 = bitcast i8* %buf.0.in10 to %struct.io_buffer*
  %1 = load i64, i64* %index, align 8
  %conv = trunc i64 %1 to i32
  %call1 = call fastcc i32 @__io_remove_buffers(%struct.io_ring_ctx* noundef %ctx, %struct.io_buffer* noundef nonnull %buf.0, i32 noundef %conv, i32 noundef -1) #25
  call fastcc void @_cond_resched() #25
  %call4 = call i8* @xa_find_after(%struct.xarray* noundef %io_buffers, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool.not = icmp eq i8* %call4, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_rsrc_node_destroy(%struct.io_rsrc_node* noundef %ref_node) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %ref_node, i64 0, i32 0
  call void @percpu_ref_exit(%struct.percpu_ref* noundef %refs) #27
  %0 = bitcast %struct.io_rsrc_node* %ref_node to i8*
  call void @kfree(i8* noundef %0) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @flush_delayed_work(%struct.delayed_work* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @llist_empty(%struct.llist_head* noundef %head) unnamed_addr #8 {
entry:
  %first = getelementptr inbounds %struct.llist_head, %struct.llist_head* %head, i64 0, i32 0
  %0 = load volatile %struct.llist_node*, %struct.llist_node** %first, align 8
  %cmp = icmp eq %struct.llist_node* %0, null
  ret i1 %cmp
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_mem_free(i8* noundef %ptr) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq i8* %ptr, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call fastcc %struct.page* @virt_to_head_page(i8* noundef nonnull %ptr) #25
  %call1 = call fastcc i32 @put_page_testzero(%struct.page* noundef %call) #25
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %cleanup, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @free_compound_page(%struct.page* noundef %call) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then3, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_exit(%struct.percpu_ref* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @free_uid(%struct.user_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_caches_free(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %free_reqs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 3
  %0 = load i32, i32* %free_reqs, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.kmem_cache*, %struct.kmem_cache** @req_cachep, align 8
  %conv = zext i32 %0 to i64
  %arraydecay = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 2, i64 0
  call void @kmem_cache_free_bulk(%struct.kmem_cache* noundef %1, i64 noundef %conv, i8** noundef %arraydecay) #27
  store i32 0, i32* %free_reqs, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %submit_state = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11
  call fastcc void @io_flush_cached_locked_reqs(%struct.io_ring_ctx* noundef %ctx, %struct.io_submit_state* noundef %submit_state) #25
  %free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 7
  call fastcc void @io_req_cache_free(%struct.list_head* noundef %free_list) #25
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_wq_put_hash(%struct.io_wq_hash* noundef %hash) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.io_wq_hash, %struct.io_wq_hash* %hash, i64 0, i32 0
  %call = call fastcc i1 @refcount_dec_and_test(%struct.refcount_struct* noundef %refs) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.io_wq_hash* %hash to i8*
  call void @kfree(i8* noundef %0) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_del_init(%struct.list_head* noundef %entry1) unnamed_addr #9 {
entry:
  call fastcc void @__list_del_entry(%struct.list_head* noundef %entry1) #25
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %entry1) #25
  ret void
}

; Function Attrs: nofree noinline norecurse nosync nounwind null_pointer_is_valid
define internal fastcc void @io_sqd_update_thread_idle(%struct.io_sq_data* noundef %sqd) unnamed_addr #16 {
entry:
  %ctx_list = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 3
  %0 = bitcast %struct.list_head* %ctx_list to i8**
  %.pn27 = load i8*, i8** %0, align 8
  %1 = bitcast i8* %.pn27 to %struct.list_head*
  %cmp.not28 = icmp eq %struct.list_head* %ctx_list, %1
  br i1 %cmp.not28, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %.pn30 = phi i8* [ %.pn, %for.body ], [ %.pn27, %entry ]
  %sq_thread_idle.029 = phi i32 [ %cond, %for.body ], [ 0, %entry ]
  %sq_thread_idle2 = getelementptr i8, i8* %.pn30, i64 -100
  %2 = bitcast i8* %sq_thread_idle2 to i32*
  %3 = load i32, i32* %2, align 4
  %cmp4 = icmp ugt i32 %sq_thread_idle.029, %3
  %cond = select i1 %cmp4, i32 %sq_thread_idle.029, i32 %3
  %4 = bitcast i8* %.pn30 to i8**
  %.pn = load i8*, i8** %4, align 8
  %5 = bitcast i8* %.pn to %struct.list_head*
  %cmp.not = icmp eq %struct.list_head* %ctx_list, %5
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %sq_thread_idle.0.lcssa = phi i32 [ 0, %entry ], [ %cond, %for.body ]
  %sq_thread_idle13 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 6
  store i32 %sq_thread_idle.0.lcssa, i32* %sq_thread_idle13, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_put_sq_data(%struct.io_sq_data* noundef %sqd) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 0
  %call = call fastcc i1 @refcount_dec_and_test(%struct.refcount_struct* noundef %refs) #25
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %counter.i = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 1, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then9, !prof !8

if.then9:                                         ; preds = %if.then
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7921; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !75
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  call fastcc void @io_sq_thread_stop(%struct.io_sq_data* noundef %sqd) #25
  %1 = bitcast %struct.io_sq_data* %sqd to i8*
  call void @kfree(i8* noundef %1) #27
  br label %if.end17

if.end17:                                         ; preds = %if.end, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @refcount_dec_and_test(%struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__refcount_dec_and_test(%struct.refcount_struct* noundef %r) #25
  ret i1 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_sq_thread_stop(%struct.io_sq_data* noundef %sqd) unnamed_addr #1 {
entry:
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 4
  %0 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %cmp = icmp eq %struct.task_struct* %0, %2
  br i1 %cmp, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7907; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !76
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %state = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 10
  %3 = load volatile i64, i64* %state, align 8
  %conv.i58 = and i64 %3, 1
  %tobool16.not = icmp eq i64 %conv.i58, 0
  br i1 %tobool16.not, label %if.end30, label %if.then29, !prof !8

if.then29:                                        ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7908; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !77
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end
  call fastcc void @set_bit(i64 noundef 0, i64* noundef %state) #25
  %lock = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 2
  call void @mutex_lock(%struct.mutex* noundef %lock) #27
  %4 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool41.not = icmp eq %struct.task_struct* %4, null
  br i1 %tobool41.not, label %if.end45, label %if.then42

if.then42:                                        ; preds = %if.end30
  %call44 = call i32 @wake_up_process(%struct.task_struct* noundef nonnull %4) #27
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end30
  call void @mutex_unlock(%struct.mutex* noundef %lock) #27
  %exited = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 11
  call void @wait_for_completion(%struct.completion* noundef %exited) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__refcount_dec_and_test(%struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__refcount_sub_and_test(i32 noundef 1, %struct.refcount_struct* noundef %r) #25
  ret i1 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mmdrop(%struct.mm_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_buffer_unmap(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.io_mapped_ubuf** nocapture noundef %slot) unnamed_addr #1 {
entry:
  %0 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %slot, align 8
  %dummy_ubuf = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 1
  %1 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %dummy_ubuf, align 8
  %cmp.not = icmp eq %struct.io_mapped_ubuf* %0, %1
  br i1 %cmp.not, label %if.end4, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %nr_bvecs = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %0, i64 0, i32 2
  %2 = load i32, i32* %nr_bvecs, align 8
  %cmp117.not = icmp eq i32 %2, 0
  br i1 %cmp117.not, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
  %bv_page = getelementptr %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %0, i64 0, i32 4, i64 %indvars.iv, i32 0
  %3 = load %struct.page*, %struct.page** %bv_page, align 8
  call void @unpin_user_page(%struct.page* noundef %3) #27
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %4 = load i32, i32* %nr_bvecs, align 8
  %5 = zext i32 %4 to i64
  %cmp1 = icmp ult i64 %indvars.iv.next, %5
  br i1 %cmp1, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %acct_pages = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %0, i64 0, i32 3
  %6 = load i64, i64* %acct_pages, align 8
  %tobool.not = icmp eq i64 %6, 0
  br i1 %tobool.not, label %if.end, label %if.then2

if.then2:                                         ; preds = %for.end
  call fastcc void @io_unaccount_mem(%struct.io_ring_ctx* noundef %ctx, i64 noundef %6) #25
  br label %if.end

if.end:                                           ; preds = %if.then2, %for.end
  %7 = bitcast %struct.io_mapped_ubuf* %0 to i8*
  call void @kvfree(i8* noundef %7) #27
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %slot, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef %data) unnamed_addr #1 {
entry:
  %tags = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 1
  %0 = load i64**, i64*** %tags, align 8
  %tobool.not = icmp eq i64** %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %nr = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 2
  %1 = load i32, i32* %nr, align 8
  %conv = zext i32 %1 to i64
  %mul = shl nuw nsw i64 %conv, 3
  %2 = bitcast i64** %0 to i8**
  call fastcc void @io_free_page_table(i8** noundef nonnull %2, i64 noundef %mul) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = bitcast %struct.io_rsrc_data* %data to i8*
  call void @kfree(i8* noundef %3) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @unpin_user_page(%struct.page* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_unaccount_mem(%struct.io_ring_ctx* nocapture noundef readonly %ctx, i64 noundef %nr_pages) unnamed_addr #1 {
entry:
  %user = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 1
  %0 = load %struct.user_struct*, %struct.user_struct** %user, align 8
  %tobool.not = icmp eq %struct.user_struct* %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @__io_unaccount_mem(%struct.user_struct* noundef nonnull %0, i64 noundef %nr_pages) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mm_account = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 2
  %1 = load %struct.mm_struct*, %struct.mm_struct** %mm_account, align 16
  %tobool2.not = icmp eq %struct.mm_struct* %1, null
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %pinned_vm = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %1, i64 0, i32 0, i32 21
  call fastcc void @__ll_sc_atomic64_sub(i64 noundef %nr_pages, %struct.atomic64_t* noundef %pinned_vm) #27
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kvfree(i8* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_unaccount_mem(%struct.user_struct* noundef %user, i64 noundef %nr_pages) unnamed_addr #1 {
entry:
  %locked_vm = getelementptr inbounds %struct.user_struct, %struct.user_struct* %user, i64 0, i32 6
  call fastcc void @__ll_sc_atomic64_sub(i64 noundef %nr_pages, %struct.atomic64_t* noundef %locked_vm) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic64_sub(i64 noundef %i, %struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64 } asm sideeffect "// atomic64_sub\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09sub\09$0, $0, $3\0A\09stxr\09${1:w}, $0, $2\0A\09cbnz\09${1:w}, 1b", "=&r,=&r,=*Q,Jr,*Q"(i64* elementtype(i64) %counter, i64 %i, i64* elementtype(i64) %counter) #26, !srcloc !78
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_free_page_table(i8** noundef %table, i64 noundef %size) unnamed_addr #1 {
entry:
  %sub = add i64 %size, 4095
  %div = lshr i64 %sub, 12
  %conv = trunc i64 %div to i32
  %cmp7.not = icmp eq i32 %conv, 0
  br i1 %cmp7.not, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = and i64 %div, 4294967295
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr i8*, i8** %table, i64 %indvars.iv
  %0 = load i8*, i8** %arrayidx, align 8
  call void @kfree(i8* noundef %0) #27
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %1 = bitcast i8** %table to i8*
  call void @kfree(i8* noundef %1) #27
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.file* @io_file_from_index(%struct.io_ring_ctx* nocapture noundef readonly %ctx, i32 noundef %index) unnamed_addr #3 {
entry:
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 7
  %call = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %index) #25
  %file_ptr = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %call, i64 0, i32 0
  %0 = load i64, i64* %file_ptr, align 8
  %and = and i64 %0, -8
  %1 = inttoptr i64 %and to %struct.file*
  ret %struct.file* %1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_free_file_tables(%struct.io_file_table* nocapture noundef %table) unnamed_addr #1 {
entry:
  %files = getelementptr inbounds %struct.io_file_table, %struct.io_file_table* %table, i64 0, i32 0
  %0 = bitcast %struct.io_file_table* %table to i8**
  %1 = load i8*, i8** %0, align 8
  call void @kvfree(i8* noundef %1) #27
  store %struct.io_fixed_file* null, %struct.io_fixed_file** %files, align 8
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* nocapture noundef readonly %table, i32 noundef %i) unnamed_addr #3 {
entry:
  %files = getelementptr inbounds %struct.io_file_table, %struct.io_file_table* %table, i64 0, i32 0
  %0 = load %struct.io_fixed_file*, %struct.io_fixed_file** %files, align 8
  %idxprom = zext i32 %i to i64
  %arrayidx = getelementptr %struct.io_fixed_file, %struct.io_fixed_file* %0, i64 %idxprom
  ret %struct.io_fixed_file* %arrayidx
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @eventfd_ctx_put(%struct.eventfd_ctx* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_remove_buffers(%struct.io_ring_ctx* noundef %ctx, %struct.io_buffer* noundef %buf, i32 noundef %bgid, i32 noundef %nbufs) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq i32 %nbufs, 0
  br i1 %tobool.not, label %cleanup8, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  %list = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %buf, i64 0, i32 0
  %0 = bitcast %struct.io_buffer* %buf to i8**
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %while.body
  %i.0 = phi i32 [ %inc, %while.body ], [ 0, %while.cond.preheader ]
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %list) #25
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8*, i8** %0, align 8
  %list3 = bitcast i8* %1 to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %list3) #25
  call void @kfree(i8* noundef %1) #27
  %inc = add nuw i32 %i.0, 1
  %cmp = icmp eq i32 %inc, %nbufs
  br i1 %cmp, label %cleanup8, label %while.cond

while.end:                                        ; preds = %while.cond
  %inc6 = add i32 %i.0, 1
  %2 = bitcast %struct.io_buffer* %buf to i8*
  call void @kfree(i8* noundef %2) #27
  %io_buffers = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 15
  %conv = sext i32 %bgid to i64
  %call7 = call i8* @xa_erase(%struct.xarray* noundef %io_buffers, i64 noundef %conv) #27
  br label %cleanup8

cleanup8:                                         ; preds = %while.body, %entry, %while.end
  %retval.2 = phi i32 [ %inc6, %while.end ], [ 0, %entry ], [ %nbufs, %while.body ]
  ret i32 %retval.2
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @put_page_testzero(%struct.page* noundef %page) unnamed_addr #1 {
entry:
  %call = call fastcc i32 @page_ref_dec_and_test(%struct.page* noundef %page) #25
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @free_compound_page(%struct.page* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @page_ref_dec_and_test(%struct.page* noundef %page) unnamed_addr #1 {
entry:
  %_refcount = getelementptr inbounds %struct.page, %struct.page* %page, i64 0, i32 3
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %_refcount) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  %conv = zext i1 %cmp.i.i to i32
  ret i32 %conv
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kmem_cache_free_bulk(%struct.kmem_cache* noundef, i64 noundef, i8** noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_flush_cached_locked_reqs(%struct.io_ring_ctx* noundef %ctx, %struct.io_submit_state* noundef %state) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %locked_free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 2
  %free_list = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 7
  call fastcc void @list_splice_init(%struct.list_head* noundef %locked_free_list, %struct.list_head* noundef %free_list) #25
  %locked_free_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 3
  store i32 0, i32* %locked_free_nr, align 16
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_cache_free(%struct.list_head* noundef readonly %list) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.list_head* %list to i8**
  %1 = load i8*, i8** %0, align 8
  %2 = bitcast i8* %1 to %struct.list_head*
  %cmp.not29 = icmp eq %struct.list_head* %2, %list
  br i1 %cmp.not29, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %3 = phi %struct.list_head* [ %5, %for.body ], [ %2, %entry ]
  %.pn.in.in30 = phi i8* [ %.pn, %for.body ], [ %1, %entry ]
  %req.0.in = getelementptr i8, i8* %.pn.in.in30, i64 -128
  %.pn.in = bitcast i8* %.pn.in.in30 to i8**
  %.pn = load i8*, i8** %.pn.in, align 8
  call fastcc void @list_del(%struct.list_head* noundef %3) #25
  %4 = load %struct.kmem_cache*, %struct.kmem_cache** @req_cachep, align 8
  call void @kmem_cache_free(%struct.kmem_cache* noundef %4, i8* noundef %req.0.in) #27
  %5 = bitcast i8* %.pn to %struct.list_head*
  %cmp.not = icmp eq %struct.list_head* %5, %list
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_splice_init(%struct.list_head* noundef %list, %struct.list_head* noundef %head) unnamed_addr #9 {
entry:
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %list) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  call fastcc void @__list_splice(%struct.list_head* noundef %list, %struct.list_head* noundef %head, %struct.list_head* noundef %0) #25
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %list) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @__list_splice(%struct.list_head* nocapture noundef readonly %list, %struct.list_head* noundef %prev, %struct.list_head* noundef %next) unnamed_addr #12 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i64 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i64 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i64 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i64 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kmem_cache_free(%struct.kmem_cache* noundef, i8* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @queue_work_on(i32 noundef, %struct.workqueue_struct* noundef, %struct.work_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_uring_show_fdinfo(%struct.io_ring_ctx* noundef %ctx, %struct.seq_file* noundef %m) unnamed_addr #1 {
entry:
  %index = alloca i64, align 8
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  %call = call i32 @mutex_trylock(%struct.mutex* noundef %uring_lock) #27
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %cond.end14.critedge, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 2
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %cond.end14.critedge, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %1 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %1, i64 0, i32 4
  %2 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool3.not = icmp eq %struct.task_struct* %2, null
  %tobool6.not = icmp eq %struct.io_sq_data* %1, null
  %or.cond = select i1 %tobool3.not, i1 true, i1 %tobool6.not
  br i1 %or.cond, label %cond.end14.critedge, label %cond.true

cond.true:                                        ; preds = %if.then
  %call8 = call fastcc i32 @task_pid_nr(%struct.task_struct* noundef nonnull %2) #25
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.3, i64 0, i64 0), i32 noundef %call8) #27
  %3 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %call12 = call fastcc i32 @task_cpu(%struct.task_struct* noundef %3) #25
  br label %cond.end14

cond.end14.critedge:                              ; preds = %if.then, %entry, %land.lhs.true
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.3, i64 0, i64 0), i32 noundef -1) #27
  br label %cond.end14

cond.end14:                                       ; preds = %cond.end14.critedge, %cond.true
  %cond15 = phi i32 [ %call12, %cond.true ], [ -1, %cond.end14.critedge ]
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.4, i64 0, i64 0), i32 noundef %cond15) #27
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 8
  %4 = load i32, i32* %nr_user_files, align 8
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.5, i64 0, i64 0), i32 noundef %4) #27
  br i1 %tobool.not, label %for.end.thread, label %land.rhs.preheader

land.rhs.preheader:                               ; preds = %cond.end14
  %5 = load i32, i32* %nr_user_files, align 8
  %cmp177.not = icmp eq i32 %5, 0
  br i1 %cmp177.not, label %for.end, label %for.body

for.end.thread:                                   ; preds = %cond.end14
  %nr_user_bufs176 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  %6 = load i32, i32* %nr_user_bufs176, align 4
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8, i64 0, i64 0), i32 noundef %6) #27
  br label %if.end50

for.body:                                         ; preds = %land.rhs.preheader, %if.end22
  %i.0167178 = phi i32 [ %inc, %if.end22 ], [ 0, %land.rhs.preheader ]
  %call18 = call fastcc %struct.file* @io_file_from_index(%struct.io_ring_ctx* noundef %ctx, i32 noundef %i.0167178) #25
  %tobool19.not = icmp eq %struct.file* %call18, null
  br i1 %tobool19.not, label %if.else, label %if.then20

if.then20:                                        ; preds = %for.body
  %call21 = call fastcc %struct.dentry* @file_dentry(%struct.file* noundef nonnull %call18) #25
  %arraydecay = getelementptr inbounds %struct.dentry, %struct.dentry* %call21, i64 0, i32 6, i64 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.6, i64 0, i64 0), i32 noundef %i.0167178, i8* noundef %arraydecay) #27
  br label %if.end22

if.else:                                          ; preds = %for.body
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i64 0, i64 0), i32 noundef %i.0167178) #27
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20
  %inc = add nuw i32 %i.0167178, 1
  %7 = load i32, i32* %nr_user_files, align 8
  %cmp = icmp ult i32 %inc, %7
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end22, %land.rhs.preheader
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  %8 = load i32, i32* %nr_user_bufs, align 4
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8, i64 0, i64 0), i32 noundef %8) #27
  br i1 %tobool.not, label %if.end50, label %land.rhs25.lr.ph

land.rhs25.lr.ph:                                 ; preds = %for.end
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  %9 = load i32, i32* %nr_user_bufs, align 4
  %cmp27179.not = icmp eq i32 %9, 0
  br i1 %cmp27179.not, label %land.lhs.true36, label %for.body29

for.body29:                                       ; preds = %land.rhs25.lr.ph, %for.body29
  %i.1169180 = phi i32 [ %inc32, %for.body29 ], [ 0, %land.rhs25.lr.ph ]
  %10 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %idxprom = sext i32 %i.1169180 to i64
  %arrayidx = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %10, i64 %idxprom
  %11 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %arrayidx, align 8
  %ubuf_end = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %11, i64 0, i32 1
  %12 = load i64, i64* %ubuf_end, align 8
  %ubuf = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %11, i64 0, i32 0
  %13 = load i64, i64* %ubuf, align 8
  %sub = sub i64 %12, %13
  %conv = trunc i64 %sub to i32
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9, i64 0, i64 0), i32 noundef %i.1169180, i64 noundef %13, i32 noundef %conv) #27
  %inc32 = add nuw i32 %i.1169180, 1
  %14 = load i32, i32* %nr_user_bufs, align 4
  %cmp27 = icmp ult i32 %inc32, %14
  br i1 %cmp27, label %for.body29, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %for.body29, %land.rhs25.lr.ph
  %personalities = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 16
  %call37 = call fastcc i1 @xa_empty(%struct.xarray* noundef %personalities) #25
  br i1 %call37, label %if.end50, label %if.then38

if.then38:                                        ; preds = %land.lhs.true36
  %15 = bitcast i64* %index to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %15) #26
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.10, i64 0, i64 0)) #27
  store i64 0, i64* %index, align 8
  %call40 = call i8* @xa_find(%struct.xarray* noundef %personalities, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool42.not170 = icmp eq i8* %call40, null
  br i1 %tobool42.not170, label %for.end49, label %for.body43

for.body43:                                       ; preds = %if.then38, %for.body43
  %cred.0.in171 = phi i8* [ %call48, %for.body43 ], [ %call40, %if.then38 ]
  %cred.0 = bitcast i8* %cred.0.in171 to %struct.cred*
  %16 = load i64, i64* %index, align 8
  %conv44 = trunc i64 %16 to i32
  call fastcc void @io_uring_show_cred(%struct.seq_file* noundef %m, i32 noundef %conv44, %struct.cred* noundef nonnull %cred.0) #25
  %call48 = call i8* @xa_find_after(%struct.xarray* noundef %personalities, i64* noundef nonnull %index, i64 noundef -1, i32 noundef 8) #27
  %tobool42.not = icmp eq i8* %call48, null
  br i1 %tobool42.not, label %for.end49, label %for.body43

for.end49:                                        ; preds = %for.body43, %if.then38
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %15) #26
  br label %if.end50

if.end50:                                         ; preds = %for.end.thread, %for.end, %for.end49, %land.lhs.true36
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.11, i64 0, i64 0)) #27
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %cancel_hash_bits = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 4
  %cancel_hash = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 3
  br label %for.body54

for.body54:                                       ; preds = %if.end50, %for.end83
  %i.2174 = phi i32 [ 0, %if.end50 ], [ %inc85, %for.end83 ]
  %17 = load %struct.hlist_head*, %struct.hlist_head** %cancel_hash, align 8
  %idxprom55 = sext i32 %i.2174 to i64
  %first = getelementptr %struct.hlist_head, %struct.hlist_head* %17, i64 %idxprom55, i32 0
  %18 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8
  %tobool57.not = icmp eq %struct.hlist_node* %18, null
  %add.ptr160 = getelementptr %struct.hlist_node, %struct.hlist_node* %18, i64 -10
  %tobool64.not172175 = icmp eq %struct.hlist_node* %add.ptr160, null
  %tobool64.not172 = or i1 %tobool57.not, %tobool64.not172175
  br i1 %tobool64.not172, label %for.end83, label %for.body65.preheader

for.body65.preheader:                             ; preds = %for.body54
  %19 = bitcast %struct.hlist_node* %add.ptr160 to %struct.io_kiocb*
  br label %for.body65

for.body65:                                       ; preds = %for.body65.preheader, %for.body65
  %req.0173 = phi %struct.io_kiocb* [ %spec.select166, %for.body65 ], [ %19, %for.body65.preheader ]
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.0173, i64 0, i32 2
  %20 = load i8, i8* %opcode, align 8
  %conv66 = zext i8 %20 to i32
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.0173, i64 0, i32 9
  %21 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %task_works = getelementptr inbounds %struct.task_struct, %struct.task_struct* %21, i64 0, i32 96
  %22 = load %struct.callback_head*, %struct.callback_head** %task_works, align 32
  %cmp67 = icmp ne %struct.callback_head* %22, null
  %conv68 = zext i1 %cmp67 to i32
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.12, i64 0, i64 0), i32 noundef %conv66, i32 noundef %conv68) #27
  %next = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.0173, i64 0, i32 15, i32 0
  %23 = load %struct.hlist_node*, %struct.hlist_node** %next, align 8
  %tobool72.not = icmp eq %struct.hlist_node* %23, null
  %add.ptr79159 = getelementptr %struct.hlist_node, %struct.hlist_node* %23, i64 -10
  %24 = bitcast %struct.hlist_node* %add.ptr79159 to %struct.io_kiocb*
  %spec.select166 = select i1 %tobool72.not, %struct.io_kiocb* null, %struct.io_kiocb* %24
  %tobool64.not = icmp eq %struct.io_kiocb* %spec.select166, null
  br i1 %tobool64.not, label %for.end83, label %for.body65

for.end83:                                        ; preds = %for.body65, %for.body54
  %inc85 = add i32 %i.2174, 1
  %25 = load i32, i32* %cancel_hash_bits, align 32
  %i.2.highbits = lshr i32 %inc85, %25
  %cmp52 = icmp eq i32 %i.2.highbits, 0
  br i1 %cmp52, label %for.body54, label %for.end86

for.end86:                                        ; preds = %for.end83
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br i1 %tobool.not, label %if.end91, label %if.then89

if.then89:                                        ; preds = %for.end86
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end91

if.end91:                                         ; preds = %if.then89, %for.end86
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @mutex_trylock(%struct.mutex* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_printf(%struct.seq_file* noundef, i8* noundef, ...) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @task_pid_nr(%struct.task_struct* nocapture noundef readonly %tsk) unnamed_addr #3 {
entry:
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i64 0, i32 50
  %0 = load i32, i32* %pid, align 32
  ret i32 %0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @task_cpu(%struct.task_struct* noundef %p) unnamed_addr #8 {
entry:
  %cpu = getelementptr inbounds %struct.task_struct, %struct.task_struct* %p, i64 0, i32 8
  %0 = load volatile i32, i32* %cpu, align 64
  ret i32 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.dentry* @file_dentry(%struct.file* nocapture noundef readonly %file) unnamed_addr #1 {
entry:
  %dentry = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 1, i32 1
  %0 = load %struct.dentry*, %struct.dentry** %dentry, align 8
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %file) #25
  %call1 = call fastcc %struct.dentry* @d_real(%struct.dentry* noundef %0, %struct.inode* noundef %call) #25
  ret %struct.dentry* %call1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_uring_show_cred(%struct.seq_file* noundef %m, i32 noundef %id, %struct.cred* nocapture noundef readonly %cred) unnamed_addr #1 {
entry:
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i64 0, i64 0), i32 noundef %id) #27
  %coerce.dive = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 1, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %coerce.val.ii = zext i32 %0 to i64
  %call1 = call fastcc i32 @from_kuid_munged(i64 %coerce.val.ii) #25
  %conv = zext i32 %call1 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14, i64 0, i64 0), i64 noundef %conv) #27
  %coerce.dive2 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 5, i32 0
  %1 = load i32, i32* %coerce.dive2, align 4
  %coerce.val.ii3 = zext i32 %1 to i64
  %call4 = call fastcc i32 @from_kuid_munged(i64 %coerce.val.ii3) #25
  %conv5 = zext i32 %call4 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv5) #27
  %coerce.dive6 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 3, i32 0
  %2 = load i32, i32* %coerce.dive6, align 4
  %coerce.val.ii7 = zext i32 %2 to i64
  %call8 = call fastcc i32 @from_kuid_munged(i64 %coerce.val.ii7) #25
  %conv9 = zext i32 %call8 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv9) #27
  %coerce.dive10 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 7, i32 0
  %3 = load i32, i32* %coerce.dive10, align 4
  %coerce.val.ii11 = zext i32 %3 to i64
  %call12 = call fastcc i32 @from_kuid_munged(i64 %coerce.val.ii11) #25
  %conv13 = zext i32 %call12 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv13) #27
  %coerce.dive14 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 2, i32 0
  %4 = load i32, i32* %coerce.dive14, align 8
  %coerce.val.ii15 = zext i32 %4 to i64
  %call16 = call fastcc i32 @from_kgid_munged(i64 %coerce.val.ii15) #25
  %conv17 = zext i32 %call16 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.16, i64 0, i64 0), i64 noundef %conv17) #27
  %coerce.dive18 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 6, i32 0
  %5 = load i32, i32* %coerce.dive18, align 8
  %coerce.val.ii19 = zext i32 %5 to i64
  %call20 = call fastcc i32 @from_kgid_munged(i64 %coerce.val.ii19) #25
  %conv21 = zext i32 %call20 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv21) #27
  %coerce.dive22 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 4, i32 0
  %6 = load i32, i32* %coerce.dive22, align 8
  %coerce.val.ii23 = zext i32 %6 to i64
  %call24 = call fastcc i32 @from_kgid_munged(i64 %coerce.val.ii23) #25
  %conv25 = zext i32 %call24 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv25) #27
  %coerce.dive26 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 8, i32 0
  %7 = load i32, i32* %coerce.dive26, align 8
  %coerce.val.ii27 = zext i32 %7 to i64
  %call28 = call fastcc i32 @from_kgid_munged(i64 %coerce.val.ii27) #25
  %conv29 = zext i32 %call28 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i64 0, i64 0), i64 noundef %conv29) #27
  call void @seq_puts(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i64 0, i64 0)) #27
  %group_info = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 18
  %8 = load %struct.group_info*, %struct.group_info** %group_info, align 8
  %ngroups = getelementptr inbounds %struct.group_info, %struct.group_info* %8, i64 0, i32 1
  %9 = load i32, i32* %ngroups, align 4
  %cmp1 = icmp sgt i32 %9, 0
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %tobool.not = icmp eq i64 %indvars.iv, 0
  %cond = select i1 %tobool.not, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.19, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i64 0, i64 0)
  %coerce.dive32 = getelementptr %struct.group_info, %struct.group_info* %8, i64 0, i32 2, i64 %indvars.iv, i32 0
  %10 = load i32, i32* %coerce.dive32, align 4
  %coerce.val.ii33 = zext i32 %10 to i64
  %call34 = call fastcc i32 @from_kgid_munged(i64 %coerce.val.ii33) #25
  %conv35 = zext i32 %call34 to i64
  call void @seq_put_decimal_ull(%struct.seq_file* noundef %m, i8* noundef %cond, i64 noundef %conv35) #27
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %11 = load i32, i32* %ngroups, align 4
  %12 = sext i32 %11 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %12
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  call void @seq_puts(%struct.seq_file* noundef %m, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.20, i64 0, i64 0)) #27
  %cap_effective = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 12
  %13 = bitcast %struct.kernel_cap_struct* %cap_effective to i64*
  %14 = load i64, i64* %13, align 8
  %cap.sroa.5.0.extract.shift = lshr i64 %14, 32
  call void @seq_put_hex_ll(%struct.seq_file* noundef %m, i8* noundef null, i64 noundef %cap.sroa.5.0.extract.shift, i32 noundef 8) #27
  %conv43.1 = and i64 %14, 4294967295
  call void @seq_put_hex_ll(%struct.seq_file* noundef %m, i8* noundef null, i64 noundef %conv43.1, i32 noundef 8) #27
  call void @seq_putc(%struct.seq_file* noundef %m, i8 noundef 10) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.dentry* @d_real(%struct.dentry* noundef %dentry, %struct.inode* noundef %inode) unnamed_addr #1 {
entry:
  %d_flags = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i64 0, i32 0
  %0 = load i32, i32* %d_flags, align 8
  %and = and i32 %0, 67108864
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  %d_op = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i64 0, i32 8
  %1 = load %struct.dentry_operations*, %struct.dentry_operations** %d_op, align 8
  %d_real = getelementptr inbounds %struct.dentry_operations, %struct.dentry_operations* %1, i64 0, i32 12
  %2 = load %struct.dentry* (%struct.dentry*, %struct.inode*)*, %struct.dentry* (%struct.dentry*, %struct.inode*)** %d_real, align 32
  %call = call %struct.dentry* %2(%struct.dentry* noundef %dentry, %struct.inode* noundef %inode) #27
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi %struct.dentry* [ %call, %if.then ], [ %dentry, %entry ]
  ret %struct.dentry* %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_put_decimal_ull(%struct.seq_file* noundef, i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @from_kuid_munged(i64 %kuid.coerce) unnamed_addr #3 {
entry:
  %coerce.val.ii2 = and i64 %kuid.coerce, 4294967295
  %call = call fastcc i32 @from_kuid(i64 %coerce.val.ii2) #25
  %cmp = icmp eq i32 %call, -1
  %0 = load i32, i32* @overflowuid, align 4
  %spec.select = select i1 %cmp, i32 %0, i32 %call
  ret i32 %spec.select
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @from_kgid_munged(i64 %kgid.coerce) unnamed_addr #3 {
entry:
  %coerce.val.ii2 = and i64 %kgid.coerce, 4294967295
  %call = call fastcc i32 @from_kgid(i64 %coerce.val.ii2) #25
  %cmp = icmp eq i32 %call, -1
  %0 = load i32, i32* @overflowgid, align 4
  %spec.select = select i1 %cmp, i32 %0, i32 %call
  ret i32 %spec.select
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_puts(%struct.seq_file* noundef, i8* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_put_hex_ll(%struct.seq_file* noundef, i8* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_putc(%struct.seq_file* noundef, i8 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @from_kuid(i64 %kuid.coerce) unnamed_addr #0 {
entry:
  %coerce.val.ii2 = and i64 %kuid.coerce, 4294967295
  %call = call fastcc i32 @__kuid_val(i64 %coerce.val.ii2) #25
  ret i32 %call
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @__kuid_val(i64 %uid.coerce) unnamed_addr #0 {
entry:
  %coerce.val.ii = trunc i64 %uid.coerce to i32
  ret i32 %coerce.val.ii
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @from_kgid(i64 %kgid.coerce) unnamed_addr #0 {
entry:
  %coerce.val.ii2 = and i64 %kgid.coerce, 4294967295
  %call = call fastcc i32 @__kgid_val(i64 %coerce.val.ii2) #25
  ret i32 %call
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @__kgid_val(i64 %gid.coerce) unnamed_addr #0 {
entry:
  %coerce.val.ii = trunc i64 %gid.coerce to i32
  ret i32 %coerce.val.ii
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_alloc_async_data(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %idxprom = zext i8 %0 to i64
  %async_size = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom, i32 1
  %1 = load i16, i16* %async_size, align 2
  %tobool.not = icmp eq i16 %1, 0
  br i1 %tobool.not, label %if.then, label %if.end9.i, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 3306; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !79
  %.pre = load i8, i8* %opcode, align 8
  %idxprom17.phi.trans.insert = zext i8 %.pre to i64
  %async_size19.phi.trans.insert = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom17.phi.trans.insert, i32 1
  %.pre28 = load i16, i16* %async_size19.phi.trans.insert, align 2
  br label %if.end9.i

if.end9.i:                                        ; preds = %entry, %if.then
  %2 = phi i16 [ %.pre28, %if.then ], [ %1, %entry ]
  %conv20 = zext i16 %2 to i64
  %call10.i = call noalias align 128 i8* @__kmalloc(i64 noundef %conv20, i32 noundef 3264) #27
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  store i8* %call10.i, i8** %async_data, align 8
  %cmp = icmp eq i8* %call10.i, null
  %conv22 = zext i1 %cmp to i32
  ret i32 %conv22
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_map_rw(%struct.io_kiocb* nocapture noundef %req, %struct.iovec* noundef %iovec, %struct.iovec* noundef %fast_iov, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %0 = bitcast i8** %async_data to %struct.io_async_rw**
  %1 = load %struct.io_async_rw*, %struct.io_async_rw** %0, align 8
  %2 = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 2, i32 0
  %3 = getelementptr %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 0
  %call = call i8* @memcpy(i8* noundef %2, i8* noundef %3, i64 noundef 40) #27
  %free_iovec = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 1
  store %struct.iovec* %iovec, %struct.iovec** %free_iovec, align 8
  %bytes_done = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 4
  store i64 0, i64* %bytes_done, align 8
  %call2 = call fastcc i1 @iov_iter_is_bvec(%struct.iov_iter* noundef %iter) #25
  br i1 %call2, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq %struct.iovec* %iovec, null
  br i1 %tobool.not, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 0, i64 0
  %iov = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 2, i32 4, i32 0
  store %struct.iovec* %arraydecay, %struct.iovec** %iov, align 8
  %iov6 = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 4, i32 0
  %4 = load %struct.iovec*, %struct.iovec** %iov6, align 8
  %cmp.not = icmp eq %struct.iovec* %4, %fast_iov
  br i1 %cmp.not, label %if.end11, label %if.then7

if.then7:                                         ; preds = %if.then3
  %sub.ptr.lhs.cast = ptrtoint %struct.iovec* %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.iovec* %fast_iov to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %5 = lshr exact i64 %sub.ptr.sub, 4
  %idx.ext = and i64 %5, 4294967295
  %add.ptr = getelementptr %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 0, i64 %idx.ext
  store %struct.iovec* %add.ptr, %struct.iovec** %iov, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.then3
  %iov_off.0 = phi i64 [ %idx.ext, %if.then7 ], [ 0, %if.then3 ]
  %cmp14.not = icmp eq %struct.iovec* %arraydecay, %fast_iov
  br i1 %cmp14.not, label %cleanup, label %if.then16

if.then16:                                        ; preds = %if.end11
  %add.ptr20 = getelementptr %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 0, i64 %iov_off.0
  %6 = bitcast %struct.iovec* %add.ptr20 to i8*
  %add.ptr22 = getelementptr %struct.iovec, %struct.iovec* %fast_iov, i64 %iov_off.0
  %7 = bitcast %struct.iovec* %add.ptr22 to i8*
  %nr_segs = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 5, i32 0
  %8 = load i64, i64* %nr_segs, align 8
  %mul = shl i64 %8, 4
  %call23 = call i8* @memcpy(i8* noundef %6, i8* noundef %7, i64 noundef %mul) #27
  br label %cleanup

if.else:                                          ; preds = %if.end
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %9 = load i32, i32* %flags, align 8
  %or = or i32 %9, 8192
  store i32 %or, i32* %flags, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then16, %if.end11, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @iov_iter_is_bvec(%struct.iov_iter* nocapture noundef readonly %i) unnamed_addr #3 {
entry:
  %call = call fastcc i32 @iov_iter_type(%struct.iov_iter* noundef %i) #25
  %cmp = icmp eq i32 %call, 2
  ret i1 %cmp
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @iov_iter_type(%struct.iov_iter* nocapture noundef readonly %i) unnamed_addr #3 {
entry:
  %iter_type = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %i, i64 0, i32 0
  %0 = load i8, i8* %iter_type, align 8
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @call_read_iter(%struct.file* nocapture noundef readonly %file, %struct.kiocb* noundef %kio, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %0 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %read_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %0, i64 0, i32 4
  %1 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %read_iter, align 8
  %call = call i64 %1(%struct.kiocb* noundef %kio, %struct.iov_iter* noundef %iter) #27
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @loop_rw_iter(i32 noundef %rw, %struct.io_kiocb* noundef %req, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %kiocb2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0
  %file3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file3, align 8
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %1 = load i32, i32* %ki_flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup54

if.end:                                           ; preds = %entry
  %and5 = and i32 %1, 8
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %while.cond.preheader, label %cleanup54

while.cond.preheader:                             ; preds = %if.end
  %addr = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  %len = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 2
  %cmp18 = icmp eq i32 %rw, 0
  %f_op26 = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 3
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %if.end46
  %ret.0 = phi i64 [ %add47, %if.end46 ], [ 0, %while.cond.preheader ]
  %call = call fastcc i64 @iov_iter_count(%struct.iov_iter* noundef %iter) #25
  %tobool9.not = icmp eq i64 %call, 0
  br i1 %tobool9.not, label %cleanup54, label %while.body

while.body:                                       ; preds = %while.cond
  %call10 = call fastcc i1 @iov_iter_is_bvec(%struct.iov_iter* noundef %iter) #25
  br i1 %call10, label %if.else, label %if.then11

if.then11:                                        ; preds = %while.body
  %call12 = call fastcc [2 x i64] @iov_iter_iovec(%struct.iov_iter* noundef %iter) #25
  %call12.fca.0.extract = extractvalue [2 x i64] %call12, 0
  %call12.fca.1.extract = extractvalue [2 x i64] %call12, 1
  br label %if.end17

if.else:                                          ; preds = %while.body
  %2 = load i64, i64* %addr, align 8
  %3 = load i64, i64* %len, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then11
  %iovec.sroa.0.1.in = phi i64 [ %2, %if.else ], [ %call12.fca.0.extract, %if.then11 ]
  %iovec.sroa.7.1 = phi i64 [ %3, %if.else ], [ %call12.fca.1.extract, %if.then11 ]
  %iovec.sroa.0.1 = inttoptr i64 %iovec.sroa.0.1.in to i8*
  %4 = load %struct.file_operations*, %struct.file_operations** %f_op26, align 8
  %write = getelementptr inbounds %struct.file_operations, %struct.file_operations* %4, i64 0, i32 3
  %read = getelementptr inbounds %struct.file_operations, %struct.file_operations* %4, i64 0, i32 2
  %write.sink = select i1 %cmp18, i64 (%struct.file*, i8*, i64, i64*)** %read, i64 (%struct.file*, i8*, i64, i64*)** %write
  %5 = load i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)** %write.sink, align 8
  %call29 = call fastcc i64* @io_kiocb_ppos(%struct.kiocb* noundef %kiocb2) #25
  %call30 = call i64 %5(%struct.file* noundef %0, i8* noundef %iovec.sroa.0.1, i64 noundef %iovec.sroa.7.1, i64* noundef %call29) #27
  %cmp32 = icmp slt i64 %call30, 0
  br i1 %cmp32, label %if.then34, label %if.end38

if.then34:                                        ; preds = %if.end17
  %tobool35.not = icmp eq i64 %ret.0, 0
  %spec.select = select i1 %tobool35.not, i64 %call30, i64 %ret.0
  br label %cleanup54

if.end38:                                         ; preds = %if.end17
  %call39 = call fastcc i1 @iov_iter_is_bvec(%struct.iov_iter* noundef %iter) #25
  br i1 %call39, label %if.else41, label %if.then40

if.then40:                                        ; preds = %if.end38
  call void @iov_iter_advance(%struct.iov_iter* noundef %iter, i64 noundef %call30) #27
  br label %if.end46

if.else41:                                        ; preds = %if.end38
  %6 = load i64, i64* %len, align 8
  %sub = sub i64 %6, %call30
  store i64 %sub, i64* %len, align 8
  %7 = load i64, i64* %addr, align 8
  %add = add i64 %7, %call30
  store i64 %add, i64* %addr, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.else41, %if.then40
  %add47 = add i64 %call30, %ret.0
  %cmp49.not = icmp eq i64 %call30, %iovec.sroa.7.1
  br i1 %cmp49.not, label %while.cond, label %cleanup54

cleanup54:                                        ; preds = %if.end46, %while.cond, %if.then34, %if.end, %entry
  %retval.0 = phi i64 [ -95, %entry ], [ -11, %if.end ], [ %spec.select, %if.then34 ], [ %add47, %if.end46 ], [ %ret.0, %while.cond ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc [2 x i64] @iov_iter_iovec(%struct.iov_iter* nocapture noundef readonly %iter) unnamed_addr #3 {
entry:
  %iov = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 4, i32 0
  %0 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %0, i64 0, i32 0
  %1 = load i8*, i8** %iov_base1, align 8
  %iov_offset = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 2
  %2 = load i64, i64* %iov_offset, align 8
  %add.ptr = getelementptr i8, i8* %1, i64 %2
  %count = getelementptr inbounds %struct.iov_iter, %struct.iov_iter* %iter, i64 0, i32 3
  %3 = load i64, i64* %count, align 8
  %iov_len3 = getelementptr inbounds %struct.iovec, %struct.iovec* %0, i64 0, i32 1
  %4 = load i64, i64* %iov_len3, align 8
  %sub = sub i64 %4, %2
  %cmp = icmp ult i64 %3, %sub
  %cond = select i1 %cmp, i64 %3, i64 %sub
  %5 = ptrtoint i8* %add.ptr to i64
  %.fca.0.insert = insertvalue [2 x i64] poison, i64 %5, 0
  %.fca.1.insert = insertvalue [2 x i64] %.fca.0.insert, i64 %cond, 1
  ret [2 x i64] %.fca.1.insert
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @file_can_poll(%struct.file* nocapture noundef readonly %file) unnamed_addr #3 {
entry:
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %0 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %poll = getelementptr inbounds %struct.file_operations, %struct.file_operations* %0, i64 0, i32 9
  %1 = load i32 (%struct.file*, %struct.poll_table_struct*)*, i32 (%struct.file*, %struct.poll_table_struct*)** %poll, align 8
  %tobool = icmp ne i32 (%struct.file*, %struct.poll_table_struct*)* %1, null
  ret i1 %tobool
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_async_buf_func(%struct.wait_queue_entry* noundef %wait, i32 noundef %mode, i32 noundef %sync, i8* nocapture noundef %arg) #1 {
entry:
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %0 = bitcast i8** %private to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %0, align 8
  %2 = bitcast i8* %arg to %struct.wait_page_key*
  %add.ptr = getelementptr %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 -1, i32 3
  %3 = bitcast %struct.list_head* %add.ptr to %struct.wait_page_queue*
  %call = call fastcc i1 @wake_page_match(%struct.wait_page_queue* noundef %3, %struct.wait_page_key* noundef %2) #25
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 0, i32 0, i32 0, i32 4
  %4 = load i32, i32* %ki_flags, align 8
  %and = and i32 %4, -524289
  store i32 %and, i32* %ki_flags, align 8
  %entry1 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3
  call fastcc void @list_del_init(%struct.list_head* noundef %entry1) #25
  call fastcc void @io_req_task_queue(%struct.io_kiocb* noundef %1) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @wake_page_match(%struct.wait_page_queue* nocapture noundef readonly %wait_page, %struct.wait_page_key* nocapture noundef %key) unnamed_addr #12 {
entry:
  %page = getelementptr inbounds %struct.wait_page_queue, %struct.wait_page_queue* %wait_page, i64 0, i32 0
  %0 = load %struct.page*, %struct.page** %page, align 8
  %page1 = getelementptr inbounds %struct.wait_page_key, %struct.wait_page_key* %key, i64 0, i32 0
  %1 = load %struct.page*, %struct.page** %page1, align 8
  %cmp.not = icmp eq %struct.page* %0, %1
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %page_match = getelementptr inbounds %struct.wait_page_key, %struct.wait_page_key* %key, i64 0, i32 2
  store i32 1, i32* %page_match, align 4
  %bit_nr = getelementptr inbounds %struct.wait_page_queue, %struct.wait_page_queue* %wait_page, i64 0, i32 1
  %2 = load i32, i32* %bit_nr, align 8
  %bit_nr2 = getelementptr inbounds %struct.wait_page_key, %struct.wait_page_key* %key, i64 0, i32 1
  %3 = load i32, i32* %bit_nr2, align 8
  %cmp3.not = icmp eq i32 %2, %3
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ false, %entry ], [ %cmp3.not, %if.end ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_complete_rw(%struct.kiocb* noundef %kiocb, i64 noundef %res, i64 noundef %res2) #1 {
entry:
  %0 = bitcast %struct.kiocb* %kiocb to %struct.io_kiocb*
  %call = call fastcc i1 @__io_complete_rw_common(%struct.io_kiocb* noundef %0, i64 noundef %res) #25
  br i1 %call, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv = trunc i64 %res to i32
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 5
  store i32 %conv, i32* %result, align 4
  %func = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 3, i32 1
  %1 = bitcast i64* %func to void (%struct.io_kiocb*, i8*)**
  store void (%struct.io_kiocb*, i8*)* @io_req_task_complete, void (%struct.io_kiocb*, i8*)** %1, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %0) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_complete_rw(%struct.io_kiocb* noundef %req, i64 noundef %res, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__io_complete_rw_common(%struct.io_kiocb* noundef %req, i64 noundef %res) #25
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %0 = load i32, i32* %result, align 4
  %conv = zext i32 %0 to i64
  %call1 = call fastcc i32 @io_put_rw_kbuf(%struct.io_kiocb* noundef %req) #25
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef %issue_flags, i64 noundef %conv, i32 noundef %call1) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_rw_done(%struct.kiocb* noundef %kiocb, i64 noundef %ret) unnamed_addr #1 {
entry:
  switch i64 %ret, label %sw.default [
    i64 -529, label %sw.epilog
    i64 -512, label %sw.bb
    i64 -513, label %sw.bb
    i64 -514, label %sw.bb
    i64 -516, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  br label %sw.default

sw.default:                                       ; preds = %entry, %sw.bb
  %ret.addr.0 = phi i64 [ %ret, %entry ], [ -4, %sw.bb ]
  %ki_complete = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 2
  %0 = load void (%struct.kiocb*, i64, i64)*, void (%struct.kiocb*, i64, i64)** %ki_complete, align 8
  call void %0(%struct.kiocb* noundef %kiocb, i64 noundef %ret.addr.0, i64 noundef 0) #27
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_resubmit_prep(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %0 = bitcast i8** %async_data to %struct.io_async_rw**
  %1 = load %struct.io_async_rw*, %struct.io_async_rw** %0, align 8
  %tobool.not = icmp eq %struct.io_async_rw* %1, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call fastcc i32 @io_req_prep_async(%struct.io_kiocb* noundef %req) #25
  %tobool1.not = icmp eq i32 %call, 0
  br label %cleanup

if.end:                                           ; preds = %entry
  %iter = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 2
  %iter_state = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 3
  call void @iov_iter_restore(%struct.iov_iter* noundef %iter, %struct.iov_iter_state* noundef %iter_state) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i1 [ true, %if.end ], [ %tobool1.not, %if.then ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_task_queue_reissue(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_queue_async_work, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @req_set_fail(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #12 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %or = or i32 %0, 256
  store i32 %or, i32* %flags, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_complete_rw_common(%struct.io_kiocb* nocapture noundef %req, i64 noundef %res) unnamed_addr #1 {
entry:
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %0 = load i32, i32* %ki_flags, align 8
  %and = and i32 %0, 262144
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @kiocb_end_write(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %1 = load i32, i32* %result, align 4
  %conv = zext i32 %1 to i64
  %cmp.not = icmp eq i64 %conv, %res
  br i1 %cmp.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  switch i64 %res, label %if.end9 [
    i64 -11, label %land.lhs.true
    i64 -95, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %if.then2, %if.then2
  %call = call fastcc i1 @io_rw_should_reissue(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.lhs.true
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags, align 8
  %or = or i32 %2, 131072
  store i32 %or, i32* %flags, align 8
  br label %return

if.end9:                                          ; preds = %if.then2, %land.lhs.true
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  %conv10 = trunc i64 %res to i32
  store i32 %conv10, i32* %result, align 4
  br label %return

return:                                           ; preds = %if.end, %if.end9, %if.then8
  %retval.0 = phi i1 [ true, %if.then8 ], [ false, %if.end9 ], [ false, %if.end ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_req_task_complete(%struct.io_kiocb* noundef %req, i8* nocapture noundef readonly %locked) #1 {
entry:
  %call = call fastcc i32 @io_put_rw_kbuf(%struct.io_kiocb* noundef %req) #25
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %0 = load i32, i32* %result, align 4
  %conv = zext i32 %0 to i64
  %1 = load i8, i8* %locked, align 1, !range !18
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  call fastcc void @io_req_complete_state(%struct.io_kiocb* noundef %req, i64 noundef %conv, i32 noundef %call) #25
  %compl_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 1, i32 11, i32 6
  %3 = load i32, i32* %compl_nr, align 8
  %inc = add i32 %3, 1
  store i32 %inc, i32* %compl_nr, align 8
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 1, i32 11, i32 5, i64 %idxprom
  store %struct.io_kiocb* %req, %struct.io_kiocb** %arrayidx, align 8
  %4 = load i32, i32* %compl_nr, align 8
  %cmp = icmp eq i32 %4, 32
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %2) #25
  br label %if.end6

if.else:                                          ; preds = %entry
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %conv, i32 noundef %call) #25
  br label %if.end6

if.end6:                                          ; preds = %if.then, %if.then5, %if.else
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @kiocb_end_write(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 8388608
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %__here

__here:                                           ; preds = %entry
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %1 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %1) #25
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 6
  %2 = load %struct.super_block*, %struct.super_block** %i_sb, align 8
  call fastcc void @sb_end_write(%struct.super_block* noundef %2) #25
  br label %if.end

if.end:                                           ; preds = %__here, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_rw_should_reissue(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #1 {
entry:
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %0) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 0
  %1 = load i16, i16* %i_mode, align 8
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %3 = and i16 %1, -4096
  switch i16 %3, label %cleanup [
    i16 24576, label %if.end
    i16 -32768, label %if.end
  ]

if.end:                                           ; preds = %entry, %entry
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %4 = load i32, i32* %flags, align 8
  %and7 = and i32 %4, 2048
  %tobool.not = icmp eq i32 %and7, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %call8 = call fastcc i1 @io_wq_current_is_worker() #25
  br i1 %call8, label %land.lhs.true10, label %if.end15

land.lhs.true10:                                  ; preds = %lor.lhs.false
  %flags11 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 0, i32 2
  %5 = load i32, i32* %flags11, align 8
  %and12 = and i32 %5, 1
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %cleanup, label %if.end15

if.end15:                                         ; preds = %land.lhs.true10, %lor.lhs.false
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 0, i32 0
  %call16 = call fastcc i1 @percpu_ref_is_dying(%struct.percpu_ref* noundef %refs) #25
  br i1 %call16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end15
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %6 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %7 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %8 = inttoptr i64 %7 to %struct.task_struct*
  %call20 = call fastcc i1 @same_thread_group(%struct.task_struct* noundef %6, %struct.task_struct* noundef %8) #25
  br i1 %call20, label %lor.lhs.false21, label %cleanup

lor.lhs.false21:                                  ; preds = %if.end18
  %call22 = call fastcc i32 @preempt_count() #25
  %9 = and i32 %call22, 15728640
  %call25 = call fastcc i32 @preempt_count() #25
  %10 = and i32 %call25, 983040
  %or46 = or i32 %10, %9
  %call28 = call fastcc i32 @preempt_count() #25
  %11 = and i32 %call28, 256
  %or3248 = or i32 %or46, %11
  %tobool33.not = icmp eq i32 %or3248, 0
  br label %cleanup

cleanup:                                          ; preds = %lor.lhs.false21, %if.end18, %if.end15, %if.end, %land.lhs.true10, %entry
  %retval.0 = phi i1 [ false, %entry ], [ false, %land.lhs.true10 ], [ false, %if.end ], [ false, %if.end15 ], [ false, %if.end18 ], [ %tobool33.not, %lor.lhs.false21 ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @sb_end_write(%struct.super_block* noundef %sb) unnamed_addr #1 {
entry:
  call fastcc void @__sb_end_write(%struct.super_block* noundef %sb) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__sb_end_write(%struct.super_block* noundef %sb) unnamed_addr #1 {
entry:
  %add.ptr1 = getelementptr %struct.super_block, %struct.super_block* %sb, i64 0, i32 26, i32 2, i64 0
  call fastcc void @percpu_up_read(%struct.percpu_rw_semaphore* noundef %add.ptr1) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_up_read(%struct.percpu_rw_semaphore* noundef %sem) unnamed_addr #1 {
entry:
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !80
  %rss = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 0
  %call = call fastcc i1 @rcu_sync_is_idle(%struct.rcu_sync* noundef %rss) #25
  br i1 %call, label %do.body3, label %if.else, !prof !8

do.body3:                                         ; preds = %entry
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !81
  %read_count = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 1
  %0 = load i32*, i32** %read_count, align 8
  %1 = ptrtoint i32* %0 to i64
  %call9 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add = add i64 %call9, %1
  %2 = inttoptr i64 %add to i8*
  call fastcc void @__percpu_add_case_32(i8* noundef %2, i64 noundef 4294967295) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !82
  br label %if.end

if.else:                                          ; preds = %entry
  call void asm sideeffect "dmb ish", "~{memory}"() #26, !srcloc !83
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !84
  %read_count20 = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 1
  %3 = load i32*, i32** %read_count20, align 8
  %4 = ptrtoint i32* %3 to i64
  %call22 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add23 = add i64 %call22, %4
  %5 = inttoptr i64 %add23 to i8*
  call fastcc void @__percpu_add_case_32(i8* noundef %5, i64 noundef 4294967295) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !85
  %writer = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 2
  %call25 = call i32 @rcuwait_wake_up(%struct.rcuwait* noundef %writer) #27
  br label %if.end

if.end:                                           ; preds = %if.else, %do.body3
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !86
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @rcu_sync_is_idle(%struct.rcu_sync* noundef %rsp) unnamed_addr #8 {
entry:
  %gp_state = getelementptr inbounds %struct.rcu_sync, %struct.rcu_sync* %rsp, i64 0, i32 0
  %0 = load volatile i32, i32* %gp_state, align 8
  %tobool.not = icmp eq i32 %0, 0
  ret i1 %tobool.not
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__percpu_add_case_32(i8* noundef %ptr, i64 noundef %val) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i32*
  %conv = trunc i64 %val to i32
  %1 = call { i32, i32 } asm sideeffect "1:\09ldxr\09${1:w}, $2\0Aadd\09${1:w}, ${1:w}, ${3:w}\0A\09stxr\09${0:w}, ${1:w}, $2\0A\09cbnz\09${0:w}, 1b", "=&r,=&r,=*Q,r,*Q"(i32* elementtype(i32) %0, i32 %conv, i32* elementtype(i32) %0) #26, !srcloc !87
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcuwait_wake_up(%struct.rcuwait* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @percpu_ref_is_dying(%struct.percpu_ref* nocapture noundef readonly %ref) unnamed_addr #3 {
entry:
  %percpu_count_ptr = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 0, i32 0
  %0 = load i64, i64* %percpu_count_ptr, align 8
  %and = and i64 %0, 2
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @same_thread_group(%struct.task_struct* nocapture noundef readonly %p1, %struct.task_struct* nocapture noundef readonly %p2) unnamed_addr #3 {
entry:
  %signal = getelementptr inbounds %struct.task_struct, %struct.task_struct* %p1, i64 0, i32 87
  %0 = load %struct.signal_struct*, %struct.signal_struct** %signal, align 8
  %signal1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %p2, i64 0, i32 87
  %1 = load %struct.signal_struct*, %struct.signal_struct** %signal1, align 8
  %cmp = icmp eq %struct.signal_struct* %0, %1
  ret i1 %cmp
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_req_prep_async(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %idxprom = zext i8 %0 to i64
  %1 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom, i32 0
  %bf.load = load i16, i16* %1, align 4
  %2 = and i16 %bf.load, 128
  %tobool.not = icmp eq i16 %2, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %3 = load i8*, i8** %async_data, align 8
  %tobool1.not = icmp eq i8* %3, null
  br i1 %tobool1.not, label %if.end20, label %if.then9, !prof !8

if.then9:                                         ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 6449; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !88
  br label %return

if.end20:                                         ; preds = %if.end
  %call = call fastcc i32 @io_alloc_async_data(%struct.io_kiocb* noundef %req) #25
  %tobool21.not = icmp eq i32 %call, 0
  br i1 %tobool21.not, label %if.end23, label %return

if.end23:                                         ; preds = %if.end20
  %4 = load i8, i8* %opcode, align 8
  switch i8 %4, label %sw.epilog [
    i8 1, label %sw.bb
    i8 2, label %sw.bb27
    i8 9, label %return
    i8 10, label %return
    i8 16, label %return
  ]

sw.bb:                                            ; preds = %if.end23
  %call26 = call fastcc i32 @io_rw_prep_async(%struct.io_kiocb* noundef %req, i32 noundef 0) #25
  br label %return

sw.bb27:                                          ; preds = %if.end23
  %call28 = call fastcc i32 @io_rw_prep_async(%struct.io_kiocb* noundef %req, i32 noundef 1) #25
  br label %return

sw.epilog:                                        ; preds = %if.end23
  %.b73 = load i1, i1* @io_req_prep_async.__already_done, align 1
  br i1 %.b73, label %return, label %if.then47, !prof !8

if.then47:                                        ; preds = %sw.epilog
  store i1 true, i1* @io_req_prep_async.__already_done, align 1
  %conv50 = zext i8 %4 to i32
  %call51 = call i32 (i8*, ...) @_printk(i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.22, i64 0, i64 0), i32 noundef %conv50) #30
  br label %return

return:                                           ; preds = %if.end23, %if.end23, %if.end23, %if.then9, %sw.epilog, %if.then47, %if.end20, %entry, %sw.bb27, %sw.bb
  %retval.0 = phi i32 [ %call28, %sw.bb27 ], [ %call26, %sw.bb ], [ 0, %entry ], [ -14, %if.then9 ], [ -11, %if.end20 ], [ -14, %if.then47 ], [ -14, %sw.epilog ], [ -95, %if.end23 ], [ -95, %if.end23 ], [ -95, %if.end23 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_rw_prep_async(%struct.io_kiocb* nocapture noundef %req, i32 noundef %rw) unnamed_addr #1 {
entry:
  %iov = alloca %struct.iovec*, align 8
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %0 = bitcast i8** %async_data to %struct.io_async_rw**
  %1 = load %struct.io_async_rw*, %struct.io_async_rw** %0, align 8
  %2 = bitcast %struct.iovec** %iov to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %2) #26
  %arraydecay = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 0, i64 0
  store %struct.iovec* %arraydecay, %struct.iovec** %iov, align 8
  %iter = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 2
  %call = call fastcc i32 @io_import_iovec(i32 noundef %rw, %struct.io_kiocb* noundef %req, %struct.iovec** noundef nonnull %iov, %struct.iov_iter* noundef %iter, i1 noundef false) #25
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %bytes_done = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 4
  store i64 0, i64* %bytes_done, align 8
  %3 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %free_iovec = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 1
  store %struct.iovec* %3, %struct.iovec** %free_iovec, align 8
  %tobool2.not = icmp eq %struct.iovec* %3, null
  br i1 %tobool2.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %4 = load i32, i32* %flags, align 8
  %or = or i32 %4, 8192
  store i32 %or, i32* %flags, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %iter_state = getelementptr inbounds %struct.io_async_rw, %struct.io_async_rw* %1, i64 0, i32 3
  call fastcc void @iov_iter_save_state(%struct.iov_iter* noundef %iter, %struct.iov_iter_state* noundef %iter_state) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ %call, %entry ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %2) #26
  ret i32 %retval.0
}

; Function Attrs: cold null_pointer_is_valid
declare dso_local i32 @_printk(i8* noundef, ...) local_unnamed_addr #17

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @sb_start_write(%struct.super_block* noundef %sb) unnamed_addr #1 {
entry:
  call fastcc void @__sb_start_write(%struct.super_block* noundef %sb) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @call_write_iter(%struct.file* nocapture noundef readonly %file, %struct.kiocb* noundef %kio, %struct.iov_iter* noundef %iter) unnamed_addr #1 {
entry:
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %0 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %write_iter = getelementptr inbounds %struct.file_operations, %struct.file_operations* %0, i64 0, i32 5
  %1 = load i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)** %write_iter, align 8
  %call = call i64 %1(%struct.kiocb* noundef %kio, %struct.iov_iter* noundef %iter) #27
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__sb_start_write(%struct.super_block* noundef %sb) unnamed_addr #1 {
entry:
  %add.ptr1 = getelementptr %struct.super_block, %struct.super_block* %sb, i64 0, i32 26, i32 2, i64 0
  call fastcc void @percpu_down_read(%struct.percpu_rw_semaphore* noundef %add.ptr1) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_down_read(%struct.percpu_rw_semaphore* noundef %sem) unnamed_addr #1 {
entry:
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !89
  %rss = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 0
  %call = call fastcc i1 @rcu_sync_is_idle(%struct.rcu_sync* noundef %rss) #25
  br i1 %call, label %do.body7, label %if.else, !prof !8

do.body7:                                         ; preds = %entry
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !90
  %read_count = getelementptr inbounds %struct.percpu_rw_semaphore, %struct.percpu_rw_semaphore* %sem, i64 0, i32 1
  %0 = load i32*, i32** %read_count, align 8
  %1 = ptrtoint i32* %0 to i64
  %call13 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add = add i64 %call13, %1
  %2 = inttoptr i64 %add to i8*
  call fastcc void @__percpu_add_case_32(i8* noundef %2, i64 noundef 1) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !91
  br label %if.end

if.else:                                          ; preds = %entry
  %call15 = call i1 @__percpu_down_read(%struct.percpu_rw_semaphore* noundef %sem, i1 noundef false) #27
  br label %if.end

if.end:                                           ; preds = %if.else, %do.body7
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !92
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @__percpu_down_read(%struct.percpu_rw_semaphore* noundef, i1 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @vfs_fsync_range(%struct.file* noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_complete(%struct.io_kiocb* noundef %req, i64 noundef %res) unnamed_addr #1 {
entry:
  call fastcc void @__io_req_complete(%struct.io_kiocb* noundef %req, i32 noundef 0, i64 noundef %res, i32 noundef 0) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_poll_queue_proc(%struct.file* nocapture noundef readnone %file, %struct.wait_queue_head* noundef %head, %struct.poll_table_struct* nocapture noundef %p) #1 {
entry:
  %0 = bitcast %struct.poll_table_struct* %p to %struct.io_poll_table*
  %req = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i64 1
  %1 = bitcast %struct.poll_table_struct* %req to %struct.io_kiocb**
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %1, align 8
  %poll = bitcast %struct.io_kiocb* %2 to %struct.io_poll_iocb*
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %2, i64 0, i32 1
  %3 = bitcast i8** %async_data to %struct.io_poll_iocb**
  call fastcc void @__io_queue_proc(%struct.io_poll_iocb* noundef %poll, %struct.io_poll_table* noundef %0, %struct.wait_queue_head* noundef %head, %struct.io_poll_iocb** noundef %3) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_arm_poll_handler(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %poll, %struct.io_poll_table* noundef %ipt, i32 noundef %mask, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef %wake_func) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %hash_node = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 15
  call fastcc void @INIT_HLIST_NODE(%struct.hlist_node* noundef %hash_node) #25
  call fastcc void @io_init_poll_iocb(%struct.io_poll_iocb* noundef %poll, i32 noundef %mask, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef %wake_func) #25
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %1 = load %struct.file*, %struct.file** %file, align 8
  %file2 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 0
  store %struct.file* %1, %struct.file** %file2, align 8
  %private = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5, i32 1
  %2 = bitcast i8** %private to %struct.io_kiocb**
  store %struct.io_kiocb* %req, %struct.io_kiocb** %2, align 8
  %pt = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0
  %_key = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 0, i32 1
  store i32 %mask, i32* %_key, align 8
  %req3 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 1
  store %struct.io_kiocb* %req, %struct.io_kiocb** %req3, align 8
  %error = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 3
  store i32 0, i32* %error, align 4
  %nr_entries = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %ipt, i64 0, i32 2
  store i32 0, i32* %nr_entries, align 8
  %3 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc i32 @vfs_poll(%struct.file* noundef %3, %struct.poll_table_struct* noundef %pt) #25
  %events = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 2
  %4 = load i32, i32* %events, align 8
  %and = and i32 %4, %call
  %5 = load i32, i32* %nr_entries, align 8
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %land.lhs.true, label %if.end, !prof !24

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, i32* %error, align 4
  %tobool11.not = icmp eq i32 %6, 0
  br i1 %tobool11.not, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 -22, i32* %error, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %7 = load i32, i32* %error, align 4
  %tobool14.not = icmp eq i32 %7, 0
  br i1 %tobool14.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %if.end
  %tobool15.not = icmp eq i32 %and, 0
  br i1 %tobool15.not, label %if.end21, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %lor.lhs.false
  %8 = load i32, i32* %events, align 8
  %and18 = and i32 %8, 1073741824
  %tobool19.not = icmp eq i32 %and18, 0
  br i1 %tobool19.not, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true16, %if.end
  call fastcc void @io_poll_remove_double(%struct.io_kiocb* noundef %req) #25
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true16, %lor.lhs.false
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 1
  %9 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %tobool22.not = icmp eq %struct.wait_queue_head* %9, null
  br i1 %tobool22.not, label %if.end77, label %if.then30, !prof !24

if.then30:                                        ; preds = %if.end21
  %rlock.i113 = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %9, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i113) #27
  %entry33 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5, i32 3
  %call34 = call fastcc i32 @list_empty(%struct.list_head* noundef %entry33) #25
  %tobool35.not = icmp eq i32 %call34, 0
  br i1 %tobool35.not, label %if.end49, label %if.else, !prof !8

if.end49:                                         ; preds = %if.then30
  %tobool50.not = icmp eq i32 %and, 0
  br i1 %tobool50.not, label %lor.lhs.false55, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %if.end49
  %10 = load i32, i32* %events, align 8
  %and53 = and i32 %10, 1073741824
  %tobool54.not = icmp eq i32 %and53, 0
  br i1 %tobool54.not, label %lor.lhs.false55, label %if.then58

lor.lhs.false55:                                  ; preds = %land.lhs.true51, %if.end49
  %.pr = load i32, i32* %error, align 4
  %tobool57.not = icmp eq i32 %.pr, 0
  br i1 %tobool57.not, label %if.else69, label %if.then58

if.then58:                                        ; preds = %lor.lhs.false55, %land.lhs.true51
  call fastcc void @list_del_init(%struct.list_head* noundef %entry33) #25
  br label %if.end74

if.else:                                          ; preds = %if.then30
  %11 = load i32, i32* %error, align 4
  %tobool45.not = icmp eq i32 %11, 0
  store i32 0, i32* %error, align 4
  br i1 %tobool45.not, label %if.else69, label %do.body64

do.body64:                                        ; preds = %if.else
  %canceled = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  store volatile i8 1, i8* %canceled, align 1
  br label %if.end74

if.else69:                                        ; preds = %lor.lhs.false55, %if.else
  %mask.addr.0120126129 = phi i32 [ 0, %if.else ], [ %and, %lor.lhs.false55 ]
  %done = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 3
  %12 = load i8, i8* %done, align 4, !range !18
  %tobool70.not = icmp eq i8 %12, 0
  br i1 %tobool70.not, label %if.then71, label %if.end74

if.then71:                                        ; preds = %if.else69
  call fastcc void @io_poll_req_insert(%struct.io_kiocb* noundef %req) #25
  br label %if.end74

if.end74:                                         ; preds = %do.body64, %if.then71, %if.else69, %if.then58
  %mask.addr.0118 = phi i32 [ 0, %do.body64 ], [ %mask.addr.0120126129, %if.then71 ], [ %mask.addr.0120126129, %if.else69 ], [ %and, %if.then58 ]
  %13 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %rlock.i114 = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %13, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i114) #27
  br label %if.end77

if.end77:                                         ; preds = %if.end74, %if.end21
  %mask.addr.1 = phi i32 [ %mask.addr.0118, %if.end74 ], [ %and, %if.end21 ]
  ret i32 %mask.addr.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_poll_wake(%struct.wait_queue_entry* nocapture noundef readonly %wait, i32 noundef %mode, i32 noundef %sync, i8* noundef %key) #1 {
entry:
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %0 = bitcast i8** %private to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %0, align 8
  %poll1 = bitcast %struct.io_kiocb* %1 to %struct.io_poll_iocb*
  %2 = ptrtoint i8* %key to i64
  %conv = trunc i64 %2 to i32
  %call = call fastcc i32 @__io_async_wake(%struct.io_kiocb* noundef %1, %struct.io_poll_iocb* noundef %poll1, i32 noundef %conv, void (%struct.io_kiocb*, i8*)* noundef nonnull @io_poll_task_func) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_poll_complete(%struct.io_kiocb* noundef %req, i32 noundef %mask) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @__io_poll_complete(%struct.io_kiocb* noundef %req, i32 noundef %mask) #25
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %0) #25
  ret i1 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_put_req(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @io_free_req(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_queue_proc(%struct.io_poll_iocb* noundef %poll, %struct.io_poll_table* nocapture noundef %pt, %struct.wait_queue_head* noundef %head, %struct.io_poll_iocb** nocapture noundef %poll_ptr) unnamed_addr #1 {
entry:
  %req1 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %pt, i64 0, i32 1
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %req1, align 8
  %nr_entries = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %pt, i64 0, i32 2
  %1 = load i32, i32* %nr_entries, align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end24, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  %head4 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 1
  %2 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head4, align 8
  %cmp = icmp eq %struct.wait_queue_head* %2, %head
  br i1 %cmp, label %cleanup34, label %if.end

if.end:                                           ; preds = %if.then
  %3 = load %struct.io_poll_iocb*, %struct.io_poll_iocb** %poll_ptr, align 8
  %tobool7.not = icmp eq %struct.io_poll_iocb* %3, null
  br i1 %tobool7.not, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.end
  %head9 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %3, i64 0, i32 1
  %4 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head9, align 8
  %cmp10 = icmp eq %struct.wait_queue_head* %4, %head
  br i1 %cmp10, label %cleanup34, label %if.end13

if.end13:                                         ; preds = %if.then8
  %error = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %pt, i64 0, i32 3
  store i32 -22, i32* %error, align 4
  br label %cleanup34

if.end14:                                         ; preds = %if.end
  %events = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 2
  %5 = load i32, i32* %events, align 8
  %and = and i32 %5, 1073741824
  %tobool15.not = icmp eq i32 %and, 0
  br i1 %tobool15.not, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %or = or i32 %5, 1073741824
  store i32 %or, i32* %events, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %6 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %6, i32 noundef 2592) #27
  %7 = bitcast i8* %call.i.i to %struct.io_poll_iocb*
  %tobool19.not = icmp eq i8* %call.i.i, null
  br i1 %tobool19.not, label %if.then20, label %cleanup

if.then20:                                        ; preds = %if.end18
  %error21 = getelementptr inbounds %struct.io_poll_table, %struct.io_poll_table* %pt, i64 0, i32 3
  store i32 -12, i32* %error21, align 4
  br label %cleanup34

cleanup:                                          ; preds = %if.end18
  %8 = load i32, i32* %events, align 8
  call fastcc void @io_init_poll_iocb(%struct.io_poll_iocb* noundef nonnull %7, i32 noundef %8, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef nonnull @io_poll_double_wake) #25
  call fastcc void @req_ref_get(%struct.io_kiocb* noundef %0) #25
  %private = getelementptr inbounds i8, i8* %call.i.i, i64 32
  %9 = bitcast i8* %private to %struct.io_kiocb**
  store %struct.io_kiocb* %0, %struct.io_kiocb** %9, align 8
  %10 = bitcast %struct.io_poll_iocb** %poll_ptr to i8**
  store i8* %call.i.i, i8** %10, align 8
  %.pre = load i32, i32* %nr_entries, align 8
  %phi.bo = add i32 %.pre, 1
  br label %if.end24

if.end24:                                         ; preds = %cleanup, %entry
  %11 = phi i32 [ %phi.bo, %cleanup ], [ 1, %entry ]
  %poll.addr.1 = phi %struct.io_poll_iocb* [ %7, %cleanup ], [ %poll, %entry ]
  store i32 %11, i32* %nr_entries, align 8
  %head26 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll.addr.1, i64 0, i32 1
  store %struct.wait_queue_head* %head, %struct.wait_queue_head** %head26, align 8
  %events27 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll.addr.1, i64 0, i32 2
  %12 = load i32, i32* %events27, align 8
  %and28 = and i32 %12, 268435456
  %tobool29.not = icmp eq i32 %and28, 0
  %wait32 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll.addr.1, i64 0, i32 5
  br i1 %tobool29.not, label %if.else, label %if.then30

if.then30:                                        ; preds = %if.end24
  call void @add_wait_queue_exclusive(%struct.wait_queue_head* noundef %head, %struct.wait_queue_entry* noundef %wait32) #27
  br label %cleanup34

if.else:                                          ; preds = %if.end24
  call void @add_wait_queue(%struct.wait_queue_head* noundef %head, %struct.wait_queue_entry* noundef %wait32) #27
  br label %cleanup34

cleanup34:                                        ; preds = %if.then8, %if.then, %if.then20, %if.end13, %if.then30, %if.else
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @io_init_poll_iocb(%struct.io_poll_iocb* noundef %poll, i32 noundef %events, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef %wake_func) unnamed_addr #9 {
entry:
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 1
  store %struct.wait_queue_head* null, %struct.wait_queue_head** %head, align 8
  %done = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 3
  store i8 0, i8* %done, align 4
  %canceled = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  store i8 0, i8* %canceled, align 1
  %or = or i32 %events, 8248
  %events1 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 2
  store i32 %or, i32* %events1, align 8
  %wait = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5
  %entry2 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5, i32 3
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %entry2) #25
  call fastcc void @init_waitqueue_func_entry(%struct.wait_queue_entry* noundef %wait, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef %wake_func) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_poll_double_wake(%struct.wait_queue_entry* noundef %wait, i32 noundef %mode, i32 noundef %sync, i8* noundef %key) #1 {
entry:
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %0 = bitcast i8** %private to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %0, align 8
  %call = call fastcc %struct.io_poll_iocb* @io_poll_get_single(%struct.io_kiocb* noundef %1) #25
  %2 = ptrtoint i8* %key to i64
  %conv = trunc i64 %2 to i32
  %tobool.not = icmp ne i32 %conv, 0
  %events2.phi.trans.insert = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 2
  %.pre = load i32, i32* %events2.phi.trans.insert, align 8
  %and = and i32 %.pre, %conv
  %tobool1.not = icmp eq i32 %and, 0
  %or.cond = select i1 %tobool.not, i1 %tobool1.not, i1 false
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %and3 = and i32 %.pre, 1073741824
  %tobool4.not = icmp eq i32 %and3, 0
  br i1 %tobool4.not, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %wait6 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5
  %func = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5, i32 2
  %3 = load i32 (%struct.wait_queue_entry*, i32, i32, i8*)*, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func, align 8
  %call8 = call i32 %3(%struct.wait_queue_entry* noundef %wait6, i32 noundef %mode, i32 noundef %sync, i8* noundef %key) #27
  br label %cleanup

if.end9:                                          ; preds = %if.end
  %entry10 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3
  call fastcc void @list_del_init(%struct.list_head* noundef %entry10) #25
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 1
  %4 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %tobool11.not = icmp eq %struct.wait_queue_head* %4, null
  br i1 %tobool11.not, label %if.end39, label %if.then12

if.then12:                                        ; preds = %if.end9
  %rlock.i = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %4, i64 0, i32 0, i32 0, i32 0
  %call17 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  %entry21 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5, i32 3
  %call22 = call fastcc i32 @list_empty(%struct.list_head* noundef %entry21) #25
  %tobool23.not = icmp eq i32 %call22, 0
  br i1 %tobool23.not, label %if.then25, label %if.end38.critedge

if.then25:                                        ; preds = %if.then12
  %wait20 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5
  call fastcc void @list_del_init(%struct.list_head* noundef %entry21) #25
  store i8* null, i8** %private, align 8
  %5 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %rlock.i66 = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %5, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i66, i64 noundef %call17) #27
  %func35 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5, i32 2
  %6 = load i32 (%struct.wait_queue_entry*, i32, i32, i8*)*, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func35, align 8
  %call37 = call i32 %6(%struct.wait_queue_entry* noundef %wait20, i32 noundef %mode, i32 noundef %sync, i8* noundef %key) #27
  br label %if.end39

if.end38.critedge:                                ; preds = %if.then12
  store i8* null, i8** %private, align 8
  %7 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %rlock.i67 = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %7, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i67, i64 noundef %call17) #27
  br label %if.end39

if.end39:                                         ; preds = %if.then25, %if.end38.critedge, %if.end9
  call fastcc void @req_ref_put(%struct.io_kiocb* noundef %1) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end39, %if.then5
  %retval.0 = phi i32 [ 1, %if.end39 ], [ %call8, %if.then5 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @req_ref_get(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1165; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !93
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 8
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i64 0, i32 0
  %1 = load volatile i32, i32* %counter.i, align 4
  %add = add i32 %1, 127
  %cmp = icmp ult i32 %add, 128
  br i1 %cmp, label %if.then30, label %if.end31, !prof !24

if.then30:                                        ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1166; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !94
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %refs) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @add_wait_queue_exclusive(%struct.wait_queue_head* noundef, %struct.wait_queue_entry* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @add_wait_queue(%struct.wait_queue_head* noundef, %struct.wait_queue_entry* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @init_waitqueue_func_entry(%struct.wait_queue_entry* nocapture noundef writeonly %wq_entry, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef %func) unnamed_addr #10 {
entry:
  %flags = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wq_entry, i64 0, i32 0
  store i32 0, i32* %flags, align 8
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wq_entry, i64 0, i32 1
  store i8* null, i8** %private, align 8
  %func1 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wq_entry, i64 0, i32 2
  store i32 (%struct.wait_queue_entry*, i32, i32, i8*)* %func, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func1, align 8
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.io_poll_iocb* @io_poll_get_single(%struct.io_kiocb* noundef readonly %req) unnamed_addr #3 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %cmp = icmp eq i8 %0, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %poll = bitcast %struct.io_kiocb* %req to %struct.io_poll_iocb*
  br label %return

if.end:                                           ; preds = %entry
  %apoll = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 16
  %1 = load %struct.async_poll*, %struct.async_poll** %apoll, align 8
  %poll2 = getelementptr inbounds %struct.async_poll, %struct.async_poll* %1, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi %struct.io_poll_iocb* [ %poll, %if.then ], [ %poll2, %if.end ]
  ret %struct.io_poll_iocb* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @req_ref_put(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1159; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !95
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then29, label %if.end30, !prof !24

if.then29:                                        ; preds = %if.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1160; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !96
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @INIT_HLIST_NODE(%struct.hlist_node* nocapture noundef writeonly %h) unnamed_addr #10 {
entry:
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i64 0, i32 0
  store %struct.hlist_node* null, %struct.hlist_node** %next, align 8
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i64 0, i32 1
  store %struct.hlist_node** null, %struct.hlist_node*** %pprev, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @vfs_poll(%struct.file* noundef %file, %struct.poll_table_struct* noundef %pt) unnamed_addr #1 {
entry:
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %0 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %poll = getelementptr inbounds %struct.file_operations, %struct.file_operations* %0, i64 0, i32 9
  %1 = load i32 (%struct.file*, %struct.poll_table_struct*)*, i32 (%struct.file*, %struct.poll_table_struct*)** %poll, align 8
  %tobool.not = icmp eq i32 (%struct.file*, %struct.poll_table_struct*)* %1, null
  br i1 %tobool.not, label %return, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %call = call i32 %1(%struct.file* noundef %file, %struct.poll_table_struct* noundef %pt) #27
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ 325, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_poll_remove_double(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_poll_iocb* @io_poll_get_double(%struct.io_kiocb* noundef %req) #25
  %tobool.not = icmp eq %struct.io_poll_iocb* %call, null
  br i1 %tobool.not, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 1
  %0 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %tobool1.not = icmp eq %struct.wait_queue_head* %0, null
  br i1 %tobool1.not, label %if.end10, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %rlock.i = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %0, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %entry4 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5, i32 3
  call fastcc void @list_del_init(%struct.list_head* noundef %entry4) #25
  %private = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %call, i64 0, i32 5, i32 1
  %1 = load i8*, i8** %private, align 8
  %tobool6.not = icmp eq i8* %1, null
  br i1 %tobool6.not, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then
  call fastcc void @req_ref_put(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then
  store %struct.wait_queue_head* null, %struct.wait_queue_head** %head, align 8
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end10

if.end10:                                         ; preds = %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @io_poll_req_insert(%struct.io_kiocb* noundef %req) unnamed_addr #9 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %cancel_hash = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 3
  %1 = load %struct.hlist_head*, %struct.hlist_head** %cancel_hash, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  %2 = load i64, i64* %user_data, align 8
  %cancel_hash_bits = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 4
  %3 = load i32, i32* %cancel_hash_bits, align 32
  %mul.i = mul i64 %2, 7046029254386353131
  %sub.i = sub i32 64, %3
  %sh_prom.i = zext i32 %sub.i to i64
  %shr.i = lshr i64 %mul.i, %sh_prom.i
  %idxprom = and i64 %shr.i, 4294967295
  %arrayidx = getelementptr %struct.hlist_head, %struct.hlist_head* %1, i64 %idxprom
  %hash_node = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 15
  call fastcc void @hlist_add_head(%struct.hlist_node* noundef %hash_node, %struct.hlist_head* noundef %arrayidx) #25
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.io_poll_iocb* @io_poll_get_double(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #3 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %cmp = icmp eq i8 %0, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %1 = bitcast i8** %async_data to %struct.io_poll_iocb**
  br label %return

if.end:                                           ; preds = %entry
  %apoll = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 16
  %2 = load %struct.async_poll*, %struct.async_poll** %apoll, align 8
  %double_poll = getelementptr inbounds %struct.async_poll, %struct.async_poll* %2, i64 0, i32 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0.in = phi %struct.io_poll_iocb** [ %1, %if.then ], [ %double_poll, %if.end ]
  %retval.0 = load %struct.io_poll_iocb*, %struct.io_poll_iocb** %retval.0.in, align 8
  ret %struct.io_poll_iocb* %retval.0
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @hlist_add_head(%struct.hlist_node* noundef %n, %struct.hlist_head* noundef %h) unnamed_addr #9 {
entry:
  %first1 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i64 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %first1, align 8
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i64 0, i32 0
  store volatile %struct.hlist_node* %0, %struct.hlist_node** %next, align 8
  %tobool.not = icmp eq %struct.hlist_node* %0, null
  br i1 %tobool.not, label %do.body22, label %do.body12

do.body12:                                        ; preds = %entry
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i64 0, i32 1
  store volatile %struct.hlist_node** %next, %struct.hlist_node*** %pprev, align 8
  br label %do.body22

do.body22:                                        ; preds = %entry, %do.body12
  store volatile %struct.hlist_node* %n, %struct.hlist_node** %first1, align 8
  %pprev34 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i64 0, i32 1
  store volatile %struct.hlist_node** %first1, %struct.hlist_node*** %pprev34, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_async_wake(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %poll, i32 noundef %mask, void (%struct.io_kiocb*, i8*)* noundef %func) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq i32 %mask, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %events = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 2
  %0 = load i32, i32* %events, align 8
  %and = and i32 %0, %mask
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %entry2 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5, i32 3
  call fastcc void @list_del_init(%struct.list_head* noundef %entry2) #25
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %mask, i32* %result, align 4
  %func3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* %func, void (%struct.io_kiocb*, i8*)** %func3, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) #25
  br label %return

return:                                           ; preds = %land.lhs.true, %if.end
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_poll_task_func(%struct.io_kiocb* noundef %req, i8* nocapture noundef %locked) #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %poll = bitcast %struct.io_kiocb* %req to %struct.io_poll_iocb*
  %call = call fastcc i1 @io_poll_rewait(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %poll) #25
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup25

if.else:                                          ; preds = %entry
  %done3 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 3
  %1 = load i8, i8* %done3, align 4, !range !18
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.else
  %rlock.i49 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i49) #27
  br label %cleanup25

if.end:                                           ; preds = %if.else
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %2 = load i32, i32* %result, align 4
  %call6 = call fastcc i1 @__io_poll_complete(%struct.io_kiocb* noundef %req, i32 noundef %2) #25
  br i1 %call6, label %if.then8, label %if.else11

if.then8:                                         ; preds = %if.end
  call fastcc void @io_poll_remove_double(%struct.io_kiocb* noundef %req) #25
  %hash_node = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 15
  call fastcc void @hash_del(%struct.hlist_node* noundef %hash_node) #25
  store i8 1, i8* %done3, align 4
  br label %if.end15

if.else11:                                        ; preds = %if.end
  store i32 0, i32* %result, align 4
  %head = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %3 = bitcast i64* %head to %struct.wait_queue_head**
  %4 = load %struct.wait_queue_head*, %struct.wait_queue_head** %3, align 8
  %wait = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %5 = bitcast i8** %wait to %struct.wait_queue_entry*
  call void @add_wait_queue(%struct.wait_queue_head* noundef %4, %struct.wait_queue_entry* noundef %5) #27
  br label %if.end15

if.end15:                                         ; preds = %if.else11, %if.then8
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %0) #25
  %rlock.i50 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i50) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %0) #25
  br i1 %call6, label %if.then18, label %cleanup25

if.then18:                                        ; preds = %if.end15
  %call19 = call fastcc %struct.io_kiocb* @io_put_req_find_next(%struct.io_kiocb* noundef %req) #25
  %tobool20.not = icmp eq %struct.io_kiocb* %call19, null
  br i1 %tobool20.not, label %cleanup25, label %if.then21

if.then21:                                        ; preds = %if.then18
  call void @io_req_task_submit(%struct.io_kiocb* noundef nonnull %call19, i8* noundef %locked) #25
  br label %cleanup25

cleanup25:                                        ; preds = %if.then4, %if.then18, %if.then21, %if.end15, %if.then
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_poll_rewait(%struct.io_kiocb* nocapture noundef %req, %struct.io_poll_iocb* noundef %poll) unnamed_addr #1 {
entry:
  %pt = alloca %struct.poll_table_struct, align 8
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %1 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 4
  %2 = load i32, i32* %flags, align 4
  %and = and i32 %2, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %do.body5, !prof !8

do.body5:                                         ; preds = %entry
  %canceled = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  store volatile i8 1, i8* %canceled, align 1
  br label %if.end

if.end:                                           ; preds = %do.body5, %entry
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %3 = load i32, i32* %result, align 4
  %tobool10.not = icmp eq i32 %3, 0
  br i1 %tobool10.not, label %do.end13, label %if.end21

do.end13:                                         ; preds = %if.end
  %canceled14 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  %4 = load volatile i8, i8* %canceled14, align 1, !range !18
  %tobool15.not = icmp eq i8 %4, 0
  br i1 %tobool15.not, label %if.then17, label %if.end21

if.then17:                                        ; preds = %do.end13
  %5 = bitcast %struct.poll_table_struct* %pt to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #26
  %_key = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %pt, i64 0, i32 1
  %events = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 2
  %6 = bitcast %struct.poll_table_struct* %pt to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %6, i8 0, i64 16, i1 false)
  %7 = load i32, i32* %events, align 8
  store i32 %7, i32* %_key, align 8
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %8 = load %struct.file*, %struct.file** %file, align 8
  %call = call fastcc i32 @vfs_poll(%struct.file* noundef %8, %struct.poll_table_struct* noundef nonnull %pt) #25
  %9 = load i32, i32* %events, align 8
  %and19 = and i32 %9, %call
  store i32 %and19, i32* %result, align 4
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #26
  br label %if.end21

if.end21:                                         ; preds = %if.then17, %do.end13, %if.end
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %10 = load i32, i32* %result, align 4
  %tobool23.not = icmp eq i32 %10, 0
  br i1 %tobool23.not, label %do.end27, label %cleanup

do.end27:                                         ; preds = %if.end21
  %canceled29 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  %11 = load volatile i8, i8* %canceled29, align 1, !range !18
  %tobool30.not = icmp eq i8 %11, 0
  br i1 %tobool30.not, label %if.then33, label %cleanup

if.then33:                                        ; preds = %do.end27
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 1
  %12 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %wait = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5
  call void @add_wait_queue(%struct.wait_queue_head* noundef %12, %struct.wait_queue_entry* noundef %wait) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %do.end27, %if.then33
  %retval.0 = phi i1 [ true, %if.then33 ], [ false, %do.end27 ], [ false, %if.end21 ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_poll_complete(%struct.io_kiocb* noundef %req, i32 noundef %mask) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %poll = bitcast %struct.io_kiocb* %req to %struct.io_poll_iocb*
  %canceled = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  %1 = load volatile i8, i8* %canceled, align 1, !range !18
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %events = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %2 = bitcast void (%struct.kiocb*, i64, i64)** %events to i32*
  %3 = load i32, i32* %2, align 8
  %or = or i32 %3, 1073741824
  store i32 %or, i32* %2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call = call fastcc i16 @mangle_poll(i32 noundef %mask) #25
  %phi.cast = zext i16 %call to i64
  %events5.phi.trans.insert = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %.phi.trans.insert = bitcast void (%struct.kiocb*, i64, i64)** %events5.phi.trans.insert to i32*
  %.pre = load i32, i32* %.phi.trans.insert, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.pre-phi = phi i32* [ %.phi.trans.insert, %if.else ], [ %2, %if.then ]
  %4 = phi i32 [ %.pre, %if.else ], [ %or, %if.then ]
  %error.0 = phi i64 [ %phi.cast, %if.else ], [ -125, %if.then ]
  %and = lshr i32 %4, 29
  %5 = and i32 %and, 2
  %6 = xor i32 %5, 2
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  %7 = load i64, i64* %user_data, align 8
  %call10 = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %0, i64 noundef %7, i64 noundef %error.0, i32 noundef %6) #25
  br i1 %call10, label %if.end15, label %if.end15.thread

if.end15.thread:                                  ; preds = %if.end
  %8 = load i32, i32* %.pre-phi, align 8
  %or14 = or i32 %8, 1073741824
  store i32 %or14, i32* %.pre-phi, align 8
  br label %if.end19

if.end15:                                         ; preds = %if.end
  %tobool17.not = icmp eq i32 %6, 0
  br i1 %tobool17.not, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  %cq_extra = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 5
  %9 = load i32, i32* %cq_extra, align 64
  %inc = add i32 %9, 1
  store i32 %inc, i32* %cq_extra, align 64
  br label %if.end19

if.end19:                                         ; preds = %if.end15.thread, %if.then18, %if.end15
  %tobool17.not36 = phi i1 [ true, %if.end15.thread ], [ false, %if.then18 ], [ true, %if.end15 ]
  ret i1 %tobool17.not36
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @hash_del(%struct.hlist_node* nocapture noundef %node) unnamed_addr #9 {
entry:
  call fastcc void @hlist_del_init(%struct.hlist_node* noundef %node) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @io_put_req_find_next(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @req_ref_put_and_test(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call fastcc %struct.io_kiocb* @io_req_find_next(%struct.io_kiocb* noundef %req) #25
  call fastcc void @__io_free_req(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %nxt.0 = phi %struct.io_kiocb* [ %call1, %if.then ], [ null, %entry ]
  ret %struct.io_kiocb* %nxt.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i16 @mangle_poll(i32 noundef %val) unnamed_addr #0 {
entry:
  %0 = trunc i32 %val to i16
  %conv45 = and i16 %0, 10239
  ret i16 %conv45
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @hlist_del_init(%struct.hlist_node* nocapture noundef %n) unnamed_addr #9 {
entry:
  %call = call fastcc i32 @hlist_unhashed(%struct.hlist_node* noundef %n) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @__hlist_del(%struct.hlist_node* noundef %n) #25
  call fastcc void @INIT_HLIST_NODE(%struct.hlist_node* noundef %n) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @hlist_unhashed(%struct.hlist_node* nocapture noundef readonly %h) unnamed_addr #3 {
entry:
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i64 0, i32 1
  %0 = load %struct.hlist_node**, %struct.hlist_node*** %pprev, align 8
  %tobool.not = icmp eq %struct.hlist_node** %0, null
  %lnot.ext = zext i1 %tobool.not to i32
  ret i32 %lnot.ext
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @__hlist_del(%struct.hlist_node* nocapture noundef readonly %n) unnamed_addr #9 {
entry:
  %next1 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i64 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %next1, align 8
  %pprev2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i64 0, i32 1
  %1 = load %struct.hlist_node**, %struct.hlist_node*** %pprev2, align 8
  store volatile %struct.hlist_node* %0, %struct.hlist_node** %1, align 8
  %tobool.not = icmp eq %struct.hlist_node* %0, null
  br i1 %tobool.not, label %if.end, label %do.body13

do.body13:                                        ; preds = %entry
  %pprev14 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i64 0, i32 1
  store volatile %struct.hlist_node** %1, %struct.hlist_node*** %pprev14, align 8
  br label %if.end

if.end:                                           ; preds = %do.body13, %entry
  ret void
}

; Function Attrs: nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly
define internal fastcc %struct.io_kiocb* @io_poll_find(%struct.io_ring_ctx* nocapture noundef readonly %ctx, i64 noundef %sqe_addr, i1 noundef %poll_only) unnamed_addr #7 {
entry:
  %cancel_hash = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 3
  %0 = load %struct.hlist_head*, %struct.hlist_head** %cancel_hash, align 8
  %cancel_hash_bits = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 4
  %1 = load i32, i32* %cancel_hash_bits, align 32
  %mul.i = mul i64 %sqe_addr, 7046029254386353131
  %sub.i = sub i32 64, %1
  %sh_prom.i = zext i32 %sub.i to i64
  %shr.i = lshr i64 %mul.i, %sh_prom.i
  %idxprom = and i64 %shr.i, 4294967295
  %first = getelementptr %struct.hlist_head, %struct.hlist_head* %0, i64 %idxprom, i32 0
  %2 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8
  %tobool.not = icmp eq %struct.hlist_node* %2, null
  %add.ptr38 = getelementptr %struct.hlist_node, %struct.hlist_node* %2, i64 -10
  %tobool2.not4146 = icmp eq %struct.hlist_node* %add.ptr38, null
  %tobool2.not41 = or i1 %tobool.not, %tobool2.not4146
  br i1 %tobool2.not41, label %cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %3 = bitcast %struct.hlist_node* %add.ptr38 to %struct.io_kiocb*
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %req.042 = phi %struct.io_kiocb* [ %spec.select40, %for.inc ], [ %3, %for.body.preheader ]
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.042, i64 0, i32 10
  %4 = load i64, i64* %user_data, align 8
  %cmp.not = icmp eq i64 %4, %sqe_addr
  br i1 %cmp.not, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  br i1 %poll_only, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.042, i64 0, i32 2
  %5 = load i8, i8* %opcode, align 8
  %cmp4.not = icmp eq i8 %5, 6
  br i1 %cmp4.not, label %cleanup, label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %next = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.042, i64 0, i32 15, i32 0
  %6 = load %struct.hlist_node*, %struct.hlist_node** %next, align 8
  %tobool10.not = icmp eq %struct.hlist_node* %6, null
  %add.ptr1737 = getelementptr %struct.hlist_node, %struct.hlist_node* %6, i64 -10
  %7 = bitcast %struct.hlist_node* %add.ptr1737 to %struct.io_kiocb*
  %spec.select40 = select i1 %tobool10.not, %struct.io_kiocb* null, %struct.io_kiocb* %7
  %tobool2.not = icmp eq %struct.io_kiocb* %spec.select40, null
  br i1 %tobool2.not, label %cleanup, label %for.body

cleanup:                                          ; preds = %land.lhs.true, %if.end, %for.inc, %entry
  %req.0.lcssa = phi %struct.io_kiocb* [ null, %entry ], [ null, %for.inc ], [ %req.042, %if.end ], [ %req.042, %land.lhs.true ]
  ret %struct.io_kiocb* %req.0.lcssa
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_poll_remove_one(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  call fastcc void @io_poll_remove_double(%struct.io_kiocb* noundef %req) #25
  %call = call fastcc %struct.io_poll_iocb* @io_poll_get_single(%struct.io_kiocb* noundef %req) #25
  %call1 = call fastcc i1 @__io_poll_remove_one(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %call, i1 noundef true) #25
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  %1 = load i64, i64* %user_data, align 8
  %call2 = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %0, i64 noundef %1, i64 noundef -125, i32 noundef 0) #25
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %2) #25
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i1 %call1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @__io_poll_remove_one(%struct.io_kiocb* nocapture noundef %req, %struct.io_poll_iocb* noundef %poll, i1 noundef %do_cancel) unnamed_addr #1 {
entry:
  %head = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 1
  %0 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %tobool.not = icmp eq %struct.wait_queue_head* %0, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %rlock.i = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %0, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  br i1 %do_cancel, label %do.body5, label %if.end10

do.body5:                                         ; preds = %if.end
  %canceled = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 4
  store volatile i8 1, i8* %canceled, align 1
  br label %if.end10

if.end10:                                         ; preds = %do.body5, %if.end
  %entry11 = getelementptr inbounds %struct.io_poll_iocb, %struct.io_poll_iocb* %poll, i64 0, i32 5, i32 3
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %entry11) #25
  %tobool12.not = icmp eq i32 %call, 0
  br i1 %tobool12.not, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end10
  call fastcc void @list_del_init(%struct.list_head* noundef %entry11) #25
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end10
  %1 = load %struct.wait_queue_head*, %struct.wait_queue_head** %head, align 8
  %rlock.i25 = getelementptr inbounds %struct.wait_queue_head, %struct.wait_queue_head* %1, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i25) #27
  %hash_node = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 15
  call fastcc void @hash_del(%struct.hlist_node* noundef %hash_node) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end16
  %retval.0 = phi i1 [ %tobool12.not, %if.end16 ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @sync_file_range(%struct.file* noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @io_is_timeout_noseq(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #3 {
entry:
  %off = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %0 = bitcast i64* %off to i32*
  %1 = load i32, i32* %0, align 8
  %tobool.not = icmp eq i32 %1, 0
  ret i1 %tobool.not
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_timeout_fn(%struct.hrtimer* nocapture noundef readonly %timer) #1 {
entry:
  %0 = getelementptr %struct.hrtimer, %struct.hrtimer* %timer, i64 -1, i32 4
  %req1 = bitcast i8* %0 to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %req1, align 8
  %ctx2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 11, i32 1, i32 0, i32 0
  %call6 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 0, i32 0, i32 0, i32 2
  %3 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @list_del_init(%struct.list_head* noundef %3) #25
  %4 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %4, i64 0, i32 10, i32 6, i32 0
  %5 = load volatile i32, i32* %counter.i, align 4
  %add = add i32 %5, 1
  store volatile i32 %add, i32* %counter.i, align 4
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call6) #27
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_req_task_timeout, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %1) #25
  ret i32 0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @hrtimer_start(%struct.hrtimer* noundef %timer, i64 noundef %tim, i32 noundef %mode) unnamed_addr #1 {
entry:
  call void @hrtimer_start_range_ns(%struct.hrtimer* noundef %timer, i64 noundef %tim, i64 noundef 0, i32 noundef %mode) #27
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @timespec64_to_ktime([2 x i64] %ts.coerce) unnamed_addr #0 {
entry:
  %ts.coerce.fca.0.extract = extractvalue [2 x i64] %ts.coerce, 0
  %ts.coerce.fca.1.extract = extractvalue [2 x i64] %ts.coerce, 1
  %call = call fastcc i64 @ktime_set(i64 noundef %ts.coerce.fca.0.extract, i64 noundef %ts.coerce.fca.1.extract) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_req_task_timeout(%struct.io_kiocb* noundef %req, i8* nocapture noundef readnone %locked) #1 {
entry:
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef -62, i32 noundef 0) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @hrtimer_start_range_ns(%struct.hrtimer* noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @ktime_set(i64 noundef %secs, i64 noundef %nsecs) unnamed_addr #0 {
entry:
  %cmp = icmp sgt i64 %secs, 9223372035
  %mul = mul i64 %secs, 1000000000
  %add = add i64 %mul, %nsecs
  %retval.0 = select i1 %cmp, i64 9223372036854775807, i64 %add, !prof !24
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_timeout_cancel(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_kiocb* @io_timeout_extract(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data) #25
  %0 = bitcast %struct.io_kiocb* %call to i8*
  %call1 = call fastcc i1 @IS_ERR(i8* noundef %0) #25
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call fastcc i64 @PTR_ERR(i8* noundef %0) #25
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %call) #25
  %user_data3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 10
  %1 = load i64, i64* %user_data3, align 8
  %call4 = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %ctx, i64 noundef %1, i64 noundef -125, i32 noundef 0) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef %call) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @io_translate_timeout_mode(i32 noundef %flags) unnamed_addr #0 {
entry:
  %and = and i32 %flags, 1
  %0 = xor i32 %and, 1
  ret i32 %0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_linked_timeout_update(%struct.io_ring_ctx* noundef readonly %ctx, i64 noundef %user_data, %struct.timespec64* nocapture noundef readonly %ts, i32 noundef %mode) unnamed_addr #1 {
entry:
  %ltimeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 13
  %0 = bitcast %struct.list_head* %ltimeout_list to i8**
  %.pn46 = load i8*, i8** %0, align 8
  %1 = bitcast i8* %.pn46 to %struct.list_head*
  %cmp.not47 = icmp eq %struct.list_head* %ltimeout_list, %1
  br i1 %cmp.not47, label %cleanup, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %.pn48 = phi i8* [ %.pn, %for.inc ], [ %.pn46, %entry ]
  %user_data2 = getelementptr i8, i8* %.pn48, i64 88
  %2 = bitcast i8* %user_data2 to i64*
  %3 = load i64, i64* %2, align 8
  %cmp3 = icmp eq i64 %3, %user_data
  br i1 %cmp3, label %if.end15, label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = bitcast i8* %.pn48 to i8**
  %.pn = load i8*, i8** %4, align 8
  %5 = bitcast i8* %.pn to %struct.list_head*
  %cmp.not = icmp eq %struct.list_head* %ltimeout_list, %5
  br i1 %cmp.not, label %cleanup, label %for.body

if.end15:                                         ; preds = %for.body
  %async_data = getelementptr i8, i8* %.pn48, i64 48
  %6 = bitcast i8* %async_data to %struct.io_timeout_data**
  %7 = load %struct.io_timeout_data*, %struct.io_timeout_data** %6, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %7, i64 0, i32 1
  %call = call i32 @hrtimer_try_to_cancel(%struct.hrtimer* noundef %timer) #27
  %cmp16 = icmp eq i32 %call, -1
  br i1 %cmp16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end15
  %call20 = call fastcc i32 @io_timeout_get_clock(%struct.io_timeout_data* noundef %7) #25, !range !97
  call void @hrtimer_init(%struct.hrtimer* noundef %timer, i32 noundef %call20, i32 noundef %mode) #27
  %function = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %7, i64 0, i32 1, i32 2
  store i32 (%struct.hrtimer*)* @io_link_timeout_fn, i32 (%struct.hrtimer*)** %function, align 8
  %.elt = getelementptr %struct.timespec64, %struct.timespec64* %ts, i64 0, i32 0
  %.unpack = load i64, i64* %.elt, align 8
  %8 = insertvalue [2 x i64] undef, i64 %.unpack, 0
  %9 = getelementptr inbounds %struct.timespec64, %struct.timespec64* %ts, i64 0, i32 1
  %.unpack43 = load i64, i64* %9, align 8
  %10 = insertvalue [2 x i64] %8, i64 %.unpack43, 1
  %call23 = call fastcc i64 @timespec64_to_ktime([2 x i64] %10) #25
  call fastcc void @hrtimer_start(%struct.hrtimer* noundef %timer, i64 noundef %call23, i32 noundef %mode) #25
  br label %cleanup

cleanup:                                          ; preds = %for.inc, %entry, %if.end15, %if.end18
  %retval.0 = phi i32 [ 0, %if.end18 ], [ -114, %if.end15 ], [ -2, %entry ], [ -2, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_timeout_update(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data, %struct.timespec64* nocapture noundef readonly %ts, i32 noundef %mode) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_kiocb* @io_timeout_extract(%struct.io_ring_ctx* noundef %ctx, i64 noundef %user_data) #25
  %0 = bitcast %struct.io_kiocb* %call to i8*
  %call1 = call fastcc i1 @IS_ERR(i8* noundef %0) #25
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call fastcc i64 @PTR_ERR(i8* noundef %0) #25
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %off = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 0, i32 0, i32 0, i32 1
  %1 = bitcast i64* %off to i32*
  store i32 0, i32* %1, align 8
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 1
  %2 = bitcast i8** %async_data to %struct.io_timeout_data**
  %3 = load %struct.io_timeout_data*, %struct.io_timeout_data** %2, align 8
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 0, i32 0, i32 0, i32 2
  %4 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  %timeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 12
  call fastcc void @list_add_tail(%struct.list_head* noundef %4, %struct.list_head* noundef %timeout_list) #25
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %3, i64 0, i32 1
  %call4 = call fastcc i32 @io_timeout_get_clock(%struct.io_timeout_data* noundef %3) #25, !range !97
  call void @hrtimer_init(%struct.hrtimer* noundef %timer, i32 noundef %call4, i32 noundef %mode) #27
  %function = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %3, i64 0, i32 1, i32 2
  store i32 (%struct.hrtimer*)* @io_timeout_fn, i32 (%struct.hrtimer*)** %function, align 8
  %.elt = getelementptr %struct.timespec64, %struct.timespec64* %ts, i64 0, i32 0
  %.unpack = load i64, i64* %.elt, align 8
  %5 = insertvalue [2 x i64] undef, i64 %.unpack, 0
  %6 = getelementptr inbounds %struct.timespec64, %struct.timespec64* %ts, i64 0, i32 1
  %.unpack21 = load i64, i64* %6, align 8
  %7 = insertvalue [2 x i64] %5, i64 %.unpack21, 1
  %call7 = call fastcc i64 @timespec64_to_ktime([2 x i64] %7) #25
  call fastcc void @hrtimer_start(%struct.hrtimer* noundef %timer, i64 noundef %call7, i32 noundef %mode) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @io_timeout_extract(%struct.io_ring_ctx* noundef readonly %ctx, i64 noundef %user_data) unnamed_addr #1 {
entry:
  %timeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 12
  %0 = bitcast %struct.list_head* %timeout_list to i8**
  %.pn43 = load i8*, i8** %0, align 8
  %1 = bitcast i8* %.pn43 to %struct.list_head*
  %cmp.not44 = icmp eq %struct.list_head* %timeout_list, %1
  br i1 %cmp.not44, label %if.then14, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %.pn45 = phi i8* [ %.pn, %for.inc ], [ %.pn43, %entry ]
  %user_data2 = getelementptr i8, i8* %.pn45, i64 88
  %2 = bitcast i8* %user_data2 to i64*
  %3 = load i64, i64* %2, align 8
  %cmp3 = icmp eq i64 %3, %user_data
  br i1 %cmp3, label %if.end15, label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = bitcast i8* %.pn45 to i8**
  %.pn = load i8*, i8** %4, align 8
  %5 = bitcast i8* %.pn to %struct.list_head*
  %cmp.not = icmp eq %struct.list_head* %timeout_list, %5
  br i1 %cmp.not, label %if.then14, label %for.body

if.then14:                                        ; preds = %for.inc, %entry
  %call = call fastcc i8* @ERR_PTR(i64 noundef -2) #25
  br label %cleanup

if.end15:                                         ; preds = %for.body
  %async_data = getelementptr i8, i8* %.pn45, i64 48
  %6 = bitcast i8* %async_data to %struct.io_timeout_data**
  %7 = load %struct.io_timeout_data*, %struct.io_timeout_data** %6, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %7, i64 0, i32 1
  %call16 = call i32 @hrtimer_try_to_cancel(%struct.hrtimer* noundef %timer) #27
  %cmp17 = icmp eq i32 %call16, -1
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %call19 = call fastcc i8* @ERR_PTR(i64 noundef -114) #25
  br label %cleanup

if.end20:                                         ; preds = %if.end15
  %8 = bitcast i8* %.pn45 to %struct.list_head*
  %req.0.in.le = getelementptr i8, i8* %.pn45, i64 -16
  call fastcc void @list_del_init(%struct.list_head* noundef %8) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.then18, %if.then14
  %retval.0.in = phi i8* [ %call19, %if.then18 ], [ %req.0.in.le, %if.end20 ], [ %call, %if.then14 ]
  %retval.0 = bitcast i8* %retval.0.in to %struct.io_kiocb*
  ret %struct.io_kiocb* %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @hrtimer_init(%struct.hrtimer* noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_timeout_get_clock(%struct.io_timeout_data* nocapture noundef readonly %data) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %data, i64 0, i32 4
  %0 = load i32, i32* %flags, align 4
  %and = and i32 %0, 12
  switch i32 %and, label %if.then [
    i32 4, label %return
    i32 8, label %sw.bb1
    i32 0, label %sw.bb11
  ]

sw.bb1:                                           ; preds = %entry
  br label %return

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 5993; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !98
  br label %sw.bb11

sw.bb11:                                          ; preds = %entry, %if.then
  br label %return

return:                                           ; preds = %entry, %sw.bb11, %sw.bb1
  %retval.0 = phi i32 [ 1, %sw.bb11 ], [ 0, %sw.bb1 ], [ 7, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_link_timeout_fn(%struct.hrtimer* nocapture noundef readonly %timer) #1 {
entry:
  %0 = getelementptr %struct.hrtimer, %struct.hrtimer* %timer, i64 -1, i32 4
  %req1 = bitcast i8* %0 to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %req1, align 8
  %ctx2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 11, i32 1, i32 0, i32 0
  %call6 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  %head = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 0, i32 0, i32 0, i32 4
  %3 = bitcast i32* %head to %struct.io_kiocb**
  %4 = load %struct.io_kiocb*, %struct.io_kiocb** %3, align 8
  store %struct.io_kiocb* null, %struct.io_kiocb** %3, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %4, null
  br i1 %tobool.not, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_remove_next_linked(%struct.io_kiocb* noundef nonnull %4) #25
  %call13 = call fastcc i1 @req_ref_inc_not_zero(%struct.io_kiocb* noundef nonnull %4) #25
  %spec.select = select i1 %call13, %struct.io_kiocb* %4, %struct.io_kiocb* null
  br label %if.end15

if.end15:                                         ; preds = %if.then, %entry
  %prev.0 = phi %struct.io_kiocb* [ null, %entry ], [ %spec.select, %if.then ]
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 0, i32 0, i32 0, i32 2
  %5 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %5) #25
  %prev18 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 0, i32 0, i32 0, i32 7
  %6 = bitcast %union.anon.40* %prev18 to %struct.io_kiocb**
  store %struct.io_kiocb* %prev.0, %struct.io_kiocb** %6, align 8
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call6) #27
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_req_task_link_timeout, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %1) #25
  ret i32 0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @req_ref_inc_not_zero(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1144; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !99
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 8
  %counter.i.i.i.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i64 0, i32 0
  %1 = load volatile i32, i32* %counter.i.i.i.i, align 4
  %2 = bitcast %struct.atomic_t* %refs to i8*
  br label %do.body.i.i.i.i

do.body.i.i.i.i:                                  ; preds = %do.cond.i.i.i.i, %if.end
  %c.0.i.i.i.i = phi i32 [ %1, %if.end ], [ %call11.i.i.i.i.i.i, %do.cond.i.i.i.i ]
  %cmp.i.i.i.i = icmp eq i32 %c.0.i.i.i.i, 0
  br i1 %cmp.i.i.i.i, label %atomic_inc_not_zero.exit, label %do.cond.i.i.i.i, !prof !24

do.cond.i.i.i.i:                                  ; preds = %do.body.i.i.i.i
  %add.i.i.i.i = add i32 %c.0.i.i.i.i, 1
  %call11.i.i.i.i.i.i = call fastcc i32 @__cmpxchg_case_mb_32(i8* noundef %2, i32 noundef %c.0.i.i.i.i, i32 noundef %add.i.i.i.i) #27
  %cmp.not.i.i.i.i.i = icmp eq i32 %c.0.i.i.i.i, %call11.i.i.i.i.i.i
  br i1 %cmp.not.i.i.i.i.i, label %atomic_inc_not_zero.exit, label %do.body.i.i.i.i, !prof !8

atomic_inc_not_zero.exit:                         ; preds = %do.body.i.i.i.i, %do.cond.i.i.i.i
  %3 = xor i1 %cmp.i.i.i.i, true
  ret i1 %3
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_req_task_link_timeout(%struct.io_kiocb* noundef %req, i8* nocapture noundef readnone %locked) #1 {
entry:
  %prev1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %0 = bitcast %union.anon.40* %prev1 to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %0, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %1, null
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 10
  %2 = load i64, i64* %user_data, align 8
  %call = call fastcc i32 @io_try_cancel_userdata(%struct.io_kiocb* noundef %req, i64 noundef %2) #25
  %tobool2.not = icmp eq i32 %call, 0
  %. = select i1 %tobool2.not, i32 -62, i32 %call
  %conv = sext i32 %. to i64
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef %conv, i32 noundef 0) #25
  call fastcc void @io_put_req(%struct.io_kiocb* noundef nonnull %1) #25
  br label %if.end

if.else:                                          ; preds = %entry
  call fastcc void @io_req_complete_post(%struct.io_kiocb* noundef %req, i64 noundef -62, i32 noundef 0) #25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_try_cancel_userdata(%struct.io_kiocb* nocapture noundef readonly %req, i64 noundef %sqe_addr) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %call = call fastcc i1 @io_wq_current_is_worker() #25
  br i1 %call, label %if.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %1 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %2 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %3 = inttoptr i64 %2 to %struct.task_struct*
  %cmp.not = icmp eq %struct.task_struct* %1, %3
  br i1 %cmp.not, label %if.end, label %if.then, !prof !8

if.then:                                          ; preds = %land.rhs
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 6260; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !100
  br label %if.end

if.end:                                           ; preds = %entry, %if.then, %land.rhs
  %task16 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  %4 = load %struct.task_struct*, %struct.task_struct** %task16, align 8
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 85
  %5 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %call17 = call fastcc i32 @io_async_cancel_one(%struct.io_uring_task* noundef %5, i64 noundef %sqe_addr, %struct.io_ring_ctx* noundef %0) #25
  %cmp18.not = icmp eq i32 %call17, -2
  br i1 %cmp18.not, label %if.end21, label %cleanup

if.end21:                                         ; preds = %if.end
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %rlock.i48 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i48) #27
  %call22 = call fastcc i32 @io_timeout_cancel(%struct.io_ring_ctx* noundef %0, i64 noundef %sqe_addr) #25
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i48) #27
  %cmp24.not = icmp eq i32 %call22, -2
  br i1 %cmp24.not, label %if.end27, label %out

if.end27:                                         ; preds = %if.end21
  %call28 = call fastcc i32 @io_poll_cancel(%struct.io_ring_ctx* noundef %0, i64 noundef %sqe_addr) #25
  br label %out

out:                                              ; preds = %if.end21, %if.end27
  %ret.0 = phi i32 [ %call22, %if.end21 ], [ %call28, %if.end27 ]
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %out
  %retval.0 = phi i32 [ %ret.0, %out ], [ %call17, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_async_cancel_one(%struct.io_uring_task* noundef readonly %tctx, i64 noundef %user_data, %struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %data = alloca %struct.io_cancel_data, align 8
  %0 = bitcast %struct.io_cancel_data* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %0) #26
  %ctx1 = getelementptr inbounds %struct.io_cancel_data, %struct.io_cancel_data* %data, i64 0, i32 0
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %ctx1, align 8
  %user_data2 = getelementptr inbounds %struct.io_cancel_data, %struct.io_cancel_data* %data, i64 0, i32 1
  store i64 %user_data, i64* %user_data2, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %tctx, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 4
  %1 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool3.not = icmp eq %struct.io_wq* %1, null
  br i1 %tobool3.not, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = call i32 @io_wq_cancel_cb(%struct.io_wq* noundef nonnull %1, i1 (%struct.io_wq_work*, i8*)* noundef nonnull @io_cancel_cb, i8* noundef nonnull %0, i1 noundef false) #27
  %switch.selectcmp = icmp eq i32 %call, 1
  %switch.select = select i1 %switch.selectcmp, i32 -114, i32 0
  %switch.selectcmp13 = icmp eq i32 %call, 2
  %switch.select14 = select i1 %switch.selectcmp13, i32 -2, i32 %switch.select
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ -2, %lor.lhs.false ], [ -2, %entry ], [ %switch.select14, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_poll_cancel(%struct.io_ring_ctx* nocapture noundef readonly %ctx, i64 noundef %sqe_addr) unnamed_addr #1 {
entry:
  %call = call fastcc %struct.io_kiocb* @io_poll_find(%struct.io_ring_ctx* noundef %ctx, i64 noundef %sqe_addr, i1 noundef false) #25
  %tobool1.not = icmp eq %struct.io_kiocb* %call, null
  br i1 %tobool1.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call fastcc i1 @io_poll_remove_one(%struct.io_kiocb* noundef nonnull %call) #25
  %. = select i1 %call2, i32 0, i32 -114
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -2, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal i1 @io_cancel_cb(%struct.io_wq_work* nocapture noundef readonly %work, i8* nocapture noundef readonly %data) #3 {
entry:
  %add.ptr = getelementptr %struct.io_wq_work, %struct.io_wq_work* %work, i64 -12, i32 1
  %ctx = getelementptr inbounds i32, i32* %add.ptr, i64 20
  %0 = bitcast i32* %ctx to %struct.io_ring_ctx**
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %0, align 8
  %ctx1 = bitcast i8* %data to %struct.io_ring_ctx**
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %cmp = icmp eq %struct.io_ring_ctx* %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %user_data = getelementptr inbounds i32, i32* %add.ptr, i64 26
  %3 = bitcast i32* %user_data to i64*
  %4 = load i64, i64* %3, align 8
  %user_data2 = getelementptr inbounds i8, i8* %data, i64 8
  %5 = bitcast i8* %user_data2 to i64*
  %6 = load i64, i64* %5, align 8
  %cmp3 = icmp eq i64 %4, %6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %7
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @vfs_fallocate(%struct.file* noundef, i32 noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_close_fixed(%struct.io_kiocb* nocapture noundef readonly %req, i32 noundef %issue_flags) unnamed_addr #1 {
entry:
  %close = bitcast %struct.io_kiocb* %req to %struct.io_close*
  %file_slot = getelementptr inbounds %struct.io_close, %struct.io_close* %close, i64 0, i32 2
  %0 = load i32, i32* %file_slot, align 4
  %sub = add i32 %0, -1
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %1, i1 noundef %tobool.not) #25
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 13, i32 2
  %2 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %tobool3.not = icmp eq %struct.io_rsrc_data* %2, null
  br i1 %tobool3.not, label %out, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 8
  %3 = load i32, i32* %nr_user_files, align 8
  %cmp.not = icmp ult i32 %sub, %3
  br i1 %cmp.not, label %if.end10, label %out

if.end10:                                         ; preds = %if.end
  %call = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %1) #25
  %tobool11.not = icmp eq i32 %call, 0
  br i1 %tobool11.not, label %if.end13, label %out

if.end13:                                         ; preds = %if.end10
  %4 = load i32, i32* %nr_user_files, align 8
  %conv15 = zext i32 %sub to i64
  %conv16 = zext i32 %4 to i64
  %call17 = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv15, i64 noundef %conv16) #25
  %5 = trunc i64 %call17 to i32
  %conv23 = and i32 %sub, %5
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 7
  %call24 = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %conv23) #25
  %file_ptr = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %call24, i64 0, i32 0
  %6 = load i64, i64* %file_ptr, align 8
  %tobool25.not = icmp eq i64 %6, 0
  br i1 %tobool25.not, label %out, label %if.end27

if.end27:                                         ; preds = %if.end13
  %and29 = and i64 %6, -8
  %7 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 6
  %8 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %9 = inttoptr i64 %and29 to i8*
  %call31 = call fastcc i32 @io_queue_rsrc_removal(%struct.io_rsrc_data* noundef %7, i32 noundef %sub, %struct.io_rsrc_node* noundef %8, i8* noundef %9) #25
  %tobool32.not = icmp eq i32 %call31, 0
  br i1 %tobool32.not, label %if.end34, label %out

if.end34:                                         ; preds = %if.end27
  store i64 0, i64* %file_ptr, align 8
  %10 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %1, %struct.io_rsrc_data* noundef %10) #25
  br label %out

out:                                              ; preds = %if.end27, %if.end13, %if.end10, %if.end, %entry, %if.end34
  %ret.0 = phi i32 [ -6, %entry ], [ -22, %if.end ], [ %call, %if.end10 ], [ %call31, %if.end27 ], [ 0, %if.end34 ], [ -9, %if.end13 ]
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %1, i1 noundef %tobool.not) #25
  ret i32 %ret.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__close_fd_get_file(i32 noundef, %struct.file** noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @filp_close(%struct.file* noundef, i8* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #1 {
entry:
  %rsrc_backup_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 0
  %0 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  %tobool.not = icmp eq %struct.io_rsrc_node* %0, null
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = call fastcc %struct.io_rsrc_node* @io_rsrc_node_alloc() #25
  store %struct.io_rsrc_node* %call, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  %tobool3.not = icmp eq %struct.io_rsrc_node* %call, null
  %cond = select i1 %tobool3.not, i32 -12, i32 0
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %cond, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_queue_rsrc_removal(%struct.io_rsrc_data* nocapture noundef readonly %data, i32 noundef %idx, %struct.io_rsrc_node* noundef %node, i8* noundef %rsrc) unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kzalloc(i64 noundef 32, i32 noundef 3264) #25
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %data, i32 noundef %idx) #25
  %0 = load i64, i64* %call1, align 8
  %tag = getelementptr inbounds i8, i8* %call, i64 16
  %1 = bitcast i8* %tag to i64*
  store i64 %0, i64* %1, align 8
  %2 = getelementptr inbounds i8, i8* %call, i64 24
  %rsrc2 = bitcast i8* %2 to i8**
  store i8* %rsrc, i8** %rsrc2, align 8
  %list = bitcast i8* %call to %struct.list_head*
  %rsrc_list = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %node, i64 0, i32 2
  call fastcc void @list_add(%struct.list_head* noundef nonnull %list, %struct.list_head* noundef %rsrc_list) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef %data_to_kill) unnamed_addr #1 {
entry:
  %rsrc_backup_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 0
  %0 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  %tobool.not = icmp eq %struct.io_rsrc_node* %0, null
  br i1 %tobool.not, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7700; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !101
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool17.not = icmp eq %struct.io_rsrc_data* %data_to_kill, null
  %rsrc_node51.phi.trans.insert = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 6
  %.pre79 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node51.phi.trans.insert, align 8
  %phi.cmp = icmp eq %struct.io_rsrc_node* %.pre79, null
  br i1 %tobool17.not, label %if.end50, label %land.rhs

land.rhs:                                         ; preds = %if.end
  br i1 %phi.cmp, label %if.then33, label %if.end50.thread, !prof !24

if.then33:                                        ; preds = %land.rhs
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 7701; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !102
  %.pre = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node51.phi.trans.insert, align 8
  br label %if.end50.thread

if.end50.thread:                                  ; preds = %if.then33, %land.rhs
  %1 = phi %struct.io_rsrc_node* [ %.pre79, %land.rhs ], [ %.pre, %if.then33 ]
  %rsrc_data = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %1, i64 0, i32 3
  store %struct.io_rsrc_data* %data_to_kill, %struct.io_rsrc_data** %rsrc_data, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 7, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %node = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %1, i64 0, i32 1
  %rsrc_ref_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 6
  call fastcc void @list_add_tail(%struct.list_head* noundef %node, %struct.list_head* noundef %rsrc_ref_list) #25
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %refs = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data_to_kill, i64 0, i32 4
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %refs) #27
  %refs48 = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %1, i64 0, i32 0
  call fastcc void @percpu_ref_kill(%struct.percpu_ref* noundef %refs48) #25
  br label %if.then53

if.end50:                                         ; preds = %if.end
  br i1 %phi.cmp, label %if.then53, label %if.end57

if.then53:                                        ; preds = %if.end50.thread, %if.end50
  %rsrc_node51 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 6
  %2 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  store %struct.io_rsrc_node* %2, %struct.io_rsrc_node** %rsrc_node51, align 8
  store %struct.io_rsrc_node* null, %struct.io_rsrc_node** %rsrc_backup_node, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then53, %if.end50
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_rsrc_node* @io_rsrc_node_alloc() unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kzalloc(i64 noundef 72, i32 noundef 3264) #25
  %0 = bitcast i8* %call to %struct.io_rsrc_node*
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %refs = bitcast i8* %call to %struct.percpu_ref*
  %call1 = call i32 @percpu_ref_init(%struct.percpu_ref* noundef nonnull %refs, void (%struct.percpu_ref*)* noundef nonnull @io_rsrc_node_ref_zero, i32 noundef 0, i32 noundef 3264) #27
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @kfree(i8* noundef nonnull %call) #27
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %node = getelementptr inbounds i8, i8* %call, i64 16
  %1 = bitcast i8* %node to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %1) #25
  %rsrc_list = getelementptr inbounds i8, i8* %call, i64 32
  %2 = bitcast i8* %rsrc_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %2) #25
  %3 = getelementptr inbounds i8, i8* %call, i64 64
  store i8 0, i8* %3, align 8
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4, %if.then3
  %retval.0 = phi %struct.io_rsrc_node* [ null, %if.then3 ], [ %0, %if.end4 ], [ null, %entry ]
  ret %struct.io_rsrc_node* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kzalloc(i64 noundef %size, i32 noundef %flags) unnamed_addr #1 {
entry:
  %or = or i32 %flags, 256
  %call10.i = call noalias align 128 i8* @__kmalloc(i64 noundef %size, i32 noundef %or) #27
  ret i8* %call10.i
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @percpu_ref_init(%struct.percpu_ref* noundef, void (%struct.percpu_ref*)* noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_rsrc_node_ref_zero(%struct.percpu_ref* nocapture noundef %ref) #1 {
entry:
  %rsrc_data = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 3
  %0 = bitcast %struct.percpu_ref* %rsrc_data to %struct.io_rsrc_data**
  %1 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %0, align 8
  %ctx1 = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %1, i64 0, i32 0
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 13, i32 7, i32 0, i32 0
  %call5 = call fastcc i64 @__raw_spin_lock_irqsave(%struct.raw_spinlock* noundef %rlock.i) #25
  %done = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 4
  %3 = bitcast %struct.percpu_ref* %done to i8*
  store i8 1, i8* %3, align 8
  %rsrc_ref_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 13, i32 6
  %4 = bitcast %struct.list_head* %rsrc_ref_list to i8**
  %call1048 = call fastcc i32 @list_empty(%struct.list_head* noundef %rsrc_ref_list) #25
  %tobool.not49 = icmp eq i32 %call1048, 0
  br i1 %tobool.not49, label %while.body.lr.ph, label %if.end30.critedge

while.body.lr.ph:                                 ; preds = %entry
  %rsrc_put_llist = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 13, i32 5
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end
  %first_add.0.off050 = phi i1 [ false, %while.body.lr.ph ], [ %or46, %if.end ]
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr i8, i8* %5, i64 48
  %7 = load i8, i8* %6, align 8, !range !18
  %tobool19.not = icmp eq i8 %7, 0
  br i1 %tobool19.not, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %8 = bitcast i8* %5 to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %8) #25
  %llist = getelementptr i8, i8* %5, i64 40
  %9 = bitcast i8* %llist to %struct.llist_node*
  %call21 = call fastcc i1 @llist_add(%struct.llist_node* noundef %9, %struct.llist_head* noundef %rsrc_put_llist) #25
  %or46 = or i1 %first_add.0.off050, %call21
  %call10 = call fastcc i32 @list_empty(%struct.list_head* noundef %rsrc_ref_list) #25
  %tobool.not = icmp eq i32 %call10, 0
  br i1 %tobool.not, label %while.body, label %while.end

while.end:                                        ; preds = %if.end, %while.body
  %first_add.0.off0.lcssa = phi i1 [ %first_add.0.off050, %while.body ], [ %or46, %if.end ]
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call5) #27
  br i1 %first_add.0.off0.lcssa, label %if.then28, label %if.end30

if.then28:                                        ; preds = %while.end
  %10 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8
  %rsrc_put_work = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 13, i32 4
  call fastcc void @mod_delayed_work(%struct.workqueue_struct* noundef %10, %struct.delayed_work* noundef %rsrc_put_work) #25
  br label %if.end30

if.end30.critedge:                                ; preds = %entry
  call fastcc void @__raw_spin_unlock_irqrestore(%struct.raw_spinlock* noundef %rlock.i, i64 noundef %call5) #27
  br label %if.end30

if.end30:                                         ; preds = %if.end30.critedge, %if.then28, %while.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @mod_delayed_work(%struct.workqueue_struct* noundef %wq, %struct.delayed_work* noundef %dwork) unnamed_addr #1 {
entry:
  %call = call i1 @mod_delayed_work_on(i32 noundef 256, %struct.workqueue_struct* noundef %wq, %struct.delayed_work* noundef %dwork, i64 noundef 250) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @mod_delayed_work_on(i32 noundef, %struct.workqueue_struct* noundef, %struct.delayed_work* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* nocapture noundef readonly %data, i32 noundef %idx) unnamed_addr #3 {
entry:
  %and = and i32 %idx, 511
  %shr = lshr i32 %idx, 9
  %tags = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 1
  %0 = load i64**, i64*** %tags, align 8
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr i64*, i64** %0, i64 %idxprom
  %1 = load i64*, i64** %arrayidx, align 8
  %idxprom1 = zext i32 %and to i64
  %arrayidx2 = getelementptr i64, i64* %1, i64 %idxprom1
  ret i64* %arrayidx2
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i32 noundef %type, %struct.io_uring_rsrc_update2* nocapture noundef readonly %up, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %resv = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 1
  %0 = load i32, i32* %resv, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %offset = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 0
  %1 = load i32, i32* %offset, align 8
  %2 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %1, i32 %nr_args)
  %3 = extractvalue { i32, i1 } %2, 1
  br i1 %3, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool8.not = icmp eq i32 %call7, 0
  br i1 %tobool8.not, label %if.end10, label %cleanup

if.end10:                                         ; preds = %if.end6
  switch i32 %type, label %cleanup [
    i32 0, label %sw.bb
    i32 1, label %sw.bb12
  ]

sw.bb:                                            ; preds = %if.end10
  %call11 = call fastcc i32 @__io_sqe_files_update(%struct.io_ring_ctx* noundef %ctx, %struct.io_uring_rsrc_update2* noundef %up, i32 noundef %nr_args) #25
  br label %cleanup

sw.bb12:                                          ; preds = %if.end10
  %call13 = call fastcc i32 @__io_sqe_buffers_update(%struct.io_ring_ctx* noundef %ctx, %struct.io_uring_rsrc_update2* noundef %up, i32 noundef %nr_args) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end6, %if.end, %entry, %sw.bb12, %sw.bb
  %retval.0 = phi i32 [ %call13, %sw.bb12 ], [ %call11, %sw.bb ], [ -22, %entry ], [ -75, %if.end ], [ %call7, %if.end6 ], [ -22, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32) #11

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_sqe_files_update(%struct.io_ring_ctx* noundef %ctx, %struct.io_uring_rsrc_update2* nocapture noundef readonly %up, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %fd = alloca i32, align 4
  %tag = alloca i64, align 8
  %tags2 = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 3
  %0 = load i64, i64* %tags2, align 8
  %1 = inttoptr i64 %0 to i64*
  %data = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 2
  %2 = load i64, i64* %data, align 8
  %3 = inttoptr i64 %2 to i32*
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 2
  %4 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %5 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #26
  store i32 0, i32* %fd, align 4, !annotation !14
  %tobool.not = icmp eq %struct.io_rsrc_data* %4, null
  br i1 %tobool.not, label %cleanup87, label %if.end

if.end:                                           ; preds = %entry
  %offset = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 0
  %6 = load i32, i32* %offset, align 8
  %add = add i32 %6, %nr_args
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 8
  %7 = load i32, i32* %nr_user_files, align 8
  %cmp11 = icmp ugt i32 %add, %7
  br i1 %cmp11, label %cleanup87, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end
  %cmp15174.not = icmp eq i32 %nr_args, 0
  br i1 %cmp15174.not, label %if.end85.thread, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %8 = bitcast i64* %tag to i8*
  %tobool17.not = icmp eq i64 %0, 0
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 7
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 6
  %wide.trip.count = zext i32 %nr_args to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %needs_switch.0.off0177 = phi i1 [ false, %for.body.lr.ph ], [ %needs_switch.2.off0, %for.inc ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #26
  store i64 0, i64* %tag, align 8
  %9 = trunc i64 %indvars.iv to i32
  br i1 %tobool17.not, label %lor.lhs.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %arrayidx = getelementptr i64, i64* %1, i64 %indvars.iv
  %10 = bitcast i64* %arrayidx to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %8, i8* noundef %10, i64 noundef 8) #27
  %tobool18.not = icmp eq i64 %call2.i, 0
  br i1 %tobool18.not, label %lor.lhs.false, label %cleanup.thread

lor.lhs.false:                                    ; preds = %land.lhs.true, %for.body
  %arrayidx20 = getelementptr i32, i32* %3, i64 %indvars.iv
  %11 = bitcast i32* %arrayidx20 to i8*
  %call2.i159 = call fastcc i64 @_copy_from_user(i8* noundef nonnull %5, i8* noundef %11, i64 noundef 4) #27
  %tobool22.not = icmp eq i64 %call2.i159, 0
  br i1 %tobool22.not, label %if.end24, label %cleanup.thread

if.end24:                                         ; preds = %lor.lhs.false
  %12 = load i32, i32* %fd, align 4
  %13 = icmp ugt i32 %12, -3
  %14 = load i64, i64* %tag, align 8
  %tobool31 = icmp ne i64 %14, 0
  %or.cond97 = select i1 %13, i1 %tobool31, i1 false
  br i1 %or.cond97, label %cleanup.thread, label %if.end33

if.end33:                                         ; preds = %if.end24
  %cmp25 = icmp eq i32 %12, -2
  br i1 %cmp25, label %for.inc, label %if.end37

if.end37:                                         ; preds = %if.end33
  %15 = load i32, i32* %offset, align 8
  %add39 = add i32 %15, %9
  %16 = load i32, i32* %nr_user_files, align 8
  %conv41 = zext i32 %add39 to i64
  %conv42 = zext i32 %16 to i64
  %call43 = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv41, i64 noundef %conv42) #25
  %17 = trunc i64 %call43 to i32
  %conv49 = and i32 %add39, %17
  %call50 = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %conv49) #25
  %file_ptr = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %call50, i64 0, i32 0
  %18 = load i64, i64* %file_ptr, align 8
  %tobool51.not = icmp eq i64 %18, 0
  br i1 %tobool51.not, label %if.end62, label %if.then52

if.then52:                                        ; preds = %if.end37
  %and54 = and i64 %18, -8
  %19 = load i32, i32* %offset, align 8
  %add56 = add i32 %19, %9
  %20 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %21 = inttoptr i64 %and54 to i8*
  %call57 = call fastcc i32 @io_queue_rsrc_removal(%struct.io_rsrc_data* noundef nonnull %4, i32 noundef %add56, %struct.io_rsrc_node* noundef %20, i8* noundef %21) #25
  %tobool58.not = icmp eq i32 %call57, 0
  br i1 %tobool58.not, label %if.end60, label %cleanup.thread

if.end60:                                         ; preds = %if.then52
  store i64 0, i64* %file_ptr, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.end60, %if.end37
  %needs_switch.1.off0 = phi i1 [ true, %if.end60 ], [ %needs_switch.0.off0177, %if.end37 ]
  %22 = load i32, i32* %fd, align 4
  %cmp63.not = icmp eq i32 %22, -1
  br i1 %cmp63.not, label %for.inc, label %if.then65

if.then65:                                        ; preds = %if.end62
  %call66 = call %struct.file* @fget(i32 noundef %22) #27
  %tobool67.not = icmp eq %struct.file* %call66, null
  br i1 %tobool67.not, label %cleanup.thread, label %if.end69

if.end69:                                         ; preds = %if.then65
  %f_op = getelementptr inbounds %struct.file, %struct.file* %call66, i64 0, i32 3
  %23 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp70 = icmp eq %struct.file_operations* %23, @io_uring_fops
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end69
  %24 = trunc i64 %indvars.iv to i32
  call void @fput(%struct.file* noundef nonnull %call66) #27
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #26
  br i1 %needs_switch.1.off0, label %if.then84, label %if.end85

if.end73:                                         ; preds = %if.end69
  %25 = load i64, i64* %tag, align 8
  %26 = load i32, i32* %offset, align 8
  %add75 = add i32 %26, %9
  %call76 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef nonnull %4, i32 noundef %add75) #25
  store i64 %25, i64* %call76, align 8
  call fastcc void @io_fixed_file_set(%struct.io_fixed_file* noundef %call50, %struct.file* noundef nonnull %call66) #25
  br label %for.inc

cleanup.thread:                                   ; preds = %lor.lhs.false, %land.lhs.true, %if.end24, %if.then52, %if.then65
  %err.3.ph = phi i32 [ -9, %if.then65 ], [ %call57, %if.then52 ], [ -22, %if.end24 ], [ -14, %land.lhs.true ], [ -14, %lor.lhs.false ]
  %needs_switch.2.off0.ph = phi i1 [ %needs_switch.1.off0, %if.then65 ], [ %needs_switch.0.off0177, %if.then52 ], [ %needs_switch.0.off0177, %if.end24 ], [ %needs_switch.0.off0177, %land.lhs.true ], [ %needs_switch.0.off0177, %lor.lhs.false ]
  %27 = trunc i64 %indvars.iv to i32
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #26
  br i1 %needs_switch.2.off0.ph, label %if.then84, label %if.end85

for.inc:                                          ; preds = %if.end33, %if.end73, %if.end62
  %needs_switch.2.off0 = phi i1 [ %needs_switch.0.off0177, %if.end33 ], [ %needs_switch.1.off0, %if.end73 ], [ %needs_switch.1.off0, %if.end62 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #26
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  br i1 %needs_switch.2.off0, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.then72, %cleanup.thread, %for.end
  %done.0172 = phi i32 [ %27, %cleanup.thread ], [ %nr_args, %for.end ], [ %24, %if.then72 ]
  %err.4166 = phi i32 [ %err.3.ph, %cleanup.thread ], [ 0, %for.end ], [ -9, %if.then72 ]
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef nonnull %4) #25
  br label %if.end85

if.end85:                                         ; preds = %if.then72, %cleanup.thread, %if.then84, %for.end
  %done.0171 = phi i32 [ %27, %cleanup.thread ], [ %done.0172, %if.then84 ], [ %nr_args, %for.end ], [ %24, %if.then72 ]
  %err.4165 = phi i32 [ %err.3.ph, %cleanup.thread ], [ %err.4166, %if.then84 ], [ 0, %for.end ], [ -9, %if.then72 ]
  %tobool86.not = icmp eq i32 %done.0171, 0
  br i1 %tobool86.not, label %if.end85.thread, label %cleanup87

if.end85.thread:                                  ; preds = %for.cond.preheader, %if.end85
  %err.4165186 = phi i32 [ %err.4165, %if.end85 ], [ 0, %for.cond.preheader ]
  br label %cleanup87

cleanup87:                                        ; preds = %if.end85.thread, %if.end85, %if.end, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ -22, %if.end ], [ %err.4165186, %if.end85.thread ], [ %done.0171, %if.end85 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_sqe_buffers_update(%struct.io_ring_ctx* noundef %ctx, %struct.io_uring_rsrc_update2* nocapture noundef readonly %up, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %iov = alloca %struct.iovec, align 8
  %last_hpage = alloca %struct.page*, align 8
  %imu = alloca %struct.io_mapped_ubuf*, align 8
  %tag = alloca i64, align 8
  %tags2 = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 3
  %0 = load i64, i64* %tags2, align 8
  %1 = inttoptr i64 %0 to i64*
  %2 = bitcast %struct.iovec* %iov to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %2) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %2, i8 0, i64 16, i1 false), !annotation !14
  %data = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 2
  %3 = load i64, i64* %data, align 8
  %4 = inttoptr i64 %3 to i8*
  %5 = bitcast %struct.page** %last_hpage to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #26
  store %struct.page* null, %struct.page** %last_hpage, align 8
  %buf_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 3
  %6 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %tobool.not = icmp eq %struct.io_rsrc_data* %6, null
  br i1 %tobool.not, label %cleanup81, label %if.end

if.end:                                           ; preds = %entry
  %offset = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 0
  %7 = load i32, i32* %offset, align 8
  %add = add i32 %7, %nr_args
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  %8 = load i32, i32* %nr_user_bufs, align 4
  %cmp9 = icmp ugt i32 %add, %8
  br i1 %cmp9, label %cleanup81, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end
  %cmp13160.not = icmp eq i32 %nr_args, 0
  br i1 %cmp13160.not, label %if.end79.thread, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %9 = bitcast %struct.io_mapped_ubuf** %imu to i8*
  %10 = bitcast i64* %tag to i8*
  %tobool21.not = icmp eq i64 %0, 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  %dummy_ubuf = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 1
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 6
  %wide.trip.count = zext i32 %nr_args to i64
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #26
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %imu, align 8, !annotation !14
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #26
  store i64 0, i64* %tag, align 8
  %call195 = call fastcc i32 @io_copy_iov(%struct.iovec* noundef nonnull %iov, i8* noundef %4, i32 noundef 0) #25
  %tobool18.not196 = icmp eq i32 %call195, 0
  br i1 %tobool18.not196, label %if.end20, label %cleanup.thread

if.end20:                                         ; preds = %for.body.lr.ph, %for.inc.for.body_crit_edge
  %add17202 = phi i32 [ %add17, %for.inc.for.body_crit_edge ], [ %7, %for.body.lr.ph ]
  %needs_switch.0.off0163200 = phi i1 [ %needs_switch.1.off0, %for.inc.for.body_crit_edge ], [ false, %for.body.lr.ph ]
  %indvars.iv197 = phi i64 [ %indvars.iv.next, %for.inc.for.body_crit_edge ], [ 0, %for.body.lr.ph ]
  br i1 %tobool21.not, label %if.end25, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end20
  %arrayidx = getelementptr i64, i64* %1, i64 %indvars.iv197
  %11 = bitcast i64* %arrayidx to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %10, i8* noundef %11, i64 noundef 8) #27
  %tobool23.not = icmp eq i64 %call2.i, 0
  br i1 %tobool23.not, label %if.end25, label %cleanup.thread

if.end25:                                         ; preds = %land.lhs.true, %if.end20
  %call26 = call fastcc i32 @io_buffer_validate(%struct.iovec* noundef nonnull %iov) #25
  %tobool27.not = icmp eq i32 %call26, 0
  br i1 %tobool27.not, label %if.end29, label %cleanup.thread

if.end29:                                         ; preds = %if.end25
  %12 = load i8*, i8** %iov_base, align 8
  %tobool30 = icmp eq i8* %12, null
  %13 = load i64, i64* %tag, align 8
  %tobool32 = icmp ne i64 %13, 0
  %or.cond = select i1 %tobool30, i1 %tobool32, i1 false
  br i1 %or.cond, label %cleanup.thread, label %if.end34

if.end34:                                         ; preds = %if.end29
  %call35 = call fastcc i32 @io_sqe_buffer_register(%struct.io_ring_ctx* noundef %ctx, %struct.iovec* noundef nonnull %iov, %struct.io_mapped_ubuf** noundef nonnull %imu, %struct.page** noundef nonnull %last_hpage) #25
  %tobool36.not = icmp eq i32 %call35, 0
  br i1 %tobool36.not, label %if.end38, label %cleanup.thread

if.end38:                                         ; preds = %if.end34
  %14 = load i32, i32* %nr_user_bufs, align 4
  %conv40 = sext i32 %add17202 to i64
  %conv41 = zext i32 %14 to i64
  %call42 = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv40, i64 noundef %conv41) #25
  %15 = trunc i64 %call42 to i32
  %conv48 = and i32 %add17202, %15
  %16 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %idxprom49 = sext i32 %conv48 to i64
  %arrayidx50 = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %16, i64 %idxprom49
  %17 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %arrayidx50, align 8
  %18 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %dummy_ubuf, align 8
  %cmp51.not = icmp eq %struct.io_mapped_ubuf* %17, %18
  br i1 %cmp51.not, label %for.inc, label %if.then53

if.then53:                                        ; preds = %if.end38
  %19 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %20 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %21 = bitcast %struct.io_mapped_ubuf* %17 to i8*
  %call58 = call fastcc i32 @io_queue_rsrc_removal(%struct.io_rsrc_data* noundef %19, i32 noundef %add17202, %struct.io_rsrc_node* noundef %20, i8* noundef %21) #25
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %if.end64, label %if.then63, !prof !8

if.then63:                                        ; preds = %if.then53
  call fastcc void @io_buffer_unmap(%struct.io_ring_ctx* noundef %ctx, %struct.io_mapped_ubuf** noundef nonnull %imu) #25
  br label %cleanup.thread

if.end64:                                         ; preds = %if.then53
  %22 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %arrayidx67 = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %22, i64 %idxprom49
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %arrayidx67, align 8
  %.pre171 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  br label %for.inc

cleanup.thread:                                   ; preds = %if.end34, %if.end29, %if.end25, %land.lhs.true, %for.inc.for.body_crit_edge, %for.body.lr.ph, %if.then63
  %indvars.iv194 = phi i64 [ %indvars.iv197, %if.then63 ], [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc.for.body_crit_edge ], [ %indvars.iv197, %land.lhs.true ], [ %indvars.iv197, %if.end25 ], [ %indvars.iv197, %if.end29 ], [ %indvars.iv197, %if.end34 ]
  %needs_switch.0.off0163191 = phi i1 [ %needs_switch.0.off0163200, %if.then63 ], [ false, %for.body.lr.ph ], [ %needs_switch.1.off0, %for.inc.for.body_crit_edge ], [ %needs_switch.0.off0163200, %land.lhs.true ], [ %needs_switch.0.off0163200, %if.end25 ], [ %needs_switch.0.off0163200, %if.end29 ], [ %needs_switch.0.off0163200, %if.end34 ]
  %err.2.ph = phi i32 [ %call58, %if.then63 ], [ %call195, %for.body.lr.ph ], [ %call, %for.inc.for.body_crit_edge ], [ -14, %land.lhs.true ], [ %call26, %if.end25 ], [ -22, %if.end29 ], [ %call35, %if.end34 ]
  %23 = trunc i64 %indvars.iv194 to i32
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #26
  br i1 %needs_switch.0.off0163191, label %if.then77, label %if.end79

for.inc:                                          ; preds = %if.end64, %if.end38
  %24 = phi %struct.io_mapped_ubuf** [ %.pre171, %if.end64 ], [ %16, %if.end38 ]
  %needs_switch.1.off0 = phi i1 [ true, %if.end64 ], [ %needs_switch.0.off0163200, %if.end38 ]
  %25 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %imu, align 8
  %arrayidx71 = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %24, i64 %idxprom49
  store %struct.io_mapped_ubuf* %25, %struct.io_mapped_ubuf** %arrayidx71, align 8
  %26 = load i64, i64* %tag, align 8
  %27 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %call73 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %27, i32 noundef %add17202) #25
  store i64 %26, i64* %call73, align 8
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #26
  %indvars.iv.next = add nuw nsw i64 %indvars.iv197, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  %.pre = load i32, i32* %offset, align 8
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #26
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %imu, align 8, !annotation !14
  %28 = trunc i64 %indvars.iv.next to i32
  %add17 = add i32 %.pre, %28
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #26
  store i64 0, i64* %tag, align 8
  %call = call fastcc i32 @io_copy_iov(%struct.iovec* noundef nonnull %iov, i8* noundef %4, i32 noundef %28) #25
  %tobool18.not = icmp eq i32 %call, 0
  br i1 %tobool18.not, label %if.end20, label %cleanup.thread

for.end:                                          ; preds = %for.inc
  br i1 %needs_switch.1.off0, label %if.then77, label %if.end79

if.then77:                                        ; preds = %cleanup.thread, %for.end
  %err.3178 = phi i32 [ %err.2.ph, %cleanup.thread ], [ 0, %for.end ]
  %done.0155177 = phi i32 [ %23, %cleanup.thread ], [ %nr_args, %for.end ]
  %29 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef %29) #25
  br label %if.end79

if.end79:                                         ; preds = %cleanup.thread, %if.then77, %for.end
  %err.3176 = phi i32 [ %err.3178, %if.then77 ], [ 0, %for.end ], [ %err.2.ph, %cleanup.thread ]
  %done.0155175 = phi i32 [ %done.0155177, %if.then77 ], [ %nr_args, %for.end ], [ %23, %cleanup.thread ]
  %tobool80.not = icmp eq i32 %done.0155175, 0
  br i1 %tobool80.not, label %if.end79.thread, label %cleanup81

if.end79.thread:                                  ; preds = %for.cond.preheader, %if.end79
  %err.3176182 = phi i32 [ %err.3176, %if.end79 ], [ 0, %for.cond.preheader ]
  br label %cleanup81

cleanup81:                                        ; preds = %if.end79.thread, %if.end79, %if.end, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ -22, %if.end ], [ %err.3176182, %if.end79.thread ], [ %done.0155175, %if.end79 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #26
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %2) #26
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.file* @fget(i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_fixed_file_set(%struct.io_fixed_file* nocapture noundef writeonly %file_slot, %struct.file* noundef %file) unnamed_addr #1 {
entry:
  %0 = ptrtoint %struct.file* %file to i64
  %call = call fastcc i1 @__io_file_supports_nowait(%struct.file* noundef %file, i32 noundef 0) #25
  %or = zext i1 %call to i64
  %spec.select = or i64 %or, %0
  %call1 = call fastcc i1 @__io_file_supports_nowait(%struct.file* noundef %file, i32 noundef 1) #25
  %or3 = or i64 %spec.select, 2
  %file_ptr.1 = select i1 %call1, i64 %or3, i64 %spec.select
  %call5 = call fastcc %struct.inode* @file_inode(%struct.file* noundef %file) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call5, i64 0, i32 0
  %1 = load i16, i16* %i_mode, align 8
  %2 = and i16 %1, -4096
  %cmp = icmp eq i16 %2, -32768
  %or8 = or i64 %file_ptr.1, 4
  %file_ptr.2 = select i1 %cmp, i64 %or8, i64 %file_ptr.1
  %file_ptr10 = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %file_slot, i64 0, i32 0
  store i64 %file_ptr.2, i64* %file_ptr10, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_copy_iov(%struct.iovec* noundef %dst, i8* noundef %arg, i32 noundef %index) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %arg to %struct.iovec*
  %1 = bitcast %struct.iovec* %dst to i8*
  %idxprom = zext i32 %index to i64
  %arrayidx = getelementptr %struct.iovec, %struct.iovec* %0, i64 %idxprom
  %2 = bitcast %struct.iovec* %arrayidx to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef %1, i8* noundef %2, i64 noundef 16) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  %. = select i1 %tobool.not, i32 0, i32 -14
  ret i32 %.
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @io_buffer_validate(%struct.iovec* nocapture noundef readonly %iov) unnamed_addr #18 {
entry:
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 1
  %0 = load i64, i64* %iov_len, align 8
  %add = add i64 %0, 4095
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8
  %tobool.not = icmp eq i8* %1, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tobool2.not = icmp eq i64 %0, 0
  %cond = select i1 %tobool2.not, i32 0, i32 -14
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = add i64 %0, -1073741825
  %3 = icmp ult i64 %2, -1073741824
  br i1 %3, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end
  %4 = ptrtoint i8* %1 to i64
  %5 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %4, i64 %add)
  %6 = extractvalue { i64, i1 } %5, 1
  %. = select i1 %6, i32 -75, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.end, %if.then
  %retval.0 = phi i32 [ %cond, %if.then ], [ -14, %if.end ], [ %., %if.end9 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqe_buffer_register(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.iovec* nocapture noundef readonly %iov, %struct.io_mapped_ubuf** nocapture noundef writeonly %pimu, %struct.page** nocapture noundef %last_hpage) unnamed_addr #1 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8
  %tobool.not = icmp eq i8* %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dummy_ubuf = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 1
  %1 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %dummy_ubuf, align 8
  store %struct.io_mapped_ubuf* %1, %struct.io_mapped_ubuf** %pimu, align 8
  br label %cleanup86

if.end:                                           ; preds = %entry
  %2 = ptrtoint i8* %0 to i64
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 1
  %3 = load i64, i64* %iov_len, align 8
  %add = add i64 %2, 4095
  %sub = add i64 %add, %3
  %shr = lshr i64 %sub, 12
  %shr3 = lshr i64 %2, 12
  %sub4 = sub nsw i64 %shr, %shr3
  %conv = trunc i64 %sub4 to i32
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %pimu, align 8
  %sext = shl i64 %sub4, 32
  %conv5 = ashr exact i64 %sext, 32
  %call = call fastcc i8* @kvmalloc_array(i64 noundef %conv5, i32 noundef 3264) #25
  %4 = bitcast i8* %call to %struct.page**
  %tobool6.not = icmp eq i8* %call, null
  br i1 %tobool6.not, label %if.then84, label %if.end8

if.end8:                                          ; preds = %if.end
  %call10 = call fastcc i8* @kvmalloc_array(i64 noundef %conv5, i32 noundef 3264) #25
  %5 = bitcast i8* %call10 to %struct.vm_area_struct**
  %tobool11.not = icmp eq i8* %call10, null
  br i1 %tobool11.not, label %if.then84, label %if.end13

if.end13:                                         ; preds = %if.end8
  %call15 = call fastcc i64 @__ab_c_size(i64 noundef %conv5, i64 noundef 16, i64 noundef 32) #25
  %call16 = call fastcc i8* @kvmalloc(i64 noundef %call15, i32 noundef 3264) #25
  %6 = bitcast i8* %call16 to %struct.io_mapped_ubuf*
  %tobool17.not = icmp eq i8* %call16, null
  br i1 %tobool17.not, label %if.then84, label %if.end19

if.end19:                                         ; preds = %if.end13
  %7 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %8 = inttoptr i64 %7 to %struct.task_struct*
  %mm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %8, i64 0, i32 35
  %9 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  call fastcc void @mmap_read_lock(%struct.mm_struct* noundef %9) #25
  %call22 = call i64 @pin_user_pages(i64 noundef %2, i64 noundef %conv5, i32 noundef 65537, %struct.page** noundef nonnull %4, %struct.vm_area_struct** noundef nonnull %5) #27
  %conv23 = trunc i64 %call22 to i32
  %cmp = icmp eq i32 %conv23, %conv
  br i1 %cmp, label %for.cond.preheader, label %if.else

for.cond.preheader:                               ; preds = %if.end19
  %cmp26193 = icmp sgt i32 %conv, 0
  br i1 %cmp26193, label %for.body.preheader, label %if.end46.thread

for.body.preheader:                               ; preds = %for.cond.preheader
  %wide.trip.count = and i64 %sub4, 4294967295
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr %struct.vm_area_struct*, %struct.vm_area_struct** %5, i64 %indvars.iv
  %10 = load %struct.vm_area_struct*, %struct.vm_area_struct** %arrayidx, align 8
  %call28 = call i1 @vma_is_shmem(%struct.vm_area_struct* noundef %10) #27
  br i1 %call28, label %for.inc, label %cleanup

cleanup:                                          ; preds = %for.body
  %vm_file = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %10, i64 0, i32 14
  %11 = load %struct.file*, %struct.file** %vm_file, align 8
  %tobool31.not = icmp eq %struct.file* %11, null
  br i1 %tobool31.not, label %for.inc, label %if.end36

for.inc:                                          ; preds = %for.body, %cleanup
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %if.end36, label %for.body

if.else:                                          ; preds = %if.end19
  %cmp34 = icmp slt i32 %conv23, 0
  %spec.select = select i1 %cmp34, i32 %conv23, i32 -14
  %12 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  call fastcc void @mmap_read_unlock(%struct.mm_struct* noundef %12) #25
  br label %if.then40

if.end36:                                         ; preds = %for.inc, %cleanup
  %tobool39.not = phi i1 [ true, %for.inc ], [ false, %cleanup ]
  %ret.2 = phi i32 [ 0, %for.inc ], [ -95, %cleanup ]
  %13 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  call fastcc void @mmap_read_unlock(%struct.mm_struct* noundef %13) #25
  br i1 %tobool39.not, label %if.end46, label %if.then40

if.then40:                                        ; preds = %if.else, %if.end36
  %ret.2187 = phi i32 [ %spec.select, %if.else ], [ %ret.2, %if.end36 ]
  %cmp41 = icmp sgt i32 %conv23, 0
  br i1 %cmp41, label %if.then84.sink.split, label %if.then84

if.end46:                                         ; preds = %if.end36
  %call47 = call fastcc i32 @io_buffer_account_pin(%struct.io_ring_ctx* noundef %ctx, %struct.page** noundef nonnull %4, i32 noundef %conv, %struct.io_mapped_ubuf* noundef nonnull %6, %struct.page** noundef %last_hpage) #25
  %tobool48.not = icmp eq i32 %call47, 0
  br i1 %tobool48.not, label %if.end51, label %if.then84.sink.split

if.end46.thread:                                  ; preds = %for.cond.preheader
  %14 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  call fastcc void @mmap_read_unlock(%struct.mm_struct* noundef %14) #25
  %call47210 = call fastcc i32 @io_buffer_account_pin(%struct.io_ring_ctx* noundef %ctx, %struct.page** noundef nonnull %4, i32 noundef %conv, %struct.io_mapped_ubuf* noundef nonnull %6, %struct.page** noundef %last_hpage) #25
  %tobool48.not211 = icmp eq i32 %call47210, 0
  br i1 %tobool48.not211, label %done, label %if.then84.sink.split

if.end51:                                         ; preds = %if.end46
  br i1 %cmp26193, label %for.body56.lr.ph, label %done

for.body56.lr.ph:                                 ; preds = %if.end51
  %15 = load i64, i64* %iov_len, align 8
  %and = and i64 %2, 4095
  %bvec = getelementptr inbounds i8, i8* %call16, i64 32
  %16 = bitcast i8* %bvec to [0 x %struct.bio_vec]*
  %wide.trip.count205 = and i64 %sub4, 4294967295
  %sub57.peel = sub nuw nsw i64 4096, %and
  %cmp58.peel = icmp ult i64 %15, %sub57.peel
  %cond63.peel = select i1 %cmp58.peel, i64 %15, i64 %sub57.peel
  %17 = load %struct.page*, %struct.page** %4, align 8
  %bv_page.peel = bitcast i8* %bvec to %struct.page**
  store %struct.page* %17, %struct.page** %bv_page.peel, align 8
  %conv68.peel = trunc i64 %cond63.peel to i32
  %bv_len.peel = getelementptr i8, i8* %call16, i64 40
  %18 = bitcast i8* %bv_len.peel to i32*
  store i32 %conv68.peel, i32* %18, align 8
  %conv72.peel = trunc i64 %and to i32
  %bv_offset.peel = getelementptr i8, i8* %call16, i64 44
  %19 = bitcast i8* %bv_offset.peel to i32*
  store i32 %conv72.peel, i32* %19, align 4
  %exitcond206.peel.not = icmp eq i64 %wide.trip.count205, 1
  br i1 %exitcond206.peel.not, label %done, label %for.body56.peel.next

for.body56.peel.next:                             ; preds = %for.body56.lr.ph
  %sub76.peel = sub i64 %15, %cond63.peel
  br label %for.body56

for.body56:                                       ; preds = %for.body56.peel.next, %for.body56
  %indvars.iv202 = phi i64 [ 1, %for.body56.peel.next ], [ %indvars.iv.next203, %for.body56 ]
  %size.0199 = phi i64 [ %sub76.peel, %for.body56.peel.next ], [ %sub76, %for.body56 ]
  %cmp58 = icmp ult i64 %size.0199, 4096
  %cond63 = select i1 %cmp58, i64 %size.0199, i64 4096
  %arrayidx65 = getelementptr %struct.page*, %struct.page** %4, i64 %indvars.iv202
  %20 = load %struct.page*, %struct.page** %arrayidx65, align 8
  %bv_page = getelementptr [0 x %struct.bio_vec], [0 x %struct.bio_vec]* %16, i64 0, i64 %indvars.iv202, i32 0
  store %struct.page* %20, %struct.page** %bv_page, align 8
  %conv68 = trunc i64 %cond63 to i32
  %bv_len = getelementptr [0 x %struct.bio_vec], [0 x %struct.bio_vec]* %16, i64 0, i64 %indvars.iv202, i32 1
  store i32 %conv68, i32* %bv_len, align 8
  %bv_offset = getelementptr [0 x %struct.bio_vec], [0 x %struct.bio_vec]* %16, i64 0, i64 %indvars.iv202, i32 2
  store i32 0, i32* %bv_offset, align 4
  %sub76 = sub i64 %size.0199, %cond63
  %indvars.iv.next203 = add nuw nsw i64 %indvars.iv202, 1
  %exitcond206.not = icmp eq i64 %indvars.iv.next203, %wide.trip.count205
  br i1 %exitcond206.not, label %done, label %for.body56, !llvm.loop !103

done:                                             ; preds = %for.body56, %if.end46.thread, %for.body56.lr.ph, %if.end51
  %ubuf80 = bitcast i8* %call16 to i64*
  store i64 %2, i64* %ubuf80, align 8
  %21 = load i64, i64* %iov_len, align 8
  %add82 = add i64 %21, %2
  %ubuf_end = getelementptr inbounds i8, i8* %call16, i64 8
  %22 = bitcast i8* %ubuf_end to i64*
  store i64 %add82, i64* %22, align 8
  %nr_bvecs = getelementptr inbounds i8, i8* %call16, i64 16
  %23 = bitcast i8* %nr_bvecs to i32*
  store i32 %conv, i32* %23, align 8
  %24 = bitcast %struct.io_mapped_ubuf** %pimu to i8**
  store i8* %call16, i8** %24, align 8
  br label %if.end85

if.then84.sink.split:                             ; preds = %if.end46, %if.end46.thread, %if.then40
  %ret.3.ph.ph = phi i32 [ %ret.2187, %if.then40 ], [ %call47210, %if.end46.thread ], [ %call47, %if.end46 ]
  %sext179 = shl i64 %call22, 32
  %conv44 = ashr exact i64 %sext179, 32
  call void @unpin_user_pages(%struct.page** noundef nonnull %4, i64 noundef %conv44) #27
  br label %if.then84

if.then84:                                        ; preds = %if.then84.sink.split, %if.then40, %if.end13, %if.end8, %if.end
  %ret.3.ph = phi i32 [ -12, %if.end ], [ -12, %if.end8 ], [ -12, %if.end13 ], [ %ret.2187, %if.then40 ], [ %ret.3.ph.ph, %if.then84.sink.split ]
  %.ph = phi i8* [ null, %if.end ], [ null, %if.end8 ], [ %call10, %if.end13 ], [ %call10, %if.then40 ], [ %call10, %if.then84.sink.split ]
  %.ph188 = phi i8* [ null, %if.end ], [ null, %if.end8 ], [ null, %if.end13 ], [ %call16, %if.then40 ], [ %call16, %if.then84.sink.split ]
  call void @kvfree(i8* noundef %.ph188) #27
  br label %if.end85

if.end85:                                         ; preds = %done, %if.then84
  %25 = phi i8* [ %.ph, %if.then84 ], [ %call10, %done ]
  %ret.3192 = phi i32 [ %ret.3.ph, %if.then84 ], [ 0, %done ]
  call void @kvfree(i8* noundef %call) #27
  call void @kvfree(i8* noundef %25) #27
  br label %cleanup86

cleanup86:                                        ; preds = %if.end85, %if.then
  %retval.0 = phi i32 [ %ret.3192, %if.end85 ], [ 0, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kvmalloc_array(i64 noundef %n, i32 noundef %flags) unnamed_addr #1 {
entry:
  %0 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %n, i64 8)
  %1 = extractvalue { i64, i1 } %0, 1
  br i1 %1, label %cleanup, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %2 = extractvalue { i64, i1 } %0, 0
  %call6 = call fastcc i8* @kvmalloc(i64 noundef %2, i32 noundef %flags) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i8* [ %call6, %if.end ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kvmalloc(i64 noundef %size, i32 noundef %flags) unnamed_addr #1 {
entry:
  %call = call i8* @kvmalloc_node(i64 noundef %size, i32 noundef %flags, i32 noundef -1) #27
  ret i8* %call
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @__ab_c_size(i64 noundef %a, i64 noundef %b, i64 noundef %c) unnamed_addr #19 {
entry:
  %0 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
  %1 = extractvalue { i64, i1 } %0, 1
  %2 = extractvalue { i64, i1 } %0, 0
  %spec.select = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %c)
  %retval.0 = select i1 %1, i64 -1, i64 %spec.select
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @mmap_read_lock(%struct.mm_struct* noundef %mm) unnamed_addr #1 {
entry:
  %mmap_lock = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %mm, i64 0, i32 0, i32 15
  call void @down_read(%struct.rw_semaphore* noundef %mmap_lock) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @pin_user_pages(i64 noundef, i64 noundef, i32 noundef, %struct.page** noundef, %struct.vm_area_struct** noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @vma_is_shmem(%struct.vm_area_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @mmap_read_unlock(%struct.mm_struct* noundef %mm) unnamed_addr #1 {
entry:
  %mmap_lock = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %mm, i64 0, i32 0, i32 15
  call void @up_read(%struct.rw_semaphore* noundef %mmap_lock) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @unpin_user_pages(%struct.page** noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_buffer_account_pin(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.page** nocapture noundef readonly %pages, i32 noundef %nr_pages, %struct.io_mapped_ubuf* nocapture noundef %imu, %struct.page** nocapture noundef %last_hpage) unnamed_addr #1 {
entry:
  %acct_pages = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %imu, i64 0, i32 3
  store i64 0, i64* %acct_pages, align 8
  %cmp48 = icmp sgt i32 %nr_pages, 0
  br i1 %cmp48, label %for.body.preheader, label %cleanup24

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %nr_pages to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr %struct.page*, %struct.page** %pages, i64 %indvars.iv
  %0 = load %struct.page*, %struct.page** %arrayidx, align 8
  %flags.i = getelementptr inbounds %struct.page, %struct.page* %0, i64 0, i32 0
  %1 = load volatile i64, i64* %flags.i, align 8
  %2 = and i64 %1, 65536
  %tobool.not.i = icmp eq i64 %2, 0
  br i1 %tobool.not.i, label %PageCompound.exit, label %if.else

PageCompound.exit:                                ; preds = %for.body
  %3 = getelementptr inbounds %struct.page, %struct.page* %0, i64 0, i32 1
  %compound_head.i.i = bitcast %union.anon.5* %3 to i64*
  %4 = load volatile i64, i64* %compound_head.i.i, align 8
  %5 = and i64 %4, 1
  %tobool.not = icmp eq i64 %5, 0
  br i1 %tobool.not, label %for.inc.sink.split, label %if.else

if.else:                                          ; preds = %for.body, %PageCompound.exit
  %call4 = call fastcc i64 @_compound_head(%struct.page* noundef %0) #25
  %6 = inttoptr i64 %call4 to %struct.page*
  %7 = load %struct.page*, %struct.page** %last_hpage, align 8
  %cmp5 = icmp eq %struct.page* %7, %6
  br i1 %cmp5, label %for.inc, label %if.end

if.end:                                           ; preds = %if.else
  store %struct.page* %6, %struct.page** %last_hpage, align 8
  %8 = trunc i64 %indvars.iv to i32
  %call7 = call fastcc i1 @headpage_already_acct(%struct.io_ring_ctx* noundef %ctx, %struct.page** noundef %pages, i32 noundef %8, %struct.page* noundef %6) #25
  br i1 %call7, label %for.inc, label %if.end9

if.end9:                                          ; preds = %if.end
  %call10 = call fastcc i64 @page_size(%struct.page* noundef %6) #25
  %shr = lshr i64 %call10, 12
  br label %for.inc.sink.split

for.inc.sink.split:                               ; preds = %PageCompound.exit, %if.end9
  %shr.sink = phi i64 [ %shr, %if.end9 ], [ 1, %PageCompound.exit ]
  %9 = load i64, i64* %acct_pages, align 8
  %add = add i64 %9, %shr.sink
  store i64 %add, i64* %acct_pages, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %if.else, %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  %.pre = load i64, i64* %acct_pages, align 8
  %tobool15.not = icmp eq i64 %.pre, 0
  br i1 %tobool15.not, label %cleanup24, label %if.end17

if.end17:                                         ; preds = %for.end
  %call19 = call fastcc i32 @io_account_mem(%struct.io_ring_ctx* noundef %ctx, i64 noundef %.pre) #25
  %tobool20.not = icmp eq i32 %call19, 0
  br i1 %tobool20.not, label %cleanup24, label %if.then21

if.then21:                                        ; preds = %if.end17
  store i64 0, i64* %acct_pages, align 8
  br label %cleanup24

cleanup24:                                        ; preds = %entry, %if.end17, %if.then21, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ %call19, %if.then21 ], [ 0, %if.end17 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #11

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @kvmalloc_node(i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @down_read(%struct.rw_semaphore* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @up_read(%struct.rw_semaphore* noundef) local_unnamed_addr #4

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc i1 @headpage_already_acct(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.page** nocapture noundef readonly %pages, i32 noundef %nr_pages, %struct.page* noundef readnone %hpage) unnamed_addr #9 {
entry:
  %cmp63 = icmp sgt i32 %nr_pages, 0
  br i1 %cmp63, label %for.body.preheader, label %for.cond7.preheader

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %nr_pages to i64
  br label %for.body

for.cond7.preheader:                              ; preds = %for.inc, %entry
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  %0 = load i32, i32* %nr_user_bufs, align 4
  %cmp867.not = icmp eq i32 %0, 0
  br i1 %cmp867.not, label %cleanup35, label %for.body9.lr.ph

for.body9.lr.ph:                                  ; preds = %for.cond7.preheader
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  br label %for.body9

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr %struct.page*, %struct.page** %pages, i64 %indvars.iv
  %1 = load %struct.page*, %struct.page** %arrayidx, align 8
  %flags.i = getelementptr inbounds %struct.page, %struct.page* %1, i64 0, i32 0
  %2 = load volatile i64, i64* %flags.i, align 8
  %3 = and i64 %2, 65536
  %tobool.not.i = icmp eq i64 %3, 0
  br i1 %tobool.not.i, label %PageCompound.exit, label %if.end

PageCompound.exit:                                ; preds = %for.body
  %4 = getelementptr inbounds %struct.page, %struct.page* %1, i64 0, i32 1
  %compound_head.i.i = bitcast %union.anon.5* %4 to i64*
  %5 = load volatile i64, i64* %compound_head.i.i, align 8
  %6 = and i64 %5, 1
  %tobool.not = icmp eq i64 %6, 0
  br i1 %tobool.not, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body, %PageCompound.exit
  %call3 = call fastcc i64 @_compound_head(%struct.page* noundef %1) #25
  %7 = inttoptr i64 %call3 to %struct.page*
  %cmp4 = icmp eq %struct.page* %7, %hpage
  br i1 %cmp4, label %cleanup35, label %for.inc

for.inc:                                          ; preds = %if.end, %PageCompound.exit
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond7.preheader, label %for.body

for.body9:                                        ; preds = %for.body9.lr.ph, %for.inc32
  %8 = phi i32 [ %0, %for.body9.lr.ph ], [ %21, %for.inc32 ]
  %i.168 = phi i32 [ 0, %for.body9.lr.ph ], [ %inc33, %for.inc32 ]
  %9 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %idxprom10 = sext i32 %i.168 to i64
  %arrayidx11 = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %9, i64 %idxprom10
  %10 = load %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %arrayidx11, align 8
  %nr_bvecs = getelementptr inbounds %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %10, i64 0, i32 2
  %11 = load i32, i32* %nr_bvecs, align 8
  %cmp1365.not = icmp eq i32 %11, 0
  br i1 %cmp1365.not, label %for.inc32, label %for.body14

for.body14:                                       ; preds = %for.body9, %for.inc29
  %12 = phi i32 [ %20, %for.inc29 ], [ %11, %for.body9 ]
  %j.066 = phi i32 [ %inc30, %for.inc29 ], [ 0, %for.body9 ]
  %idxprom15 = sext i32 %j.066 to i64
  %bv_page = getelementptr %struct.io_mapped_ubuf, %struct.io_mapped_ubuf* %10, i64 0, i32 4, i64 %idxprom15, i32 0
  %13 = load %struct.page*, %struct.page** %bv_page, align 8
  %flags.i54 = getelementptr inbounds %struct.page, %struct.page* %13, i64 0, i32 0
  %14 = load volatile i64, i64* %flags.i54, align 8
  %15 = and i64 %14, 65536
  %tobool.not.i55 = icmp eq i64 %15, 0
  br i1 %tobool.not.i55, label %PageCompound.exit58, label %if.end20

PageCompound.exit58:                              ; preds = %for.body14
  %16 = getelementptr inbounds %struct.page, %struct.page* %13, i64 0, i32 1
  %compound_head.i.i56 = bitcast %union.anon.5* %16 to i64*
  %17 = load volatile i64, i64* %compound_head.i.i56, align 8
  %18 = and i64 %17, 1
  %tobool18.not = icmp eq i64 %18, 0
  br i1 %tobool18.not, label %for.inc29, label %if.end20

if.end20:                                         ; preds = %for.body14, %PageCompound.exit58
  %call25 = call fastcc i64 @_compound_head(%struct.page* noundef %13) #25
  %19 = inttoptr i64 %call25 to %struct.page*
  %cmp26 = icmp eq %struct.page* %19, %hpage
  br i1 %cmp26, label %cleanup35, label %if.end20.for.inc29_crit_edge

if.end20.for.inc29_crit_edge:                     ; preds = %if.end20
  %.pre = load i32, i32* %nr_bvecs, align 8
  br label %for.inc29

for.inc29:                                        ; preds = %if.end20.for.inc29_crit_edge, %PageCompound.exit58
  %20 = phi i32 [ %.pre, %if.end20.for.inc29_crit_edge ], [ %12, %PageCompound.exit58 ]
  %inc30 = add nuw i32 %j.066, 1
  %cmp13 = icmp ult i32 %inc30, %20
  br i1 %cmp13, label %for.body14, label %for.inc32.loopexit

for.inc32.loopexit:                               ; preds = %for.inc29
  %.pre72 = load i32, i32* %nr_user_bufs, align 4
  br label %for.inc32

for.inc32:                                        ; preds = %for.inc32.loopexit, %for.body9
  %21 = phi i32 [ %.pre72, %for.inc32.loopexit ], [ %8, %for.body9 ]
  %inc33 = add nuw i32 %i.168, 1
  %cmp8 = icmp ult i32 %inc33, %21
  br i1 %cmp8, label %for.body9, label %cleanup35

cleanup35:                                        ; preds = %if.end, %for.inc32, %if.end20, %for.cond7.preheader
  %retval.2 = phi i1 [ false, %for.cond7.preheader ], [ true, %if.end20 ], [ false, %for.inc32 ], [ true, %if.end ]
  ret i1 %retval.2
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_account_mem(%struct.io_ring_ctx* nocapture noundef readonly %ctx, i64 noundef %nr_pages) unnamed_addr #1 {
entry:
  %user = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 1
  %0 = load %struct.user_struct*, %struct.user_struct** %user, align 8
  %tobool.not = icmp eq %struct.user_struct* %0, null
  br i1 %tobool.not, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %call = call fastcc i32 @__io_account_mem(%struct.user_struct* noundef nonnull %0, i64 noundef %nr_pages) #25
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.then, %entry
  %mm_account = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 2
  %1 = load %struct.mm_struct*, %struct.mm_struct** %mm_account, align 16
  %tobool5.not = icmp eq %struct.mm_struct* %1, null
  br i1 %tobool5.not, label %cleanup, label %if.then6

if.then6:                                         ; preds = %if.end4
  %pinned_vm = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %1, i64 0, i32 0, i32 21
  call fastcc void @__ll_sc_atomic64_add(i64 noundef %nr_pages, %struct.atomic64_t* noundef %pinned_vm) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then6, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %if.then6 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_account_mem(%struct.user_struct* noundef %user, i64 noundef %nr_pages) unnamed_addr #1 {
entry:
  %call = call fastcc i64 @rlimit(i32 noundef 8) #25
  %shr = lshr i64 %call, 12
  %locked_vm = getelementptr inbounds %struct.user_struct, %struct.user_struct* %user, i64 0, i32 6
  %0 = bitcast %struct.atomic64_t* %locked_vm to i8*
  %counter.i.i = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %locked_vm, i64 0, i32 0
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %1 = load volatile i64, i64* %counter.i.i, align 8
  %add = add i64 %1, %nr_pages
  %cmp = icmp ugt i64 %add, %shr
  br i1 %cmp, label %cleanup, label %do.cond

do.cond:                                          ; preds = %do.body
  %call14.i.i.i = call fastcc i64 @__cmpxchg_case_mb_64(i8* noundef %0, i64 noundef %1, i64 noundef %add) #27
  %cmp4.not = icmp eq i64 %call14.i.i.i, %1
  br i1 %cmp4.not, label %cleanup, label %do.body

cleanup:                                          ; preds = %do.cond, %do.body
  %retval.0 = phi i32 [ -12, %do.body ], [ 0, %do.cond ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @rlimit(i32 noundef %limit) unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %call1 = call fastcc i64 @task_rlimit(%struct.task_struct* noundef %1, i32 noundef %limit) #25
  ret i64 %call1
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i64 @task_rlimit(%struct.task_struct* nocapture noundef readonly %task, i32 noundef %limit) unnamed_addr #8 {
entry:
  %signal = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 87
  %0 = load %struct.signal_struct*, %struct.signal_struct** %signal, align 8
  %idxprom = zext i32 %limit to i64
  %rlim_cur = getelementptr %struct.signal_struct, %struct.signal_struct* %0, i64 0, i32 49, i64 %idxprom, i32 0
  %1 = load volatile i64, i64* %rlim_cur, align 8
  ret i64 %1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic64_add(i64 noundef %i, %struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64 } asm sideeffect "// atomic64_add\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09add\09$0, $0, $3\0A\09stxr\09${1:w}, $0, $2\0A\09cbnz\09${1:w}, 1b", "=&r,=&r,=*Q,Ir,*Q"(i64* elementtype(i64) %counter, i64 %i, i64* elementtype(i64) %counter) #26, !srcloc !105
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_statx(i32 noundef, i8* noundef, i32 noundef, i32 noundef, %struct.statx* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @vfs_fadvise(%struct.file* noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_madvise(%struct.mm_struct* noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @build_open_flags(%struct.open_how* noundef, %struct.open_flags* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__get_unused_fd_flags(i32 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.file* @do_filp_open(i32 noundef, %struct.filename* noundef, %struct.open_flags* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @put_unused_fd(i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc void @fsnotify_open(%struct.file* nocapture noundef readonly %file) unnamed_addr #8 {
entry:
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 7
  %0 = load i32, i32* %f_flags, align 8
  %and = and i32 %0, 32
  %tobool.not = icmp eq i32 %and, 0
  %spec.select = select i1 %tobool.not, i32 32, i32 4128
  call fastcc void @fsnotify_file(%struct.file* noundef %file, i32 noundef %spec.select) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @fd_install(i32 noundef, %struct.file* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_install_fixed_file(%struct.io_kiocb* nocapture noundef readonly %req, %struct.file* noundef %file, i32 noundef %issue_flags, i32 noundef %slot_index) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %and = and i32 %issue_flags, 1
  %tobool.not = icmp eq i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp = icmp eq %struct.file_operations* %1, @io_uring_fops
  br i1 %cmp, label %if.then47, label %if.end

if.end:                                           ; preds = %entry
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 13, i32 2
  %2 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %tobool3.not = icmp eq %struct.io_rsrc_data* %2, null
  br i1 %tobool3.not, label %if.then47, label %if.end5

if.end5:                                          ; preds = %if.end
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 8
  %3 = load i32, i32* %nr_user_files, align 8
  %cmp6.not = icmp ugt i32 %3, %slot_index
  br i1 %cmp6.not, label %if.end8, label %if.then47

if.end8:                                          ; preds = %if.end5
  %conv = zext i32 %slot_index to i64
  %conv10 = zext i32 %3 to i64
  %call = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv, i64 noundef %conv10) #25
  %4 = trunc i64 %call to i32
  %conv16 = and i32 %4, %slot_index
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 7
  %call17 = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %conv16) #25
  %file_ptr = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %call17, i64 0, i32 0
  %5 = load i64, i64* %file_ptr, align 8
  %tobool18.not = icmp eq i64 %5, 0
  br i1 %tobool18.not, label %err, label %if.then19

if.then19:                                        ; preds = %if.end8
  %call20 = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %0) #25
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.end23, label %if.then47

if.end23:                                         ; preds = %if.then19
  %6 = load i64, i64* %file_ptr, align 8
  %and25 = and i64 %6, -8
  %7 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 6
  %8 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %9 = inttoptr i64 %and25 to i8*
  %call27 = call fastcc i32 @io_queue_rsrc_removal(%struct.io_rsrc_data* noundef %7, i32 noundef %conv16, %struct.io_rsrc_node* noundef %8, i8* noundef %9) #25
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %cleanup, label %if.then47

cleanup:                                          ; preds = %if.end23
  store i64 0, i64* %file_ptr, align 8
  %10 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %call34.c = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %10, i32 noundef %conv16) #25
  store i64 0, i64* %call34.c, align 8
  call fastcc void @io_fixed_file_set(%struct.io_fixed_file* noundef %call17, %struct.file* noundef %file) #25
  %11 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %0, %struct.io_rsrc_data* noundef %11) #25
  br label %if.end43.thread

err:                                              ; preds = %if.end8
  %12 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %call34 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %12, i32 noundef %conv16) #25
  store i64 0, i64* %call34, align 8
  call fastcc void @io_fixed_file_set(%struct.io_fixed_file* noundef %call17, %struct.file* noundef %file) #25
  br label %if.end43.thread

if.end43.thread:                                  ; preds = %err, %cleanup
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  br label %cleanup49

if.then47:                                        ; preds = %if.end23, %if.then19, %if.end, %if.end5, %entry
  %ret.1.ph = phi i32 [ -6, %if.end ], [ -22, %if.end5 ], [ -9, %entry ], [ %call27, %if.end23 ], [ %call20, %if.then19 ]
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %0, i1 noundef %tobool.not) #25
  call void @fput(%struct.file* noundef %file) #27
  br label %cleanup49

cleanup49:                                        ; preds = %if.end43.thread, %if.then47
  %ret.199102 = phi i32 [ 0, %if.end43.thread ], [ %ret.1.ph, %if.then47 ]
  ret i32 %ret.199102
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc void @fsnotify_file(%struct.file* nocapture noundef readonly %file, i32 noundef %mask) unnamed_addr #8 {
entry:
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 8
  %0 = load i32, i32* %f_mode, align 4
  %and = and i32 %0, 67108864
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dentry = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 1, i32 1
  %1 = load %struct.dentry*, %struct.dentry** %dentry, align 8
  call fastcc void @fsnotify_parent(%struct.dentry* noundef %1, i32 noundef %mask) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc void @fsnotify_parent(%struct.dentry* noundef readonly %dentry, i32 noundef %mask) unnamed_addr #8 {
entry:
  %call = call fastcc %struct.inode* @d_inode(%struct.dentry* noundef %dentry) #25
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 6
  %0 = load %struct.super_block*, %struct.super_block** %i_sb, align 8
  %counter.i.i = getelementptr inbounds %struct.super_block, %struct.super_block* %0, i64 0, i32 41, i32 0
  %1 = load volatile i64, i64* %counter.i.i, align 8
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc %struct.inode* @d_inode(%struct.dentry* nocapture noundef readonly %dentry) unnamed_addr #3 {
entry:
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i64 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8
  ret %struct.inode* %0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_epoll_ctl(i32 noundef, i32 noundef, i32 noundef, %struct.epoll_event* noundef, i1 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @do_splice(%struct.file* noundef, i64* noundef, %struct.file* noundef, i64* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_add_buffers(%struct.io_provide_buf* nocapture noundef readonly %pbuf, %struct.io_buffer** nocapture noundef %head) unnamed_addr #1 {
entry:
  %nbufs = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 4
  %0 = load i16, i16* %nbufs, align 8
  %cmp51.not = icmp eq i16 %0, 0
  br i1 %cmp51.not, label %for.end.thread, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %bid2 = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 5
  %1 = load i16, i16* %bid2, align 2
  %conv = zext i16 %1 to i32
  %addr1 = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 1
  %2 = load i64, i64* %addr1, align 8
  %len = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 2
  %3 = bitcast %struct.io_buffer** %head to i8**
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %addr.054 = phi i64 [ %2, %for.body.lr.ph ], [ %add, %for.inc ]
  %i.053 = phi i32 [ 0, %for.body.lr.ph ], [ %inc18, %for.inc ]
  %bid.052 = phi i32 [ %conv, %for.body.lr.ph ], [ %inc, %for.inc ]
  %4 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %4, i32 noundef 4197568) #27
  %tobool.not = icmp eq i8* %call.i.i, null
  br i1 %tobool.not, label %for.end, label %if.end

if.end:                                           ; preds = %for.body
  %addr5 = getelementptr inbounds i8, i8* %call.i.i, i64 16
  %5 = bitcast i8* %addr5 to i64*
  store i64 %addr.054, i64* %5, align 8
  %6 = load i32, i32* %len, align 8
  %cmp6 = icmp ult i32 %6, 2147479552
  %cond = select i1 %cmp6, i32 %6, i32 2147479552
  %len8 = getelementptr inbounds i8, i8* %call.i.i, i64 24
  %7 = bitcast i8* %len8 to i32*
  store i32 %cond, i32* %7, align 8
  %conv9 = trunc i32 %bid.052 to i16
  %bid10 = getelementptr inbounds i8, i8* %call.i.i, i64 28
  %8 = bitcast i8* %bid10 to i16*
  store i16 %conv9, i16* %8, align 4
  %conv12 = zext i32 %6 to i64
  %add = add i64 %addr.054, %conv12
  %inc = add nuw nsw i32 %bid.052, 1
  %9 = load %struct.io_buffer*, %struct.io_buffer** %head, align 8
  %tobool13.not = icmp eq %struct.io_buffer* %9, null
  %list = bitcast i8* %call.i.i to %struct.list_head*
  br i1 %tobool13.not, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef nonnull %list) #25
  store i8* %call.i.i, i8** %3, align 8
  br label %for.inc

if.else:                                          ; preds = %if.end
  %list16 = getelementptr inbounds %struct.io_buffer, %struct.io_buffer* %9, i64 0, i32 0
  call fastcc void @list_add_tail(%struct.list_head* noundef nonnull %list, %struct.list_head* noundef %list16) #25
  br label %for.inc

for.inc:                                          ; preds = %if.then14, %if.else
  %inc18 = add nuw nsw i32 %i.053, 1
  %10 = load i16, i16* %nbufs, align 8
  %conv3 = zext i16 %10 to i32
  %cmp = icmp ult i32 %inc18, %conv3
  br i1 %cmp, label %for.body, label %for.end.thread58

for.end:                                          ; preds = %for.body
  %tobool19.not = icmp eq i32 %i.053, 0
  br i1 %tobool19.not, label %for.end.thread, label %for.end.thread58

for.end.thread:                                   ; preds = %entry, %for.end
  br label %for.end.thread58

for.end.thread58:                                 ; preds = %for.inc, %for.end, %for.end.thread
  %11 = phi i32 [ -12, %for.end.thread ], [ %i.053, %for.end ], [ %inc18, %for.inc ]
  ret i32 %11
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @xa_insert(%struct.xarray* noundef %xa, i64 noundef %index, i8* noundef %entry1) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %call = call i32 @__xa_insert(%struct.xarray* noundef %xa, i64 noundef %index, i8* noundef %entry1, i32 noundef 3264) #27
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__xa_insert(%struct.xarray* noundef, i64 noundef, i8* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @do_tee(%struct.file* noundef, %struct.file* noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_renameat2(i32 noundef, %struct.filename* noundef, i32 noundef, %struct.filename* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_rmdir(i32 noundef, %struct.filename* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_unlinkat(i32 noundef, %struct.filename* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_mkdirat(i32 noundef, %struct.filename* noundef, i16 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_symlinkat(%struct.filename* noundef, i32 noundef, %struct.filename* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @do_linkat(i32 noundef, %struct.filename* noundef, i32 noundef, %struct.filename* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @blk_qc_t_to_queue_num(i32 noundef %cookie) unnamed_addr #0 {
entry:
  %and = lshr i32 %cookie, 16
  %shr = and i32 %and, 32767
  ret i32 %shr
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @__io_prep_linked_timeout(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %0, null
  br i1 %tobool.not, label %if.then, label %if.end18, !prof !24

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 1375; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !106
  br label %return

if.end18:                                         ; preds = %entry
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, -1052673
  %or = or i32 %and, 4096
  store i32 %or, i32* %flags, align 8
  call fastcc void @io_req_set_refcount(%struct.io_kiocb* noundef %req) #25
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  call fastcc void @__io_req_set_refcount(%struct.io_kiocb* noundef %2, i32 noundef 2) #25
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  br label %return

return:                                           ; preds = %if.then, %if.end18
  %retval.0 = phi %struct.io_kiocb* [ %3, %if.end18 ], [ null, %if.then ]
  ret %struct.io_kiocb* %retval.0
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @io_req_set_refcount(%struct.io_kiocb* noundef %req) unnamed_addr #9 {
entry:
  call fastcc void @__io_req_set_refcount(%struct.io_kiocb* noundef %req, i32 noundef 1) #25
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @__io_req_set_refcount(%struct.io_kiocb* noundef %req, i32 noundef %nr) unnamed_addr #9 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %or = or i32 %0, 524288
  store i32 %or, i32* %flags, align 8
  %counter.i = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 8, i32 0
  store volatile i32 %nr, i32* %counter.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_async_queue_proc(%struct.file* nocapture noundef readnone %file, %struct.wait_queue_head* noundef %head, %struct.poll_table_struct* nocapture noundef %p) #1 {
entry:
  %0 = bitcast %struct.poll_table_struct* %p to %struct.io_poll_table*
  %req = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i64 1
  %1 = bitcast %struct.poll_table_struct* %req to %struct.io_kiocb**
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %1, align 8
  %apoll1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %2, i64 0, i32 16
  %3 = load %struct.async_poll*, %struct.async_poll** %apoll1, align 8
  %poll = getelementptr inbounds %struct.async_poll, %struct.async_poll* %3, i64 0, i32 0
  %double_poll = getelementptr inbounds %struct.async_poll, %struct.async_poll* %3, i64 0, i32 1
  call fastcc void @__io_queue_proc(%struct.io_poll_iocb* noundef %poll, %struct.io_poll_table* noundef %0, %struct.wait_queue_head* noundef %head, %struct.io_poll_iocb** noundef %double_poll) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_async_wake(%struct.wait_queue_entry* nocapture noundef readonly %wait, i32 noundef %mode, i32 noundef %sync, i8* noundef %key) #1 {
entry:
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %0 = bitcast i8** %private to %struct.io_kiocb**
  %1 = load %struct.io_kiocb*, %struct.io_kiocb** %0, align 8
  %apoll = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %1, i64 0, i32 16
  %2 = load %struct.async_poll*, %struct.async_poll** %apoll, align 8
  %poll1 = getelementptr inbounds %struct.async_poll, %struct.async_poll* %2, i64 0, i32 0
  %3 = ptrtoint i8* %key to i64
  %conv = trunc i64 %3 to i32
  %call = call fastcc i32 @__io_async_wake(%struct.io_kiocb* noundef %1, %struct.io_poll_iocb* noundef %poll1, i32 noundef %conv, void (%struct.io_kiocb*, i8*)* noundef nonnull @io_async_task_func) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_async_task_func(%struct.io_kiocb* noundef %req, i8* nocapture noundef %locked) #1 {
entry:
  %apoll1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 16
  %0 = load %struct.async_poll*, %struct.async_poll** %apoll1, align 8
  %ctx2 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %poll = getelementptr inbounds %struct.async_poll, %struct.async_poll* %0, i64 0, i32 0
  %call = call fastcc i1 @io_poll_rewait(%struct.io_kiocb* noundef %req, %struct.io_poll_iocb* noundef %poll) #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup

if.end:                                           ; preds = %entry
  %hash_node = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 15
  call fastcc void @hash_del(%struct.hlist_node* noundef %hash_node) #25
  call fastcc void @io_poll_remove_double(%struct.io_kiocb* noundef %req) #25
  %done = getelementptr inbounds %struct.async_poll, %struct.async_poll* %0, i64 0, i32 0, i32 3
  store i8 1, i8* %done, align 4
  %rlock.i26 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i26) #27
  %canceled = getelementptr inbounds %struct.async_poll, %struct.async_poll* %0, i64 0, i32 0, i32 4
  %2 = load volatile i8, i8* %canceled, align 1, !range !18
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  call void @io_req_task_submit(%struct.io_kiocb* noundef %req, i8* noundef %locked) #25
  br label %cleanup

if.else:                                          ; preds = %if.end
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef -125) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_prep_async_link(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 4096
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %for.cond4.preheader, label %if.then

for.cond4.preheader:                              ; preds = %entry
  %tobool5.not24 = icmp eq %struct.io_kiocb* %req, null
  br i1 %tobool5.not24, label %if.end, label %for.body6

if.then:                                          ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %tobool2.not22 = icmp eq %struct.io_kiocb* %req, null
  br i1 %tobool2.not22, label %for.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %cur.023 = phi %struct.io_kiocb* [ %2, %for.body ], [ %req, %if.then ]
  call fastcc void @io_prep_async_work(%struct.io_kiocb* noundef nonnull %cur.023) #25
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %cur.023, i64 0, i32 11
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %tobool2.not = icmp eq %struct.io_kiocb* %2, null
  br i1 %tobool2.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %if.then
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %if.end

for.body6:                                        ; preds = %for.cond4.preheader, %for.body6
  %cur.125 = phi %struct.io_kiocb* [ %3, %for.body6 ], [ %req, %for.cond4.preheader ]
  call fastcc void @io_prep_async_work(%struct.io_kiocb* noundef nonnull %cur.125) #25
  %link8 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %cur.125, i64 0, i32 11
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %link8, align 8
  %tobool5.not = icmp eq %struct.io_kiocb* %3, null
  br i1 %tobool5.not, label %if.end, label %for.body6

if.end:                                           ; preds = %for.body6, %for.cond4.preheader, %for.end
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @io_wq_enqueue(%struct.io_wq* noundef, %struct.io_wq_work* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_prep_async_work(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 262144
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %or = or i32 %2, 262144
  store i32 %or, i32* %flags, align 8
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 80
  %5 = load %struct.cred*, %struct.cred** %cred, align 8
  %call3 = call fastcc %struct.cred* @get_cred(%struct.cred* noundef %5) #25
  %creds = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 18
  store %struct.cred* %call3, %struct.cred** %creds, align 8
  %.pre = load i32, i32* %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = phi i32 [ %.pre, %if.then ], [ %2, %entry ]
  %work = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 17
  %next = getelementptr inbounds %struct.io_wq_work, %struct.io_wq_work* %work, i64 0, i32 0, i32 0
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %next, align 8
  %flags5 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 17, i32 1
  %and7 = and i32 %6, 16
  store i32 %and7, i32* %flags5, align 8
  %and15 = and i32 %6, 8388608
  %tobool16.not = icmp eq i32 %and15, 0
  br i1 %tobool16.not, label %if.else, label %if.then17

if.then17:                                        ; preds = %if.end
  %7 = getelementptr %struct.io_op_def, %struct.io_op_def* %arrayidx, i64 0, i32 0
  %bf.load = load i16, i16* %7, align 4
  %8 = and i16 %bf.load, 2
  %tobool18.not = icmp eq i16 %8, 0
  br i1 %tobool18.not, label %lor.lhs.false, label %if.then22

lor.lhs.false:                                    ; preds = %if.then17
  %flags19 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 2
  %9 = load i32, i32* %flags19, align 8
  %and20 = and i32 %9, 1
  %tobool21.not = icmp eq i32 %and20, 0
  br i1 %tobool21.not, label %if.end45, label %if.then22

if.then22:                                        ; preds = %lor.lhs.false, %if.then17
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %10 = load %struct.file*, %struct.file** %file, align 8
  %call24 = call fastcc %struct.inode* @file_inode(%struct.file* noundef %10) #25
  %11 = bitcast %struct.inode* %call24 to i8*
  call void @io_wq_hash_work(%struct.io_wq_work* noundef %work, i8* noundef %11) #27
  br label %if.end45

if.else:                                          ; preds = %if.end
  %file26 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %12 = load %struct.file*, %struct.file** %file26, align 8
  %tobool27.not = icmp eq %struct.file* %12, null
  br i1 %tobool27.not, label %if.then33, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %if.else
  %call30 = call fastcc %struct.inode* @file_inode(%struct.file* noundef nonnull %12) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call30, i64 0, i32 0
  %13 = load i16, i16* %i_mode, align 8
  %14 = and i16 %13, -4096
  %cmp = icmp eq i16 %14, 24576
  br i1 %cmp, label %if.end45, label %if.then33

if.then33:                                        ; preds = %lor.lhs.false28, %if.else
  %15 = getelementptr %struct.io_op_def, %struct.io_op_def* %arrayidx, i64 0, i32 0
  %bf.load34 = load i16, i16* %15, align 4
  %16 = and i16 %bf.load34, 4
  %tobool38.not = icmp eq i16 %16, 0
  br i1 %tobool38.not, label %if.end45, label %if.then39

if.then39:                                        ; preds = %if.then33
  %or42 = or i32 %and7, 4
  store i32 %or42, i32* %flags5, align 8
  br label %if.end45

if.end45:                                         ; preds = %lor.lhs.false28, %if.then39, %if.then33, %lor.lhs.false, %if.then22
  %17 = load i8, i8* %opcode, align 8
  switch i8 %17, label %sw.epilog [
    i8 30, label %sw.bb
    i8 33, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end45, %if.end45
  %file_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %18 = bitcast i64* %file_in to %struct.file**
  %19 = load %struct.file*, %struct.file** %18, align 8
  %call48 = call fastcc %struct.inode* @file_inode(%struct.file* noundef %19) #25
  %i_mode49 = getelementptr inbounds %struct.inode, %struct.inode* %call48, i64 0, i32 0
  %20 = load i16, i16* %i_mode49, align 8
  %21 = and i16 %20, -4096
  %cmp52 = icmp eq i16 %21, -32768
  br i1 %cmp52, label %sw.epilog, label %if.then54

if.then54:                                        ; preds = %sw.bb
  %22 = load i32, i32* %flags5, align 8
  %or57 = or i32 %22, 4
  store i32 %or57, i32* %flags5, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.then54, %if.end45
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.cred* @get_cred(%struct.cred* noundef %cred) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.cred* %cred, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 19
  %non_rcu = bitcast %union.anon.30* %0 to i32*
  store i32 0, i32* %non_rcu, align 8
  %call = call fastcc %struct.cred* @get_new_cred(%struct.cred* noundef nonnull %cred) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  ret %struct.cred* %cred
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @io_wq_hash_work(%struct.io_wq_work* noundef, i8* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.cred* @get_new_cred(%struct.cred* noundef returned %cred) unnamed_addr #1 {
entry:
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %cred, i64 0, i32 0
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %usage) #27
  ret %struct.cred* %cred
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_commit_cqring_flush(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %off_timeout_used = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %off_timeout_used, align 4
  %0 = and i8 %bf.load, 16
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_flush_timeouts(%struct.io_ring_ctx* noundef %ctx) #25
  %bf.load1.pre = load i8, i8* %off_timeout_used, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %bf.load1 = phi i8 [ %bf.load1.pre, %if.then ], [ %bf.load, %entry ]
  %1 = and i8 %bf.load1, 32
  %tobool5.not = icmp eq i8 %1, 0
  br i1 %tobool5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  call fastcc void @io_queue_deferred(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_flush_timeouts(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 0
  %0 = load i32, i32* %cached_cq_tail, align 64
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 6, i32 0
  %1 = load volatile i32, i32* %counter.i, align 4
  %sub = sub i32 %0, %1
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 1, i32 0, i32 0
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %timeout_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 12
  %call134 = call fastcc i32 @list_empty(%struct.list_head* noundef %timeout_list) #25
  %tobool.not35 = icmp eq i32 %call134, 0
  br i1 %tobool.not35, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %entry
  %2 = bitcast %struct.list_head* %timeout_list to i8**
  %cq_last_tm_flush = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 7
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  %3 = load i8*, i8** %2, align 8
  %add.ptr = getelementptr i8, i8* %3, i64 -16
  %4 = bitcast i8* %add.ptr to %struct.io_kiocb*
  %call3 = call fastcc i1 @io_is_timeout_noseq(%struct.io_kiocb* noundef %4) #25
  br i1 %call3, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %target_seq = getelementptr i8, i8* %3, i64 -4
  %5 = bitcast i8* %target_seq to i32*
  %6 = load i32, i32* %5, align 4
  %7 = load i32, i32* %cq_last_tm_flush, align 8
  %sub4 = sub i32 %6, %7
  %sub6 = sub i32 %sub, %7
  %cmp = icmp ult i32 %sub6, %sub4
  br i1 %cmp, label %while.end, label %cleanup

cleanup:                                          ; preds = %if.end
  %8 = bitcast i8* %3 to %struct.list_head*
  call fastcc void @list_del_init(%struct.list_head* noundef %8) #25
  call fastcc void @io_kill_timeout(%struct.io_kiocb* noundef %4, i32 noundef 0) #25
  %call1 = call fastcc i32 @list_empty(%struct.list_head* noundef %timeout_list) #25
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %while.body, label %while.end

while.end:                                        ; preds = %cleanup, %while.body, %if.end, %entry
  %cq_last_tm_flush12 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 7
  store i32 %sub, i32* %cq_last_tm_flush12, align 8
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_queue_deferred(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %defer_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 5
  %call13 = call fastcc i32 @list_empty(%struct.list_head* noundef %defer_list) #25
  %tobool.not14 = icmp eq i32 %call13, 0
  br i1 %tobool.not14, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %entry
  %0 = bitcast %struct.list_head* %defer_list to i8**
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  %1 = load i8*, i8** %0, align 8
  %req = getelementptr inbounds i8, i8* %1, i64 16
  %2 = bitcast i8* %req to %struct.io_kiocb**
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %2, align 8
  %seq = getelementptr inbounds i8, i8* %1, i64 24
  %4 = bitcast i8* %seq to i32*
  %5 = load i32, i32* %4, align 8
  %call2 = call fastcc i1 @req_need_defer(%struct.io_kiocb* noundef %3, i32 noundef %5) #25
  br i1 %call2, label %while.end, label %cleanup

cleanup:                                          ; preds = %while.body
  %list = bitcast i8* %1 to %struct.list_head*
  call fastcc void @list_del_init(%struct.list_head* noundef %list) #25
  %6 = load %struct.io_kiocb*, %struct.io_kiocb** %2, align 8
  call fastcc void @io_req_task_queue(%struct.io_kiocb* noundef %6) #25
  call void @kfree(i8* noundef %1) #27
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %defer_list) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %while.body, label %while.end

while.end:                                        ; preds = %cleanup, %while.body, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_kill_timeout(%struct.io_kiocb* noundef %req, i32 noundef %status) unnamed_addr #1 {
entry:
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %0 = bitcast i8** %async_data to %struct.io_timeout_data**
  %1 = load %struct.io_timeout_data*, %struct.io_timeout_data** %0, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %1, i64 0, i32 1
  %call = call i32 @hrtimer_try_to_cancel(%struct.hrtimer* noundef %timer) #27
  %cmp.not = icmp eq i32 %call, -1
  br i1 %cmp.not, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %tobool.not = icmp eq i32 %status, 0
  br i1 %tobool.not, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 10, i32 6, i32 0
  %3 = load volatile i32, i32* %counter.i, align 4
  %add = add i32 %3, 1
  store volatile i32 %add, i32* %counter.i, align 4
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %4 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @list_del_init(%struct.list_head* noundef %4) #25
  %5 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  %6 = load i64, i64* %user_data, align 8
  %conv = sext i32 %status to i64
  %call6 = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %5, i64 noundef %6, i64 noundef %conv, i32 noundef 0) #25
  call fastcc void @io_put_req_deferred(%struct.io_kiocb* noundef %req) #25
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @req_need_defer(%struct.io_kiocb* nocapture noundef readonly %req, i32 noundef %seq) unnamed_addr #8 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.then, !prof !8

if.then:                                          ; preds = %entry
  %ctx3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx3, align 8
  %cq_extra = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 10, i32 5
  %2 = load volatile i32, i32* %cq_extra, align 64
  %add = add i32 %2, %seq
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 10, i32 0
  %3 = load i32, i32* %cached_cq_tail, align 64
  %cmp = icmp ne i32 %add, %3
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i1 [ %cmp, %if.then ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %ti, i32 noundef %flag) unnamed_addr #8 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i64 0, i32 0
  %div.i = lshr i32 %flag, 6
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr i64, i64* %flags, i64 %idxprom.i
  %0 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i32 %flag, 63
  %sh_prom.i = zext i32 %and.i to i64
  %shr.i = lshr i64 %0, %sh_prom.i
  %1 = trunc i64 %shr.i to i32
  %conv.i = and i32 %1, 1
  ret i32 %conv.i
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @list_cut_position(%struct.list_head* noundef %list, %struct.list_head* noundef %head, %struct.list_head* noundef %entry1) unnamed_addr #9 {
entry:
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %head) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %if.end10

if.end:                                           ; preds = %entry
  %call2 = call fastcc i32 @list_is_singular(%struct.list_head* noundef %head) #25
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  %cmp.not = icmp eq %struct.list_head* %0, %entry1
  %cmp5.not = icmp eq %struct.list_head* %head, %entry1
  %or.cond = or i1 %cmp5.not, %cmp.not
  br i1 %or.cond, label %if.end7, label %if.end10

if.end7:                                          ; preds = %land.lhs.true, %if.end
  %cmp8 = icmp eq %struct.list_head* %entry1, %head
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %list) #25
  br label %if.end10

if.else:                                          ; preds = %if.end7
  call fastcc void @__list_cut_position(%struct.list_head* noundef %list, %struct.list_head* noundef %head, %struct.list_head* noundef %entry1) #25
  br label %if.end10

if.end10:                                         ; preds = %land.lhs.true, %entry, %if.else, %if.then9
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @list_is_singular(%struct.list_head* noundef %head) unnamed_addr #8 {
entry:
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %head) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %cmp = icmp eq %struct.list_head* %0, %1
  %phi.cast = zext i1 %cmp to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i32 [ 0, %entry ], [ %phi.cast, %land.rhs ]
  ret i32 %2
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @__list_cut_position(%struct.list_head* noundef %list, %struct.list_head* noundef %head, %struct.list_head* noundef %entry1) unnamed_addr #12 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i64 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next2, align 8
  %next3 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 0
  store %struct.list_head* %1, %struct.list_head** %next3, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i64 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8
  %prev5 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i64 0, i32 1
  store %struct.list_head* %entry1, %struct.list_head** %prev5, align 8
  store %struct.list_head* %list, %struct.list_head** %next, align 8
  store %struct.list_head* %0, %struct.list_head** %next2, align 8
  %prev8 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i64 0, i32 1
  store %struct.list_head* %head, %struct.list_head** %prev8, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @tracehook_notify_signal() unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %2 = getelementptr %struct.task_struct, %struct.task_struct* %1, i64 0, i32 0
  call fastcc void @clear_ti_thread_flag(%struct.thread_info* noundef %2) #25
  call void asm sideeffect "dmb ish", "~{memory}"() #26, !srcloc !107
  %task_works = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 96
  %3 = load %struct.callback_head*, %struct.callback_head** %task_works, align 32
  %tobool.not = icmp eq %struct.callback_head* %3, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @task_work_run() #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @clear_ti_thread_flag(%struct.thread_info* noundef %ti) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i64 0, i32 0
  call fastcc void @clear_bit(i64 noundef 6, i64* noundef %flags) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @task_work_run() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__cond_resched() local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__ll_sc_atomic_sub(%struct.atomic_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i64 0, i32 0
  %0 = call { i32, i64 } asm sideeffect "// atomic_sub\0A\09prfm\09pstl1strm, $2\0A1:\09ldxr\09${0:w}, $2\0A\09sub\09${0:w}, ${0:w}, ${3:w}\0A\09stxr\09${1:w}, ${0:w}, $2\0A\09cbnz\09${1:w}, 1b\0A", "=&r,=&r,=*Q,Jr,*Q"(i32* elementtype(i32) %counter, i32 1, i32* elementtype(i32) %counter) #26, !srcloc !108
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @io_wq_put_and_exit(%struct.io_wq* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__do_sys_io_uring_enter(i32 noundef %fd, i32 noundef %to_submit, i32 noundef %min_complete, i32 noundef %flags, i8* noundef %argp, i64 noundef %argsz) unnamed_addr #1 {
entry:
  %argsz.addr = alloca i64, align 8
  %sig = alloca %struct.sigset_t*, align 8
  %ts = alloca %struct.__kernel_timespec*, align 8
  store i64 %argsz, i64* %argsz.addr, align 8
  %call = call fastcc i1 @io_run_task_work() #25
  %tobool.not = icmp ult i32 %flags, 16
  br i1 %tobool.not, label %if.end, label %cleanup145, !prof !8

if.end:                                           ; preds = %entry
  %call3 = call fastcc [2 x i64] @fdget(i32 noundef %fd) #25
  %call3.fca.0.extract = extractvalue [2 x i64] %call3, 0
  %0 = inttoptr i64 %call3.fca.0.extract to %struct.file*
  %tobool4.not = icmp eq i64 %call3.fca.0.extract, 0
  br i1 %tobool4.not, label %cleanup145, label %if.end15, !prof !24

if.end15:                                         ; preds = %if.end
  %f_op = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp.not = icmp eq %struct.file_operations* %1, @io_uring_fops
  br i1 %cmp.not, label %if.end26, label %out_fput.thread, !prof !8

if.end26:                                         ; preds = %if.end15
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 15
  %2 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %2, align 8
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 0, i32 0
  %call28 = call fastcc i1 @percpu_ref_tryget(%struct.percpu_ref* noundef %refs) #25
  br i1 %call28, label %if.end39, label %out_fput.thread, !prof !8

if.end39:                                         ; preds = %if.end26
  %flags40 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 0, i32 2
  %4 = load i32, i32* %flags40, align 8
  %and41 = and i32 %4, 64
  %tobool42.not = icmp eq i32 %and41, 0
  br i1 %tobool42.not, label %if.end51, label %out_fput, !prof !8

if.end51:                                         ; preds = %if.end39
  %and53 = and i32 %4, 2
  %tobool54.not = icmp eq i32 %and53, 0
  br i1 %tobool54.not, label %if.else, label %if.then55

if.then55:                                        ; preds = %if.end51
  %call56 = call fastcc i1 @io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %3) #25
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 5
  %5 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %5, i64 0, i32 4
  %6 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %cmp57 = icmp eq %struct.task_struct* %6, null
  br i1 %cmp57, label %out_fput, label %if.end67, !prof !24

if.end67:                                         ; preds = %if.then55
  %and68 = and i32 %flags, 2
  %tobool69.not = icmp eq i32 %and68, 0
  br i1 %tobool69.not, label %if.end72, label %if.then70

if.then70:                                        ; preds = %if.end67
  %wait = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %5, i64 0, i32 5
  call void @__wake_up(%struct.wait_queue_head* noundef %wait, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %if.end67
  %and73 = and i32 %flags, 4
  %tobool74.not = icmp eq i32 %and73, 0
  br i1 %tobool74.not, label %if.end103, label %if.then75

if.then75:                                        ; preds = %if.end72
  call fastcc void @io_sqpoll_wait_sq(%struct.io_ring_ctx* noundef %3) #25
  br label %if.end103

if.else:                                          ; preds = %if.end51
  %tobool82.not = icmp eq i32 %to_submit, 0
  br i1 %tobool82.not, label %if.end103, label %if.then83

if.then83:                                        ; preds = %if.else
  %call84 = call fastcc i32 @io_uring_add_tctx_node(%struct.io_ring_ctx* noundef %3) #25
  %conv85 = sext i32 %call84 to i64
  %tobool86.not = icmp eq i32 %call84, 0
  br i1 %tobool86.not, label %if.end95, label %out_fput, !prof !8

if.end95:                                         ; preds = %if.then83
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %call96 = call fastcc i32 @io_submit_sqes(%struct.io_ring_ctx* noundef %3, i32 noundef %to_submit) #25
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %cmp98.not = icmp eq i32 %call96, %to_submit
  br i1 %cmp98.not, label %if.end103, label %out_fput

if.end103:                                        ; preds = %if.end72, %if.then75, %if.else, %if.end95
  %and104 = and i32 %flags, 1
  %tobool105.not = icmp eq i32 %and104, 0
  br i1 %tobool105.not, label %out_fput, label %if.then106

if.then106:                                       ; preds = %if.end103
  %7 = bitcast %struct.sigset_t** %sig to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #26
  store %struct.sigset_t* null, %struct.sigset_t** %sig, align 8, !annotation !14
  %8 = bitcast %struct.__kernel_timespec** %ts to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #26
  store %struct.__kernel_timespec* null, %struct.__kernel_timespec** %ts, align 8, !annotation !14
  %call107 = call fastcc i32 @io_get_ext_arg(i32 noundef %flags, i8* noundef %argp, i64* noundef nonnull %argsz.addr, %struct.__kernel_timespec** noundef nonnull %ts, %struct.sigset_t** noundef nonnull %sig) #25
  %tobool109.not = icmp eq i32 %call107, 0
  br i1 %tobool109.not, label %if.end118, label %cleanup, !prof !8

if.end118:                                        ; preds = %if.then106
  %cq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 10, i32 1
  %9 = load i32, i32* %cq_entries, align 4
  %cmp120 = icmp ugt i32 %9, %min_complete
  %cond = select i1 %cmp120, i32 %min_complete, i32 %9
  %10 = load i32, i32* %flags40, align 8
  %11 = and i32 %10, 3
  %12 = icmp eq i32 %11, 1
  br i1 %12, label %if.then128, label %if.else132

if.then128:                                       ; preds = %if.end118
  %conv129 = zext i32 %cond to i64
  %call130 = call fastcc i32 @io_iopoll_check(%struct.io_ring_ctx* noundef %3, i64 noundef %conv129) #25
  br label %cleanup

if.else132:                                       ; preds = %if.end118
  %13 = load %struct.sigset_t*, %struct.sigset_t** %sig, align 8
  %14 = load i64, i64* %argsz.addr, align 8
  %15 = load %struct.__kernel_timespec*, %struct.__kernel_timespec** %ts, align 8
  %call133 = call fastcc i32 @io_cqring_wait(%struct.io_ring_ctx* noundef %3, i32 noundef %cond, %struct.sigset_t* noundef %13, i64 noundef %14, %struct.__kernel_timespec* noundef %15) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then128, %if.else132, %if.then106
  %ret.3.in = phi i32 [ %call107, %if.then106 ], [ %call133, %if.else132 ], [ %call130, %if.then128 ]
  %ret.3 = sext i32 %ret.3.in to i64
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #26
  br label %out_fput

out_fput.thread:                                  ; preds = %if.end15, %if.end26
  %ret.5.ph = phi i64 [ -6, %if.end26 ], [ -95, %if.end15 ]
  call fastcc void @fdput([2 x i64] %call3) #25
  br label %16

out_fput:                                         ; preds = %if.end39, %if.then83, %if.end95, %if.end103, %if.then55, %cleanup
  %ret.4 = phi i64 [ -77, %if.end39 ], [ %ret.3, %cleanup ], [ 0, %if.end103 ], [ %conv85, %if.then83 ], [ 0, %if.end95 ], [ -130, %if.then55 ]
  %submitted.1 = phi i32 [ 0, %if.end39 ], [ %to_submit, %cleanup ], [ %to_submit, %if.end103 ], [ 0, %if.then83 ], [ %call96, %if.end95 ], [ 0, %if.then55 ]
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs) #25
  call fastcc void @fdput([2 x i64] %call3) #25
  %tobool139.not = icmp eq i32 %submitted.1, 0
  %conv141 = sext i32 %submitted.1 to i64
  br i1 %tobool139.not, label %16, label %cleanup145

16:                                               ; preds = %out_fput.thread, %out_fput
  %ret.5200 = phi i64 [ %ret.5.ph, %out_fput.thread ], [ %ret.4, %out_fput ]
  br label %cleanup145

cleanup145:                                       ; preds = %16, %out_fput, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -9, %if.end ], [ %ret.5200, %16 ], [ %conv141, %out_fput ]
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc [2 x i64] @fdget(i32 noundef %fd) unnamed_addr #1 {
entry:
  %call = call i64 @__fdget(i32 noundef %fd) #27
  %call1 = call fastcc [2 x i64] @__to_fd(i64 noundef %call) #25
  ret [2 x i64] %call1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 8
  %0 = load volatile i64, i64* %check_cq_overflow, align 8
  %conv.i17 = and i64 %0, 1
  %tobool.not = icmp eq i64 %conv.i17, 0
  br i1 %tobool.not, label %if.end10, label %if.then

if.then:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %call3 = call fastcc i1 @__io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx, i1 noundef false) #25
  %2 = load i32, i32* %flags, align 8
  %and5 = and i32 %2, 1
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.end
  %uring_lock8 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock8) #27
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then7, %entry
  %ret.0.shrunk = phi i1 [ %call3, %if.then7 ], [ %call3, %if.end ], [ true, %entry ]
  ret i1 %ret.0.shrunk
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_sqpoll_wait_sq(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %wait = alloca %struct.wait_queue_entry, align 8
  %0 = bitcast %struct.wait_queue_entry* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %0) #26
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %3 = bitcast i8** %private to %struct.task_struct**
  %4 = bitcast %struct.wait_queue_entry* %wait to i64*
  store i64 0, i64* %4, align 8
  store %struct.task_struct* %2, %struct.task_struct** %3, align 8
  %func = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 2
  store i32 (%struct.wait_queue_entry*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func, align 8
  %entry1 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 0
  store %struct.list_head* %entry1, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3, i32 1
  store %struct.list_head* %entry1, %struct.list_head** %prev, align 8
  %sqo_sq_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 6
  br label %do.body

do.body:                                          ; preds = %if.end7, %entry
  %call4 = call fastcc i1 @io_sqring_full(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call4, label %if.end, label %do.end

if.end:                                           ; preds = %do.body
  call void @prepare_to_wait(%struct.wait_queue_head* noundef %sqo_sq_wait, %struct.wait_queue_entry* noundef nonnull %wait, i32 noundef 1) #27
  %call5 = call fastcc i1 @io_sqring_full(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call5, label %if.end7, label %do.end

if.end7:                                          ; preds = %if.end
  call void @schedule() #27
  %call9 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %2) #25
  %tobool.not = icmp eq i32 %call9, 0
  br i1 %tobool.not, label %do.body, label %do.end

do.end:                                           ; preds = %if.end, %do.body, %if.end7
  call void @finish_wait(%struct.wait_queue_head* noundef %sqo_sq_wait, %struct.wait_queue_entry* noundef nonnull %wait) #27
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %0) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_uring_add_tctx_node(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %2, null
  br i1 %tobool.not, label %if.end, label %land.rhs, !prof !24

land.rhs:                                         ; preds = %entry
  %last = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 3
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %last, align 8
  %cmp = icmp eq %struct.io_ring_ctx* %3, %ctx
  br i1 %cmp, label %cleanup, label %if.end, !prof !8

if.end:                                           ; preds = %entry, %land.rhs
  %call3 = call fastcc i32 @__io_uring_add_tctx_node(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

cleanup:                                          ; preds = %land.rhs, %if.end
  %retval.0 = phi i32 [ %call3, %if.end ], [ 0, %land.rhs ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_submit_sqes(%struct.io_ring_ctx* noundef %ctx, i32 noundef %nr) unnamed_addr #1 {
entry:
  %sq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 4
  %0 = load i32, i32* %sq_entries, align 4
  %cmp = icmp ugt i32 %0, %nr
  %cond = select i1 %cmp, i32 %nr, i32 %0
  %call = call fastcc i32 @io_sqring_entries(%struct.io_ring_ctx* noundef %ctx) #25
  %cmp2 = icmp ult i32 %cond, %call
  %cond6 = select i1 %cmp2, i32 %cond, i32 %call
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  %conv = zext i32 %cond6 to i64
  %call7 = call fastcc i1 @percpu_ref_tryget_many(%struct.percpu_ref* noundef %refs, i64 noundef %conv) #25
  br i1 %call7, label %if.end, label %cleanup60

if.end:                                           ; preds = %entry
  call fastcc void @io_get_task_refs(i32 noundef %cond6) #25
  %submit_state = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11
  call fastcc void @io_submit_state_start(%struct.io_submit_state* noundef %submit_state, i32 noundef %cond6) #25
  br label %while.cond

while.cond:                                       ; preds = %if.end33, %if.end
  %submitted.0 = phi i32 [ 0, %if.end ], [ %inc, %if.end33 ]
  %exitcond.not = icmp eq i32 %submitted.0, %cond6
  br i1 %exitcond.not, label %if.end58, label %while.body

while.body:                                       ; preds = %while.cond
  %call10 = call fastcc %struct.io_kiocb* @io_alloc_req(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool.not = icmp eq %struct.io_kiocb* %call10, null
  br i1 %tobool.not, label %if.then15, label %if.end19, !prof !24

if.then15:                                        ; preds = %while.body
  %tobool16.not = icmp eq i32 %submitted.0, 0
  %spec.store.select = select i1 %tobool16.not, i32 -11, i32 %submitted.0
  br label %while.end

if.end19:                                         ; preds = %while.body
  %call20 = call fastcc %struct.io_uring_sqe* @io_get_sqe(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool21.not = icmp eq %struct.io_uring_sqe* %call20, null
  br i1 %tobool21.not, label %if.then31, label %if.end33, !prof !24

if.then31:                                        ; preds = %if.end19
  %inflight_entry = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call10, i64 0, i32 13
  %free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 7
  call fastcc void @list_add(%struct.list_head* noundef %inflight_entry, %struct.list_head* noundef %free_list) #25
  br label %while.end

if.end33:                                         ; preds = %if.end19
  %inc = add i32 %submitted.0, 1
  %call34 = call fastcc i32 @io_submit_sqe(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef nonnull %call10, %struct.io_uring_sqe* noundef nonnull %call20) #25
  %tobool35.not = icmp eq i32 %call34, 0
  br i1 %tobool35.not, label %while.cond, label %while.end

while.end:                                        ; preds = %if.end33, %if.then31, %if.then15
  %submitted.2 = phi i32 [ %submitted.0, %if.then31 ], [ %spec.store.select, %if.then15 ], [ %inc, %if.end33 ]
  %cmp39.not = icmp eq i32 %submitted.2, %cond6
  br i1 %cmp39.not, label %if.end58, label %if.then48, !prof !8

if.then48:                                        ; preds = %while.end
  %cmp49 = icmp eq i32 %submitted.2, -11
  %cond54 = select i1 %cmp49, i32 0, i32 %submitted.2
  %sub = sub i32 %cond6, %cond54
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i64 0, i32 85
  %3 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %3, i64 0, i32 0
  %4 = load i32, i32* %cached_refs, align 8
  %add = add i32 %4, %sub
  store i32 %add, i32* %cached_refs, align 8
  %conv57 = sext i32 %sub to i64
  call fastcc void @percpu_ref_put_many(%struct.percpu_ref* noundef %refs, i64 noundef %conv57) #25
  br label %if.end58

if.end58:                                         ; preds = %while.cond, %if.then48, %while.end
  %submitted.2112 = phi i32 [ %submitted.2, %if.then48 ], [ %submitted.2, %while.end ], [ %cond6, %while.cond ]
  call fastcc void @io_submit_state_end(%struct.io_submit_state* noundef %submit_state, %struct.io_ring_ctx* noundef %ctx) #25
  call fastcc void @io_commit_sqring(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup60

cleanup60:                                        ; preds = %entry, %if.end58
  %retval.0 = phi i32 [ %submitted.2112, %if.end58 ], [ -11, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_get_ext_arg(i32 noundef %flags, i8* noundef %argp, i64* nocapture noundef %argsz, %struct.__kernel_timespec** nocapture noundef writeonly %ts, %struct.sigset_t** nocapture noundef writeonly %sig) unnamed_addr #1 {
entry:
  %arg = alloca %struct.io_uring_getevents_arg, align 8
  %0 = bitcast %struct.io_uring_getevents_arg* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(24) %0, i8 0, i64 24, i1 false), !annotation !14
  %and = and i32 %flags, 8
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast %struct.sigset_t** %sig to i8**
  store i8* %argp, i8** %1, align 8
  br label %cleanup.sink.split

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %argsz, align 8
  %cmp.not = icmp eq i64 %2, 24
  br i1 %cmp.not, label %if.end2, label %cleanup

if.end2:                                          ; preds = %if.end
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %argp, i64 noundef 24) #27
  %tobool3.not = icmp eq i64 %call2.i, 0
  br i1 %tobool3.not, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end2
  %sigmask = getelementptr inbounds %struct.io_uring_getevents_arg, %struct.io_uring_getevents_arg* %arg, i64 0, i32 0
  %3 = load i64, i64* %sigmask, align 8
  %4 = inttoptr i64 %3 to %struct.sigset_t*
  store %struct.sigset_t* %4, %struct.sigset_t** %sig, align 8
  %sigmask_sz = getelementptr inbounds %struct.io_uring_getevents_arg, %struct.io_uring_getevents_arg* %arg, i64 0, i32 1
  %5 = load i32, i32* %sigmask_sz, align 8
  %conv8 = zext i32 %5 to i64
  store i64 %conv8, i64* %argsz, align 8
  %ts15 = getelementptr inbounds %struct.io_uring_getevents_arg, %struct.io_uring_getevents_arg* %arg, i64 0, i32 3
  %6 = load i64, i64* %ts15, align 8
  %7 = inttoptr i64 %6 to %struct.__kernel_timespec*
  br label %cleanup.sink.split

cleanup.sink.split:                               ; preds = %if.then, %if.end5
  %.sink = phi %struct.__kernel_timespec* [ %7, %if.end5 ], [ null, %if.then ]
  store %struct.__kernel_timespec* %.sink, %struct.__kernel_timespec** %ts, align 8
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %if.end2, %if.end
  %retval.0 = phi i32 [ -22, %if.end ], [ -14, %if.end2 ], [ 0, %cleanup.sink.split ]
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_iopoll_check(%struct.io_ring_ctx* noundef %ctx, i64 noundef %min) unnamed_addr #1 {
entry:
  %nr_events = alloca i32, align 4
  %0 = bitcast i32* %nr_events to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #26
  store i32 0, i32* %nr_events, align 4
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 8
  %1 = load volatile i64, i64* %check_cq_overflow, align 8
  %conv.i45 = and i64 %1, 1
  %tobool.not = icmp eq i64 %conv.i45, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call fastcc i1 @__io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx, i1 noundef false) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call2 = call fastcc i32 @io_cqring_events(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %do.body.preheader, label %out

do.body.preheader:                                ; preds = %if.end
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 0
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 2
  br label %do.body

do.body:                                          ; preds = %do.body.preheader, %land.rhs
  %call6 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end18, label %if.then8

if.then8:                                         ; preds = %do.body
  %2 = load i32, i32* %cached_cq_tail, align 64
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %call10 = call fastcc i1 @io_run_task_work() #25
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %3 = load i32, i32* %cached_cq_tail, align 64
  %cmp.not = icmp eq i32 %2, %3
  br i1 %cmp.not, label %lor.lhs.false, label %out

lor.lhs.false:                                    ; preds = %if.then8
  %call14 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %if.end18, label %out

if.end18:                                         ; preds = %lor.lhs.false, %do.body
  %call19 = call fastcc i32 @io_do_iopoll(%struct.io_ring_ctx* noundef %ctx, i32* noundef nonnull %nr_events, i64 noundef %min) #25
  %tobool20.not = icmp eq i32 %call19, 0
  br i1 %tobool20.not, label %land.lhs.true, label %out

land.lhs.true:                                    ; preds = %if.end18
  %4 = load i32, i32* %nr_events, align 4
  %conv = zext i32 %4 to i64
  %cmp21 = icmp slt i64 %conv, %min
  br i1 %cmp21, label %land.rhs, label %out

land.rhs:                                         ; preds = %land.lhs.true
  %5 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %6 = inttoptr i64 %5 to %struct.task_struct*
  %7 = getelementptr %struct.task_struct, %struct.task_struct* %6, i64 0, i32 0
  %call1.i = call fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %7, i32 noundef 1) #27
  %tobool.i.not = icmp eq i32 %call1.i, 0
  br i1 %tobool.i.not, label %do.body, label %out

out:                                              ; preds = %lor.lhs.false, %if.then8, %if.end18, %land.lhs.true, %land.rhs, %if.end
  %ret.1 = phi i32 [ 0, %if.end ], [ 0, %lor.lhs.false ], [ 0, %if.then8 ], [ 0, %land.lhs.true ], [ 0, %land.rhs ], [ %call19, %if.end18 ]
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #26
  ret i32 %ret.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_cqring_wait(%struct.io_ring_ctx* noundef %ctx, i32 noundef %min_events, %struct.sigset_t* noundef %sig, i64 noundef %sigsz, %struct.__kernel_timespec* noundef %uts) unnamed_addr #1 {
entry:
  %iowq = alloca %struct.io_wait_queue, align 8
  %timeout = alloca i64, align 8
  %ts = alloca %struct.timespec64, align 8
  %0 = bitcast %struct.io_wait_queue* %iowq to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(56) %0, i8 0, i64 56, i1 false), !annotation !14
  %rings1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %1 = load %struct.io_rings*, %struct.io_rings** %rings1, align 16
  %2 = bitcast i64* %timeout to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %2) #26
  store i64 9223372036854775807, i64* %timeout, align 8
  br label %do.body

do.body:                                          ; preds = %if.end, %entry
  %call = call fastcc i1 @io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx) #25
  %call2 = call fastcc i32 @io_cqring_events(%struct.io_ring_ctx* noundef %ctx) #25
  %cmp.not = icmp ult i32 %call2, %min_events
  br i1 %cmp.not, label %if.end, label %cleanup57

if.end:                                           ; preds = %do.body
  %call3 = call fastcc i1 @io_run_task_work() #25
  br i1 %call3, label %do.body, label %do.end

do.end:                                           ; preds = %if.end
  %tobool.not = icmp eq %struct.__kernel_timespec* %uts, null
  br i1 %tobool.not, label %if.end12, label %if.then6

if.then6:                                         ; preds = %do.end
  %3 = bitcast %struct.timespec64* %ts to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %3) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %3, i8 0, i64 16, i1 false), !annotation !14
  %call7 = call i32 @get_timespec64(%struct.timespec64* noundef nonnull %ts, %struct.__kernel_timespec* noundef nonnull %uts) #27
  %tobool8.not = icmp eq i32 %call7, 0
  br i1 %tobool8.not, label %if.end10, label %cleanup57.critedge

if.end10:                                         ; preds = %if.then6
  %call11 = call i64 @timespec64_to_jiffies(%struct.timespec64* noundef nonnull %ts) #27
  store i64 %call11, i64* %timeout, align 8
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %3) #26
  br label %if.end12

if.end12:                                         ; preds = %if.end10, %do.end
  %tobool13.not = icmp eq %struct.sigset_t* %sig, null
  br i1 %tobool13.not, label %if.end19, label %if.then14

if.then14:                                        ; preds = %if.end12
  %call15 = call i32 @set_user_sigmask(%struct.sigset_t* noundef nonnull %sig, i64 noundef %sigsz) #27
  %tobool16.not = icmp eq i32 %call15, 0
  br i1 %tobool16.not, label %if.end19, label %cleanup57

if.end19:                                         ; preds = %if.then14, %if.end12
  %wq = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 0
  call fastcc void @init_waitqueue_func_entry(%struct.wait_queue_entry* noundef nonnull %wq, i32 (%struct.wait_queue_entry*, i32, i32, i8*)* noundef nonnull @io_wake_function) #25
  %4 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %5 = inttoptr i64 %4 to %struct.task_struct*
  %private = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 0, i32 1
  %6 = bitcast i8** %private to %struct.task_struct**
  store %struct.task_struct* %5, %struct.task_struct** %6, align 8
  %entry23 = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 0, i32 3
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %entry23) #25
  %ctx24 = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 1
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %ctx24, align 8
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 6, i32 0
  %7 = load volatile i32, i32* %counter.i, align 4
  %nr_timeouts = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 3
  store i32 %7, i32* %nr_timeouts, align 4
  %8 = load %struct.io_rings*, %struct.io_rings** %rings1, align 16
  %head = getelementptr inbounds %struct.io_rings, %struct.io_rings* %8, i64 0, i32 1, i32 0
  %9 = load volatile i32, i32* %head, align 64
  %add = add i32 %9, %min_events
  %cq_tail = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 2
  store i32 %add, i32* %cq_tail, align 8
  %cq_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 4
  br label %do.body30

do.body30:                                        ; preds = %if.end33, %if.end19
  %call31 = call fastcc i1 @io_cqring_overflow_flush(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call31, label %if.end33, label %do.end43

if.end33:                                         ; preds = %do.body30
  %call35 = call i1 @prepare_to_wait_exclusive(%struct.wait_queue_head* noundef %cq_wait, %struct.wait_queue_entry* noundef nonnull %wq, i32 noundef 1) #27
  %call36 = call fastcc i32 @io_cqring_wait_schedule(%struct.io_ring_ctx* noundef %ctx, %struct.io_wait_queue* noundef nonnull %iowq, i64* noundef nonnull %timeout) #25
  call void @finish_wait(%struct.wait_queue_head* noundef %cq_wait, %struct.wait_queue_entry* noundef nonnull %wq) #27
  call fastcc void @_cond_resched() #25
  %cmp42 = icmp sgt i32 %call36, 0
  br i1 %cmp42, label %do.body30, label %do.end43

do.end43:                                         ; preds = %do.body30, %if.end33
  %ret.0 = phi i32 [ %call36, %if.end33 ], [ -16, %do.body30 ]
  %cmp44 = icmp eq i32 %ret.0, -4
  call fastcc void @restore_saved_sigmask_unless(i1 noundef %cmp44) #25
  %head50 = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 1, i32 0
  %10 = load volatile i32, i32* %head50, align 64
  %tail = getelementptr inbounds %struct.io_rings, %struct.io_rings* %1, i64 0, i32 1, i32 2
  %11 = load volatile i32, i32* %tail, align 64
  %cmp56 = icmp eq i32 %10, %11
  %cond = select i1 %cmp56, i32 %ret.0, i32 0
  br label %cleanup57

cleanup57.critedge:                               ; preds = %if.then6
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %3) #26
  br label %cleanup57

cleanup57:                                        ; preds = %do.body, %if.then14, %cleanup57.critedge, %do.end43
  %retval.1 = phi i32 [ %cond, %do.end43 ], [ -14, %cleanup57.critedge ], [ %call15, %if.then14 ], [ 0, %do.body ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %2) #26
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %0) #26
  ret i32 %retval.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @fdput([2 x i64] %fd.coerce) unnamed_addr #1 {
entry:
  %fd.coerce.fca.1.extract = extractvalue [2 x i64] %fd.coerce, 1
  %and1 = and i64 %fd.coerce.fca.1.extract, 1
  %tobool.not = icmp eq i64 %and1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %fd.coerce.fca.0.extract = extractvalue [2 x i64] %fd.coerce, 0
  %0 = inttoptr i64 %fd.coerce.fca.0.extract to %struct.file*
  call void @fput(%struct.file* noundef %0) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc [2 x i64] @__to_fd(i64 noundef %v) unnamed_addr #0 {
entry:
  %and = and i64 %v, -4
  %conv = and i64 %v, 3
  %.fca.0.insert = insertvalue [2 x i64] poison, i64 %and, 0
  %.fca.1.insert = insertvalue [2 x i64] %.fca.0.insert, i64 %conv, 1
  ret [2 x i64] %.fca.1.insert
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__fdget(i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @signal_pending(%struct.task_struct* noundef %p) unnamed_addr #8 {
entry:
  %call = call fastcc i32 @test_tsk_thread_flag(%struct.task_struct* noundef %p, i32 noundef 6) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return, !prof !8

if.end:                                           ; preds = %entry
  %call3 = call fastcc i32 @task_sigpending(%struct.task_struct* noundef %p) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call3, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @test_tsk_thread_flag(%struct.task_struct* noundef %tsk, i32 noundef %flag) unnamed_addr #8 {
entry:
  %call = call fastcc %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %tsk) #25
  %call1 = call fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %call, i32 noundef %flag) #25
  ret i32 %call1
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @task_sigpending(%struct.task_struct* noundef %p) unnamed_addr #8 {
entry:
  %call = call fastcc i32 @test_tsk_thread_flag(%struct.task_struct* noundef %p, i32 noundef 0) #25
  %tobool = icmp ne i32 %call, 0
  %lnot.ext = zext i1 %tobool to i32
  ret i32 %lnot.ext
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc %struct.thread_info* @task_thread_info(%struct.task_struct* noundef readnone %task) unnamed_addr #0 {
entry:
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_uring_add_tctx_node(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %limits = alloca i64, align 8, !annotation !14
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %2, null
  br i1 %tobool.not, label %if.then, label %if.end26, !prof !24

if.then:                                          ; preds = %entry
  %call5 = call fastcc i32 @io_uring_alloc_task_context(%struct.task_struct* noundef %1, %struct.io_ring_ctx* noundef %ctx) #25
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %if.end, label %cleanup44, !prof !8

if.end:                                           ; preds = %if.then
  %3 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %iowq_limits_set = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 9
  %4 = load i8, i8* %iowq_limits_set, align 16, !range !18
  %tobool17.not = icmp eq i8 %4, 0
  br i1 %tobool17.not, label %if.end26, label %if.then18

if.then18:                                        ; preds = %if.end
  %5 = bitcast i64* %limits to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #26
  %arrayinit.begin = bitcast i64* %limits to i32*
  %arrayidx = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8, i64 0
  %6 = load i32, i32* %arrayidx, align 8
  store i32 %6, i32* %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds i32, i32* %arrayinit.begin, i64 1
  %arrayidx20 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8, i64 1
  %7 = load i32, i32* %arrayidx20, align 4
  store i32 %7, i32* %arrayinit.element, align 4
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %3, i64 0, i32 4
  %8 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %call21 = call i32 @io_wq_max_workers(%struct.io_wq* noundef %8, i32* noundef nonnull %arrayinit.begin) #27
  %tobool22.not = icmp eq i32 %call21, 0
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #26
  br i1 %tobool22.not, label %if.end26, label %cleanup44

if.end26:                                         ; preds = %if.end, %if.then18, %entry
  %tctx.0 = phi %struct.io_uring_task* [ %3, %if.then18 ], [ %3, %if.end ], [ %2, %entry ]
  %xa = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx.0, i64 0, i32 1
  %9 = ptrtoint %struct.io_ring_ctx* %ctx to i64
  %call27 = call i8* @xa_load(%struct.xarray* noundef %xa, i64 noundef %9) #27
  %tobool28.not = icmp eq i8* %call27, null
  br i1 %tobool28.not, label %if.then29, label %if.end43

if.then29:                                        ; preds = %if.end26
  %10 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %10, i32 noundef 3264) #27
  %tobool31.not = icmp eq i8* %call.i.i, null
  br i1 %tobool31.not, label %cleanup44, label %if.end33

if.end33:                                         ; preds = %if.then29
  %ctx34 = getelementptr inbounds i8, i8* %call.i.i, i64 24
  %11 = bitcast i8* %ctx34 to %struct.io_ring_ctx**
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %11, align 8
  %task = getelementptr inbounds i8, i8* %call.i.i, i64 16
  %12 = bitcast i8* %task to %struct.task_struct**
  store %struct.task_struct* %1, %struct.task_struct** %12, align 8
  %call37 = call i8* @xa_store(%struct.xarray* noundef %xa, i64 noundef %9, i8* noundef nonnull %call.i.i, i32 noundef 3264) #27
  %call38 = call fastcc i32 @xa_err(i8* noundef %call37) #25
  %tobool39.not = icmp eq i32 %call38, 0
  br i1 %tobool39.not, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end33
  call void @kfree(i8* noundef nonnull %call.i.i) #27
  br label %cleanup44

if.end41:                                         ; preds = %if.end33
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %ctx_node = bitcast i8* %call.i.i to %struct.list_head*
  %tctx_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 6
  call fastcc void @list_add(%struct.list_head* noundef nonnull %ctx_node, %struct.list_head* noundef %tctx_list) #25
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end43

if.end43:                                         ; preds = %if.end41, %if.end26
  %last = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx.0, i64 0, i32 3
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %last, align 8
  br label %cleanup44

cleanup44:                                        ; preds = %if.then29, %if.then, %if.then18, %if.end43, %if.then40
  %retval.1 = phi i32 [ 0, %if.end43 ], [ %call38, %if.then40 ], [ %call21, %if.then18 ], [ %call5, %if.then ], [ -12, %if.then29 ]
  ret i32 %retval.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_uring_alloc_task_context(%struct.task_struct* noundef %task, %struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #25
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %inflight = getelementptr inbounds i8, i8* %call, i64 64
  %0 = bitcast i8* %inflight to %struct.percpu_counter*
  %call4 = call i32 @__percpu_counter_init(%struct.percpu_counter* noundef %0, i64 noundef 0, i32 noundef 3264, %struct.lock_class_key* noundef nonnull @io_uring_alloc_task_context.__key) #27
  %tobool5.not = icmp eq i32 %call4, 0
  br i1 %tobool5.not, label %if.end14, label %if.then13, !prof !8

if.then13:                                        ; preds = %if.end
  call void @kfree(i8* noundef nonnull %call) #27
  br label %cleanup

if.end14:                                         ; preds = %if.end
  %call15 = call fastcc %struct.io_wq* @io_init_wq_offload(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task) #25
  %io_wq = getelementptr inbounds i8, i8* %call, i64 56
  %1 = bitcast i8* %io_wq to %struct.io_wq**
  store %struct.io_wq* %call15, %struct.io_wq** %1, align 8
  %2 = bitcast %struct.io_wq* %call15 to i8*
  %call17 = call fastcc i1 @IS_ERR(i8* noundef %2) #25
  br i1 %call17, label %if.then18, label %if.end23

if.then18:                                        ; preds = %if.end14
  %call20 = call fastcc i64 @PTR_ERR(i8* noundef %2) #25
  %conv21 = trunc i64 %call20 to i32
  call void @percpu_counter_destroy(%struct.percpu_counter* noundef %0) #27
  call void @kfree(i8* noundef nonnull %call) #27
  br label %cleanup

if.end23:                                         ; preds = %if.end14
  %xa = getelementptr inbounds i8, i8* %call, i64 8
  %3 = bitcast i8* %xa to %struct.xarray*
  call fastcc void @xa_init(%struct.xarray* noundef %3) #25
  %wait = getelementptr inbounds i8, i8* %call, i64 24
  %4 = bitcast i8* %wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %4, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_uring_alloc_task_context.__key.23) #27
  %in_idle = getelementptr inbounds i8, i8* %call, i64 92
  %counter.i = bitcast i8* %in_idle to i32*
  store volatile i32 0, i32* %counter.i, align 4
  %inflight_tracked = getelementptr inbounds i8, i8* %call, i64 88
  %counter.i56 = bitcast i8* %inflight_tracked to i32*
  store volatile i32 0, i32* %counter.i56, align 4
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i64 0, i32 85
  %5 = bitcast %struct.io_uring_task** %io_uring to i8**
  store i8* %call, i8** %5, align 8
  %task_lock = getelementptr inbounds i8, i8* %call, i64 96
  %6 = bitcast i8* %task_lock to i32*
  store i32 0, i32* %6, align 8
  %task_list = getelementptr inbounds i8, i8* %call, i64 104
  %first = bitcast i8* %task_list to %struct.io_wq_work_node**
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %first, align 8
  %last = getelementptr inbounds i8, i8* %call, i64 112
  %7 = bitcast i8* %last to %struct.io_wq_work_node**
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %7, align 8
  %task_work = getelementptr inbounds i8, i8* %call, i64 120
  %8 = bitcast i8* %task_work to %struct.callback_head*
  call fastcc void @init_task_work(%struct.callback_head* noundef %8, void (%struct.callback_head*)* noundef nonnull @tctx_task_work) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end23, %if.then18, %if.then13
  %retval.0 = phi i32 [ %call4, %if.then13 ], [ %conv21, %if.then18 ], [ 0, %if.end23 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @io_wq_max_workers(%struct.io_wq* noundef, i32* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @xa_err(i8* noundef %entry1) unnamed_addr #0 {
entry:
  %call = call fastcc i1 @xa_is_err(i8* noundef %entry1) #25
  %0 = ptrtoint i8* %entry1 to i64
  %1 = lshr i64 %0, 2
  %conv = trunc i64 %1 to i32
  %retval.0 = select i1 %call, i32 %conv, i32 0
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @xa_store(%struct.xarray* noundef, i64 noundef, i8* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__percpu_counter_init(%struct.percpu_counter* noundef, i64 noundef, i32 noundef, %struct.lock_class_key* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_wq* @io_init_wq_offload(%struct.io_ring_ctx* noundef %ctx, %struct.task_struct* noundef %task) unnamed_addr #1 {
entry:
  %data = alloca %struct.io_wq_data, align 8
  %0 = bitcast %struct.io_wq_data* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %0) #26
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %hash_map = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 0
  %1 = load %struct.io_wq_hash*, %struct.io_wq_hash** %hash_map, align 16
  %tobool.not = icmp eq %struct.io_wq_hash* %1, null
  br i1 %tobool.not, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %call = call fastcc i8* @kzalloc(i64 noundef 40, i32 noundef 3264) #25
  %tobool1.not = icmp eq i8* %call, null
  br i1 %tobool1.not, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %call4 = call fastcc i8* @ERR_PTR(i64 noundef -12) #25
  %2 = bitcast i8* %call4 to %struct.io_wq*
  br label %cleanup

if.end:                                           ; preds = %if.then
  %3 = bitcast i8* %call to %struct.io_wq_hash*
  %refs = bitcast i8* %call to %struct.refcount_struct*
  call fastcc void @refcount_set(%struct.refcount_struct* noundef nonnull %refs) #25
  %wait = getelementptr inbounds i8, i8* %call, i64 16
  %4 = bitcast i8* %wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %4, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.25, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_init_wq_offload.__key) #27
  %5 = bitcast %struct.io_wq_hash** %hash_map to i8**
  store i8* %call, i8** %5, align 16
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  %hash.0 = phi %struct.io_wq_hash* [ %1, %entry ], [ %3, %if.end ]
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %hash8 = getelementptr inbounds %struct.io_wq_data, %struct.io_wq_data* %data, i64 0, i32 0
  store %struct.io_wq_hash* %hash.0, %struct.io_wq_hash** %hash8, align 8
  %task9 = getelementptr inbounds %struct.io_wq_data, %struct.io_wq_data* %data, i64 0, i32 1
  store %struct.task_struct* %task, %struct.task_struct** %task9, align 8
  %free_work = getelementptr inbounds %struct.io_wq_data, %struct.io_wq_data* %data, i64 0, i32 3
  store %struct.io_wq_work* (%struct.io_wq_work*)* @io_wq_free_work, %struct.io_wq_work* (%struct.io_wq_work*)** %free_work, align 8
  %do_work = getelementptr inbounds %struct.io_wq_data, %struct.io_wq_data* %data, i64 0, i32 2
  store void (%struct.io_wq_work*)* @io_wq_submit_work, void (%struct.io_wq_work*)** %do_work, align 8
  %sq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 4
  %6 = load i32, i32* %sq_entries, align 4
  %call10 = call fastcc i32 @num_online_cpus() #25
  %mul = shl i32 %call10, 2
  %cmp = icmp ult i32 %6, %mul
  %cond = select i1 %cmp, i32 %6, i32 %mul
  %call11 = call %struct.io_wq* @io_wq_create(i32 noundef %cond, %struct.io_wq_data* noundef nonnull %data) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then2
  %retval.0 = phi %struct.io_wq* [ %call11, %if.end6 ], [ %2, %if.then2 ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %0) #26
  ret %struct.io_wq* %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @xa_init(%struct.xarray* nocapture noundef writeonly %xa) unnamed_addr #10 {
entry:
  call fastcc void @xa_init_flags(%struct.xarray* noundef %xa, i32 noundef 0) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__init_waitqueue_head(%struct.wait_queue_head* noundef, i8* noundef, %struct.lock_class_key* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @tctx_task_work(%struct.callback_head* noundef %cb) #1 {
entry:
  %locked = alloca i8, align 4
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %locked) #26
  store i8 0, i8* %locked, align 4
  %add.ptr = getelementptr %struct.callback_head, %struct.callback_head* %cb, i64 -8, i32 1
  %task_list = getelementptr inbounds void (%struct.callback_head*)*, void (%struct.callback_head*)** %add.ptr, i64 13
  %first = bitcast void (%struct.callback_head*)** %task_list to %struct.io_wq_work_node**
  %task_lock = getelementptr inbounds void (%struct.callback_head*)*, void (%struct.callback_head*)** %add.ptr, i64 12
  %rlock.i = bitcast void (%struct.callback_head*)** %task_lock to %struct.raw_spinlock*
  %last = getelementptr inbounds void (%struct.callback_head*)*, void (%struct.callback_head*)** %add.ptr, i64 14
  %0 = bitcast void (%struct.callback_head*)** %last to %struct.io_wq_work_node**
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %entry
  %1 = phi i8 [ 0, %entry ], [ %.pre, %cleanup ]
  %ctx.0 = phi %struct.io_ring_ctx* [ null, %entry ], [ %ctx.2, %cleanup ]
  %2 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %first, align 8
  %tobool.not = icmp ne %struct.io_wq_work_node* %2, null
  %tobool1.not = icmp eq i8 %1, 0
  %or.cond = select i1 %tobool.not, i1 true, i1 %tobool1.not
  br i1 %or.cond, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %while.cond
  %compl_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx.0, i64 0, i32 1, i32 11, i32 6
  %3 = load i32, i32* %compl_nr, align 8
  %tobool3.not = icmp eq i32 %3, 0
  br i1 %tobool3.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %ctx.0) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true2, %while.cond
  call fastcc void @__raw_spin_lock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  %4 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %first, align 8
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %first, align 8
  store %struct.io_wq_work_node* null, %struct.io_wq_work_node** %0, align 8
  %tobool12.not = icmp eq %struct.io_wq_work_node* %4, null
  br i1 %tobool12.not, label %while.end, label %do.body19.critedge

do.body19.critedge:                               ; preds = %if.end
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %do.body19

do.body19:                                        ; preds = %do.body19.critedge, %if.end31
  %node.0 = phi %struct.io_wq_work_node* [ %5, %if.end31 ], [ %4, %do.body19.critedge ]
  %ctx.1 = phi %struct.io_ring_ctx* [ %ctx.2, %if.end31 ], [ %ctx.0, %do.body19.critedge ]
  %next20 = getelementptr inbounds %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0, i64 0, i32 0
  %5 = load %struct.io_wq_work_node*, %struct.io_wq_work_node** %next20, align 8
  %add.ptr2664 = getelementptr %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0, i64 -18
  %6 = bitcast %struct.io_wq_work_node* %add.ptr2664 to %struct.io_kiocb*
  %ctx27 = getelementptr %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0, i64 -8
  %7 = bitcast %struct.io_wq_work_node* %ctx27 to %struct.io_ring_ctx**
  %8 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %7, align 8
  %cmp.not = icmp eq %struct.io_ring_ctx* %8, %ctx.1
  br i1 %cmp.not, label %if.end31, label %if.then28

if.then28:                                        ; preds = %do.body19
  call fastcc void @ctx_flush_and_put(%struct.io_ring_ctx* noundef %ctx.1, i8* noundef nonnull %locked) #25
  %9 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %7, align 8
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %9, i64 0, i32 1, i32 0
  %call = call i32 @mutex_trylock(%struct.mutex* noundef %uring_lock) #27
  %tobool30 = icmp ne i32 %call, 0
  %frombool = zext i1 %tobool30 to i8
  store i8 %frombool, i8* %locked, align 4
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %9, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_get(%struct.percpu_ref* noundef %refs) #25
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %do.body19
  %ctx.2 = phi %struct.io_ring_ctx* [ %9, %if.then28 ], [ %ctx.1, %do.body19 ]
  %func = getelementptr inbounds %struct.io_wq_work_node, %struct.io_wq_work_node* %node.0, i64 1
  %10 = bitcast %struct.io_wq_work_node* %func to void (%struct.io_kiocb*, i8*)**
  %11 = load void (%struct.io_kiocb*, i8*)*, void (%struct.io_kiocb*, i8*)** %10, align 8
  call void %11(%struct.io_kiocb* noundef %6, i8* noundef nonnull %locked) #27
  %tobool33.not = icmp eq %struct.io_wq_work_node* %5, null
  br i1 %tobool33.not, label %cleanup, label %do.body19

cleanup:                                          ; preds = %if.end31
  call fastcc void @_cond_resched() #25
  %.pre = load i8, i8* %locked, align 4
  br label %while.cond

while.end:                                        ; preds = %if.end
  %task_running = getelementptr inbounds void (%struct.callback_head*)*, void (%struct.callback_head*)** %add.ptr, i64 17
  %12 = bitcast void (%struct.callback_head*)** %task_running to i8*
  store i8 0, i8* %12, align 8
  call fastcc void @__raw_spin_unlock_irq(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @ctx_flush_and_put(%struct.io_ring_ctx* noundef %ctx.0, i8* noundef nonnull %locked) #25
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %locked) #26
  ret void
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc void @refcount_set(%struct.refcount_struct* noundef %r) unnamed_addr #9 {
entry:
  %counter.i = getelementptr inbounds %struct.refcount_struct, %struct.refcount_struct* %r, i64 0, i32 0, i32 0
  store volatile i32 1, i32* %counter.i, align 4
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal %struct.io_wq_work* @io_wq_free_work(%struct.io_wq_work* noundef %work) #1 {
entry:
  %add.ptr = getelementptr %struct.io_wq_work, %struct.io_wq_work* %work, i64 -12, i32 1
  %0 = bitcast i32* %add.ptr to %struct.io_kiocb*
  %call = call fastcc %struct.io_kiocb* @io_put_req_find_next(%struct.io_kiocb* noundef %0) #25
  %tobool.not = icmp eq %struct.io_kiocb* %call, null
  %work1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %call, i64 0, i32 17
  %cond = select i1 %tobool.not, %struct.io_wq_work* null, %struct.io_wq_work* %work1
  ret %struct.io_wq_work* %cond
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_wq_submit_work(%struct.io_wq_work* noundef %work) #1 {
entry:
  %add.ptr = getelementptr %struct.io_wq_work, %struct.io_wq_work* %work, i64 -12, i32 1
  %0 = bitcast i32* %add.ptr to %struct.io_kiocb*
  %1 = getelementptr inbounds i32, i32* %add.ptr, i64 22
  %2 = load i32, i32* %1, align 8
  %and = and i32 %2, 524288
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call fastcc void @__io_req_set_refcount(%struct.io_kiocb* noundef %0, i32 noundef 2) #25
  br label %if.end

if.else:                                          ; preds = %entry
  call fastcc void @req_ref_get(%struct.io_kiocb* noundef %0) #25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call = call fastcc %struct.io_kiocb* @io_prep_linked_timeout(%struct.io_kiocb* noundef %0) #25
  %tobool1.not = icmp eq %struct.io_kiocb* %call, null
  br i1 %tobool1.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  call fastcc void @io_queue_linked_timeout(%struct.io_kiocb* noundef nonnull %call) #25
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %flags4 = getelementptr inbounds %struct.io_wq_work, %struct.io_wq_work* %work, i64 0, i32 1
  %3 = load i32, i32* %flags4, align 8
  %and5 = and i32 %3, 1
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %do.body11.preheader, label %if.then21

do.body11.preheader:                              ; preds = %if.end3
  %call1237 = call fastcc i32 @io_issue_sqe(%struct.io_kiocb* noundef %0, i32 noundef 0) #25
  %cmp.not38 = icmp eq i32 %call1237, -11
  br i1 %cmp.not38, label %if.end14, label %if.end19

if.end14:                                         ; preds = %do.body11.preheader, %if.end14
  call fastcc void @_cond_resched() #25
  %call12 = call fastcc i32 @io_issue_sqe(%struct.io_kiocb* noundef %0, i32 noundef 0) #25
  %cmp.not = icmp eq i32 %call12, -11
  br i1 %cmp.not, label %if.end14, label %if.end19

if.end19:                                         ; preds = %if.end14, %do.body11.preheader
  %ret.1 = phi i32 [ %call1237, %do.body11.preheader ], [ %call12, %if.end14 ]
  %tobool20.not = icmp eq i32 %ret.1, 0
  br i1 %tobool20.not, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end3, %if.end19
  %ret.141 = phi i32 [ %ret.1, %if.end19 ], [ -125, %if.end3 ]
  call fastcc void @io_req_task_queue_fail(%struct.io_kiocb* noundef %0, i32 noundef %ret.141) #25
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end19
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @num_online_cpus() unnamed_addr #8 {
entry:
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @__num_online_cpus, i64 0, i32 0), align 4
  ret i32 %0
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.io_wq* @io_wq_create(i32 noundef, %struct.io_wq_data* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_task_queue_fail(%struct.io_kiocb* noundef %req, i32 noundef %ret) unnamed_addr #1 {
entry:
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %ret, i32* %result, align 4
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 14, i32 1
  store void (%struct.io_kiocb*, i8*)* @io_req_task_cancel, void (%struct.io_kiocb*, i8*)** %func, align 8
  call fastcc void @io_req_task_work_add(%struct.io_kiocb* noundef %req) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_req_task_cancel(%struct.io_kiocb* noundef %req, i8* nocapture noundef %locked) #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  call fastcc void @io_tw_lock(%struct.io_ring_ctx* noundef %0, i8* noundef %locked) #25
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %1 = load i32, i32* %result, align 4
  %conv = zext i32 %1 to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @xa_init_flags(%struct.xarray* nocapture noundef writeonly %xa, i32 noundef %flags) unnamed_addr #10 {
entry:
  %.compoundliteral.sroa.0.0..sroa_idx = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0
  store i32 0, i32* %.compoundliteral.sroa.0.0..sroa_idx, align 8
  %xa_flags = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 1
  store i32 %flags, i32* %xa_flags, align 4
  %xa_head = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 2
  store i8* null, i8** %xa_head, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @ctx_flush_and_put(%struct.io_ring_ctx* noundef %ctx, i8* nocapture noundef %locked) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq %struct.io_ring_ctx* %ctx, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* %locked, align 1, !range !18
  %tobool1.not = icmp eq i8 %0, 0
  br i1 %tobool1.not, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.end
  %compl_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 6
  %1 = load i32, i32* %compl_nr, align 8
  %tobool3.not = icmp eq i32 %1, 0
  br i1 %tobool3.not, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.then2
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef nonnull %ctx) #25
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then2
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  store i8 0, i8* %locked, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs) #25
  br label %return

return:                                           ; preds = %entry, %if.end6
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_ref_get(%struct.percpu_ref* noundef %ref) unnamed_addr #1 {
entry:
  call fastcc void @percpu_ref_get_many(%struct.percpu_ref* noundef %ref) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @percpu_ref_get_many(%struct.percpu_ref* noundef %ref) unnamed_addr #1 {
entry:
  %percpu_count = alloca i64*, align 8
  %0 = bitcast i64** %percpu_count to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64* null, i64** %percpu_count, align 8, !annotation !14
  call fastcc void @__rcu_read_lock() #27
  %call = call fastcc i1 @__ref_is_percpu(%struct.percpu_ref* noundef %ref, i64** noundef nonnull %percpu_count) #25
  br i1 %call, label %do.body1, label %if.else

do.body1:                                         ; preds = %entry
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !109
  %1 = load i64*, i64** %percpu_count, align 8
  %2 = ptrtoint i64* %1 to i64
  %call7 = call fastcc i64 @__kern_my_cpu_offset() #25
  %add = add i64 %call7, %2
  %3 = inttoptr i64 %add to i8*
  call fastcc void @__percpu_add_case_64(i8* noundef %3, i64 noundef 1) #25
  call void asm sideeffect "", "~{memory}"() #26, !srcloc !110
  br label %if.end

if.else:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 0, i32 1
  %4 = load %struct.percpu_ref_data*, %struct.percpu_ref_data** %data, align 8
  %count = getelementptr inbounds %struct.percpu_ref_data, %struct.percpu_ref_data* %4, i64 0, i32 0
  call fastcc void @__ll_sc_atomic64_add(i64 noundef 1, %struct.atomic64_t* noundef %count) #27
  br label %if.end

if.end:                                           ; preds = %if.else, %do.body1
  call fastcc void @rcu_read_unlock() #25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i1 @xa_is_err(i8* noundef %entry1) unnamed_addr #0 {
entry:
  %call = call fastcc i1 @xa_is_internal(i8* noundef %entry1) #25
  %cmp = icmp uge i8* %entry1, inttoptr (i64 -16378 to i8*)
  %spec.select = and i1 %cmp, %call
  ret i1 %spec.select
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i1 @xa_is_internal(i8* noundef %entry1) unnamed_addr #0 {
entry:
  %0 = ptrtoint i8* %entry1 to i64
  %and = and i64 %0, 3
  %cmp = icmp eq i64 %and, 2
  ret i1 %cmp
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqring_entries(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #1 {
entry:
  %rings1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings1, align 16
  %tail = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 0, i32 2
  %1 = call i32 asm sideeffect "ldar ${0:w}, $1", "=r,*Q,~{memory}"(i32* elementtype(i32) %tail) #26, !srcloc !111
  %cached_sq_head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 3
  %2 = load i32, i32* %cached_sq_head, align 16
  %sub = sub i32 %1, %2
  ret i32 %sub
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_get_task_refs(i32 noundef %nr) unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 0
  %3 = load i32, i32* %cached_refs, align 8
  %sub = sub i32 %3, %nr
  store i32 %sub, i32* %cached_refs, align 8
  %cmp = icmp slt i32 %sub, 0
  br i1 %cmp, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %entry
  call fastcc void @io_task_refs_refill(%struct.io_uring_task* noundef %2) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @io_submit_state_start(%struct.io_submit_state* nocapture noundef writeonly %state, i32 noundef %max_ios) unnamed_addr #10 {
entry:
  %plug_started = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 4
  store i8 0, i8* %plug_started, align 4
  %ios_left = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 8
  store i32 %max_ios, i32* %ios_left, align 8
  %head = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 1, i32 0
  store %struct.io_kiocb* null, %struct.io_kiocb** %head, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_kiocb* @io_alloc_req(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %free_reqs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 3
  %0 = load i32, i32* %free_reqs, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %lor.rhs, label %got_req

lor.rhs:                                          ; preds = %entry
  %call = call fastcc i1 @io_flush_cached_reqs(%struct.io_ring_ctx* noundef %ctx) #25
  br i1 %call, label %lor.rhs.got_req_crit_edge, label %if.end, !prof !8

lor.rhs.got_req_crit_edge:                        ; preds = %lor.rhs
  %.pre = load i32, i32* %free_reqs, align 8
  br label %got_req

if.end:                                           ; preds = %lor.rhs
  %1 = load %struct.kmem_cache*, %struct.kmem_cache** @req_cachep, align 8
  %arraydecay = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 2, i64 0
  %call3 = call i32 @kmem_cache_alloc_bulk(%struct.kmem_cache* noundef %1, i32 noundef 11456, i64 noundef 8, i8** noundef %arraydecay) #27
  %cmp = icmp slt i32 %call3, 1
  br i1 %cmp, label %if.then12, label %for.body.preheader, !prof !24

if.then12:                                        ; preds = %if.end
  %2 = load %struct.kmem_cache*, %struct.kmem_cache** @req_cachep, align 8
  %call13 = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %2, i32 noundef 11456) #27
  store i8* %call13, i8** %arraydecay, align 8
  %tobool17.not = icmp eq i8* %call13, null
  br i1 %tobool17.not, label %cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %if.end, %if.then12
  %ret.0 = phi i32 [ %call3, %if.end ], [ 1, %if.then12 ]
  %wide.trip.count = zext i32 %ret.0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx24 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 2, i64 %indvars.iv
  %3 = bitcast i8** %arrayidx24 to %struct.io_kiocb**
  %4 = load %struct.io_kiocb*, %struct.io_kiocb** %3, align 8
  call fastcc void @io_preinit_req(%struct.io_kiocb* noundef %4, %struct.io_ring_ctx* noundef %ctx) #25
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %got_req, label %for.body

got_req:                                          ; preds = %for.body, %lor.rhs.got_req_crit_edge, %entry
  %5 = phi i32 [ %.pre, %lor.rhs.got_req_crit_edge ], [ %0, %entry ], [ %ret.0, %for.body ]
  %dec = add i32 %5, -1
  store i32 %dec, i32* %free_reqs, align 8
  %idxprom29 = zext i32 %dec to i64
  %arrayidx30 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 2, i64 %idxprom29
  %6 = bitcast i8** %arrayidx30 to %struct.io_kiocb**
  %7 = load %struct.io_kiocb*, %struct.io_kiocb** %6, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %got_req
  %retval.0 = phi %struct.io_kiocb* [ %7, %got_req ], [ null, %if.then12 ]
  ret %struct.io_kiocb* %retval.0
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc %struct.io_uring_sqe* @io_get_sqe(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #9 {
entry:
  %sq_entries = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 4
  %0 = load i32, i32* %sq_entries, align 4
  %sub = add i32 %0, -1
  %cached_sq_head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 3
  %1 = load i32, i32* %cached_sq_head, align 16
  %inc = add i32 %1, 1
  store i32 %inc, i32* %cached_sq_head, align 16
  %and = and i32 %1, %sub
  %sq_array = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 1
  %2 = load i32*, i32** %sq_array, align 32
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr i32, i32* %2, i64 %idxprom
  %3 = load volatile i32, i32* %arrayidx, align 4
  %cmp = icmp ult i32 %3, %0
  br i1 %cmp, label %if.then, label %if.end, !prof !8

if.then:                                          ; preds = %entry
  %sq_sqes = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 2
  %4 = load %struct.io_uring_sqe*, %struct.io_uring_sqe** %sq_sqes, align 8
  %idxprom3 = zext i32 %3 to i64
  %arrayidx4 = getelementptr %struct.io_uring_sqe, %struct.io_uring_sqe* %4, i64 %idxprom3
  br label %cleanup

if.end:                                           ; preds = %entry
  %cq_extra = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 5
  %5 = load i32, i32* %cq_extra, align 64
  %dec = add i32 %5, -1
  store i32 %dec, i32* %cq_extra, align 64
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %6 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %sq_dropped = getelementptr inbounds %struct.io_rings, %struct.io_rings* %6, i64 0, i32 6
  %7 = load volatile i32, i32* %sq_dropped, align 16
  %add = add i32 %7, 1
  store volatile i32 %add, i32* %sq_dropped, align 16
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi %struct.io_uring_sqe* [ %arrayidx4, %if.then ], [ null, %if.end ]
  ret %struct.io_uring_sqe* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_submit_sqe(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %link1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 1
  %call = call fastcc i32 @io_init_req(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.else17, label %fail_req, !prof !8

fail_req:                                         ; preds = %if.else17, %entry
  %ret.0 = phi i32 [ %call, %entry ], [ %call18, %if.else17 ]
  %head = getelementptr inbounds %struct.io_submit_link, %struct.io_submit_link* %link1, i64 0, i32 0
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %head, align 8
  %tobool4.not = icmp eq %struct.io_kiocb* %0, null
  br i1 %tobool4.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %fail_req
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 256
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %if.then8, label %if.end16

if.then8:                                         ; preds = %if.then5
  call fastcc void @req_fail_link_node(%struct.io_kiocb* noundef nonnull %0, i32 noundef -125) #25
  br label %if.end16

if.else:                                          ; preds = %fail_req
  %flags10 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags10, align 8
  %and11 = and i32 %2, 12
  %tobool12.not = icmp eq i32 %and11, 0
  br i1 %tobool12.not, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.else
  %conv14 = sext i32 %ret.0 to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv14) #25
  br label %cleanup

if.end16:                                         ; preds = %if.else, %if.then5, %if.then8
  call fastcc void @req_fail_link_node(%struct.io_kiocb* noundef %req, i32 noundef %ret.0) #25
  br label %if.end29

if.else17:                                        ; preds = %entry
  %call18 = call fastcc i32 @io_req_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.end29, label %fail_req, !prof !8

if.end29:                                         ; preds = %if.else17, %if.end16
  %flags30 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %head34 = getelementptr inbounds %struct.io_submit_link, %struct.io_submit_link* %link1, i64 0, i32 0
  %3 = load %struct.io_kiocb*, %struct.io_kiocb** %head34, align 8
  %tobool35.not = icmp eq %struct.io_kiocb* %3, null
  %4 = load i32, i32* %flags30, align 8
  br i1 %tobool35.not, label %if.else68, label %if.then36

if.then36:                                        ; preds = %if.end29
  %and40 = and i32 %4, 256
  %tobool41.not = icmp eq i32 %and40, 0
  br i1 %tobool41.not, label %if.then42, label %if.end59

if.then42:                                        ; preds = %if.then36
  %call43 = call fastcc i32 @io_req_prep_async(%struct.io_kiocb* noundef %req) #25
  %tobool44.not = icmp eq i32 %call43, 0
  br i1 %tobool44.not, label %if.end59, label %if.then52, !prof !8

if.then52:                                        ; preds = %if.then42
  call fastcc void @req_fail_link_node(%struct.io_kiocb* noundef %req, i32 noundef %call43) #25
  %flags53 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %3, i64 0, i32 7
  %5 = load i32, i32* %flags53, align 8
  %and54 = and i32 %5, 256
  %tobool55.not = icmp eq i32 %and54, 0
  br i1 %tobool55.not, label %if.then56, label %if.end59

if.then56:                                        ; preds = %if.then52
  call fastcc void @req_fail_link_node(%struct.io_kiocb* noundef nonnull %3, i32 noundef -125) #25
  br label %if.end59

if.end59:                                         ; preds = %if.then42, %if.then56, %if.then52, %if.then36
  %last = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 1, i32 1
  %6 = load %struct.io_kiocb*, %struct.io_kiocb** %last, align 8
  %link60 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %6, i64 0, i32 11
  store %struct.io_kiocb* %req, %struct.io_kiocb** %link60, align 8
  store %struct.io_kiocb* %req, %struct.io_kiocb** %last, align 8
  %7 = load i32, i32* %flags30, align 8
  %and63 = and i32 %7, 12
  %tobool64.not = icmp eq i32 %and63, 0
  br i1 %tobool64.not, label %if.then65, label %cleanup

if.then65:                                        ; preds = %if.end59
  store %struct.io_kiocb* null, %struct.io_kiocb** %head34, align 8
  call fastcc void @io_queue_sqe(%struct.io_kiocb* noundef nonnull %3) #25
  br label %cleanup

if.else68:                                        ; preds = %if.end29
  %and70 = and i32 %4, 12
  %tobool71.not = icmp eq i32 %and70, 0
  br i1 %tobool71.not, label %if.else75, label %if.then72

if.then72:                                        ; preds = %if.else68
  store %struct.io_kiocb* %req, %struct.io_kiocb** %head34, align 8
  %last74 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 1, i32 1
  store %struct.io_kiocb* %req, %struct.io_kiocb** %last74, align 8
  br label %cleanup

if.else75:                                        ; preds = %if.else68
  call fastcc void @io_queue_sqe(%struct.io_kiocb* noundef %req) #25
  br label %cleanup

cleanup:                                          ; preds = %if.else75, %if.then72, %if.then65, %if.end59, %if.then13
  %retval.0 = phi i32 [ %ret.0, %if.then13 ], [ 0, %if.end59 ], [ 0, %if.then65 ], [ 0, %if.then72 ], [ 0, %if.else75 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_submit_state_end(%struct.io_submit_state* noundef %state, %struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %head = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 1, i32 0
  %0 = load %struct.io_kiocb*, %struct.io_kiocb** %head, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_queue_sqe(%struct.io_kiocb* noundef nonnull %0) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %compl_nr = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 6
  %1 = load i32, i32* %compl_nr, align 8
  %tobool3.not = icmp eq i32 %1, 0
  br i1 %tobool3.not, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %ctx) #25
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %plug_started = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 4
  %2 = load i8, i8* %plug_started, align 4, !range !18
  %tobool6.not = icmp eq i8 %2, 0
  br i1 %tobool6.not, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  %plug = getelementptr inbounds %struct.io_submit_state, %struct.io_submit_state* %state, i64 0, i32 0
  call void @blk_finish_plug(%struct.blk_plug* noundef %plug) #27
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_commit_sqring(%struct.io_ring_ctx* nocapture noundef readonly %ctx) unnamed_addr #1 {
entry:
  %rings1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings1, align 16
  %head = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 0, i32 0
  %cached_sq_head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 3
  %1 = load i32, i32* %cached_sq_head, align 16
  call void asm sideeffect "stlr ${1:w}, $0", "=*Q,r,~{memory}"(i32* elementtype(i32) %head, i32 %1) #26, !srcloc !112
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_task_refs_refill(%struct.io_uring_task* noundef %tctx) unnamed_addr #1 {
entry:
  %cached_refs = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 0
  %0 = load i32, i32* %cached_refs, align 8
  %add = sub i32 1024, %0
  %inflight = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx, i64 0, i32 5
  %conv = zext i32 %add to i64
  call fastcc void @percpu_counter_add(%struct.percpu_counter* noundef %inflight, i64 noundef %conv) #25
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %usage = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i64 0, i32 3
  call fastcc void @refcount_add(i32 noundef %add, %struct.refcount_struct* noundef %usage) #25
  %3 = load i32, i32* %cached_refs, align 8
  %add2 = add i32 %3, %add
  store i32 %add2, i32* %cached_refs, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @refcount_add(i32 noundef %i, %struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  call fastcc void @__refcount_add(i32 noundef %i, %struct.refcount_struct* noundef %r) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__refcount_add(i32 noundef %i, %struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.refcount_struct, %struct.refcount_struct* %r, i64 0, i32 0
  %call.i.i = call fastcc i32 @__ll_sc_atomic_fetch_add_relaxed(i32 noundef %i, %struct.atomic_t* noundef %refs) #27
  %tobool1.not = icmp eq i32 %call.i.i, 0
  br i1 %tobool1.not, label %if.end18.sink.split, label %if.else, !prof !24

if.else:                                          ; preds = %entry
  %add = add i32 %call.i.i, %i
  %0 = or i32 %add, %call.i.i
  %.not = icmp sgt i32 %0, -1
  br i1 %.not, label %if.end18, label %if.end18.sink.split, !prof !8

if.end18.sink.split:                              ; preds = %if.else, %entry
  %.sink = phi i32 [ 2, %entry ], [ 1, %if.else ]
  call void @refcount_warn_saturate(%struct.refcount_struct* noundef %r, i32 noundef %.sink) #27
  br label %if.end18

if.end18:                                         ; preds = %if.end18.sink.split, %if.else
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__ll_sc_atomic_fetch_add_relaxed(i32 noundef %i, %struct.atomic_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i64 0, i32 0
  %0 = call { i32, i32, i64 } asm sideeffect "// atomic_fetch_add_relaxed\0A\09prfm\09pstl1strm, $3\0A1:\09ldxr\09${0:w}, $3\0A\09add\09${1:w}, ${0:w}, ${4:w}\0A\09stxr\09${2:w}, ${1:w}, $3\0A\09cbnz\09${2:w}, 1b\0A\09", "=&r,=&r,=&r,=*Q,Ir,*Q"(i32* elementtype(i32) %counter, i32 %i, i32* elementtype(i32) %counter) #26, !srcloc !113
  %asmresult = extractvalue { i32, i32, i64 } %0, 0
  ret i32 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_flush_cached_reqs(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %locked_free_nr = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 3
  %0 = load volatile i32, i32* %locked_free_nr, align 16
  %cmp = icmp ugt i32 %0, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %submit_state = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11
  call fastcc void @io_flush_cached_locked_reqs(%struct.io_ring_ctx* noundef %ctx, %struct.io_submit_state* noundef %submit_state) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %free_reqs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 3
  %1 = load i32, i32* %free_reqs, align 8
  %free_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 7
  %2 = bitcast %struct.list_head* %free_list to i8**
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %nr.0 = phi i32 [ %1, %if.end ], [ %inc, %while.body ]
  %call = call fastcc i32 @list_empty(%struct.list_head* noundef %free_list) #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %2, align 8
  %add.ptr = getelementptr i8, i8* %3, i64 -128
  %4 = bitcast i8* %3 to %struct.list_head*
  call fastcc void @list_del(%struct.list_head* noundef %4) #25
  %inc = add i32 %nr.0, 1
  %idxprom = sext i32 %nr.0 to i64
  %arrayidx = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 2, i64 %idxprom
  store i8* %add.ptr, i8** %arrayidx, align 8
  %cmp6 = icmp eq i32 %inc, 32
  br i1 %cmp6, label %while.end, label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  %nr.1 = phi i32 [ 32, %while.body ], [ %nr.0, %while.cond ]
  store i32 %nr.1, i32* %free_reqs, align 8
  %cmp11 = icmp ne i32 %nr.1, 0
  ret i1 %cmp11
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @kmem_cache_alloc_bulk(%struct.kmem_cache* noundef, i32 noundef, i64 noundef, i8** noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @io_preinit_req(%struct.io_kiocb* nocapture noundef writeonly %req, %struct.io_ring_ctx* noundef %ctx) unnamed_addr #10 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %ctx1, align 8
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 11
  store %struct.io_kiocb* null, %struct.io_kiocb** %link, align 8
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  store i8* null, i8** %async_data, align 8
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 0, i32* %result, align 4
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_init_req(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %opcode = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 0
  %0 = load volatile i8, i8* %opcode, align 8
  %opcode1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  store i8 %0, i8* %opcode1, align 8
  %flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 1
  %1 = load volatile i8, i8* %flags, align 1
  %conv = zext i8 %1 to i32
  %flags6 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  store i32 %conv, i32* %flags6, align 8
  %user_data = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 8
  %2 = load volatile i64, i64* %user_data, align 8
  %user_data11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 10
  store i64 %2, i64* %user_data11, align 8
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  store %struct.file* null, %struct.file** %file, align 8
  %fixed_rsrc_refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 12
  store %struct.percpu_ref* null, %struct.percpu_ref** %fixed_rsrc_refs, align 8
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %task = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 9
  store %struct.task_struct* %4, %struct.task_struct** %task, align 8
  %and = and i32 %conv, 192
  %tobool.not = icmp ne i32 %and, 0
  %cmp = icmp ugt i8 %0, 39
  %or.cond = select i1 %tobool.not, i1 true, i1 %cmp
  br i1 %or.cond, label %cleanup, label %if.end26, !prof !114

if.end26:                                         ; preds = %entry
  %call27 = call fastcc i1 @io_check_restriction(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, i32 noundef %conv) #25
  br i1 %call27, label %if.end29, label %cleanup

if.end29:                                         ; preds = %if.end26
  %and30 = and i32 %conv, 32
  %tobool31.not = icmp eq i32 %and30, 0
  br i1 %tobool31.not, label %if.end35, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end29
  %5 = load i8, i8* %opcode1, align 8
  %idxprom = zext i8 %5 to i64
  %6 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom, i32 0
  %bf.load = load i16, i16* %6, align 4
  %7 = and i16 %bf.load, 64
  %tobool33.not = icmp eq i16 %7, 0
  br i1 %tobool33.not, label %cleanup, label %if.end35

if.end35:                                         ; preds = %land.lhs.true, %if.end29
  %and36 = and i32 %conv, 2
  %tobool37.not = icmp eq i32 %and36, 0
  br i1 %tobool37.not, label %do.end51, label %if.then45, !prof !8

if.then45:                                        ; preds = %if.end35
  %drain_active = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load46 = load i8, i8* %drain_active, align 4
  %bf.set = or i8 %bf.load46, 32
  store i8 %bf.set, i8* %drain_active, align 4
  br label %do.end51

do.end51:                                         ; preds = %if.end35, %if.then45
  %personality53 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 10
  %8 = load volatile i16, i16* %personality53, align 2
  %tobool55.not = icmp eq i16 %8, 0
  br i1 %tobool55.not, label %if.end66, label %if.then56

if.then56:                                        ; preds = %do.end51
  %personalities = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 16
  %conv57 = zext i16 %8 to i64
  %call58 = call i8* @xa_load(%struct.xarray* noundef %personalities, i64 noundef %conv57) #27
  %creds = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 18
  %9 = bitcast %struct.cred** %creds to i8**
  store i8* %call58, i8** %9, align 8
  %tobool60.not = icmp eq i8* %call58, null
  br i1 %tobool60.not, label %cleanup, label %if.end62

if.end62:                                         ; preds = %if.then56
  %10 = bitcast i8* %call58 to %struct.cred*
  %call64 = call fastcc %struct.cred* @get_cred(%struct.cred* noundef nonnull %10) #25
  %11 = load i32, i32* %flags6, align 8
  %or = or i32 %11, 262144
  store i32 %or, i32* %flags6, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.end62, %do.end51
  %plug_started = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 4
  %12 = load i8, i8* %plug_started, align 4, !range !18
  %tobool67.not = icmp eq i8 %12, 0
  br i1 %tobool67.not, label %land.lhs.true68, label %if.end82

land.lhs.true68:                                  ; preds = %if.end66
  %ios_left = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 8
  %13 = load i32, i32* %ios_left, align 8
  %cmp69 = icmp ugt i32 %13, 1
  br i1 %cmp69, label %land.lhs.true71, label %if.end82

land.lhs.true71:                                  ; preds = %land.lhs.true68
  %14 = load i8, i8* %opcode1, align 8
  %idxprom73 = zext i8 %14 to i64
  %15 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom73, i32 0
  %bf.load75 = load i16, i16* %15, align 4
  %16 = and i16 %bf.load75, 256
  %tobool79.not = icmp eq i16 %16, 0
  br i1 %tobool79.not, label %if.end82, label %if.then80

if.then80:                                        ; preds = %land.lhs.true71
  %plug = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 0
  call void @blk_start_plug(%struct.blk_plug* noundef %plug) #27
  store i8 1, i8* %plug_started, align 4
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %land.lhs.true71, %land.lhs.true68, %if.end66
  %17 = load i8, i8* %opcode1, align 8
  %idxprom84 = zext i8 %17 to i64
  %18 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %idxprom84, i32 0
  %bf.load86 = load i16, i16* %18, align 4
  %bf.clear87 = and i16 %bf.load86, 1
  %tobool89.not = icmp eq i16 %bf.clear87, 0
  br i1 %tobool89.not, label %if.end112, label %if.then90

if.then90:                                        ; preds = %if.end82
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %19 = load volatile i32, i32* %fd, align 4
  %and95 = and i32 %conv, 1
  %tobool96 = icmp ne i32 %and95, 0
  %call97 = call fastcc %struct.file* @io_file_get(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, i32 noundef %19, i1 noundef %tobool96) #25
  store %struct.file* %call97, %struct.file** %file, align 8
  %tobool100.not = icmp eq %struct.file* %call97, null
  br i1 %tobool100.not, label %if.then110, label %if.end112, !prof !24

if.then110:                                       ; preds = %if.then90
  br label %if.end112

if.end112:                                        ; preds = %if.then90, %if.then110, %if.end82
  %ret.0 = phi i32 [ -9, %if.then110 ], [ 0, %if.then90 ], [ 0, %if.end82 ]
  %ios_left113 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 11, i32 8
  %20 = load i32, i32* %ios_left113, align 8
  %dec = add i32 %20, -1
  store i32 %dec, i32* %ios_left113, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.then56, %land.lhs.true, %if.end26, %entry, %if.end112
  %retval.0 = phi i32 [ %ret.0, %if.end112 ], [ -22, %entry ], [ -13, %if.end26 ], [ -95, %land.lhs.true ], [ -22, %if.then56 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc void @req_fail_link_node(%struct.io_kiocb* nocapture noundef %req, i32 noundef %res) unnamed_addr #12 {
entry:
  call fastcc void @req_set_fail(%struct.io_kiocb* noundef %req) #25
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  store i32 %res, i32* %result, align 4
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_req_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %0 = load i8, i8* %opcode, align 8
  switch i8 %0, label %sw.epilog [
    i8 0, label %return
    i8 1, label %sw.bb1
    i8 4, label %sw.bb1
    i8 22, label %sw.bb1
    i8 2, label %sw.bb2
    i8 5, label %sw.bb2
    i8 23, label %sw.bb2
    i8 6, label %sw.bb4
    i8 7, label %sw.bb6
    i8 3, label %sw.bb8
    i8 8, label %sw.bb10
    i8 9, label %sw.bb12
    i8 26, label %sw.bb12
    i8 10, label %sw.bb14
    i8 27, label %sw.bb14
    i8 16, label %sw.bb16
    i8 11, label %sw.bb18
    i8 12, label %sw.bb20
    i8 14, label %sw.bb22
    i8 15, label %sw.bb24
    i8 13, label %sw.bb26
    i8 17, label %sw.bb28
    i8 18, label %sw.bb30
    i8 19, label %sw.bb32
    i8 20, label %sw.bb34
    i8 21, label %sw.bb36
    i8 24, label %sw.bb38
    i8 25, label %sw.bb40
    i8 28, label %sw.bb42
    i8 29, label %sw.bb44
    i8 30, label %sw.bb46
    i8 31, label %sw.bb48
    i8 32, label %sw.bb50
    i8 33, label %sw.bb52
    i8 34, label %sw.bb54
    i8 35, label %sw.bb56
    i8 36, label %sw.bb58
    i8 37, label %sw.bb60
    i8 38, label %sw.bb62
    i8 39, label %sw.bb64
  ]

sw.bb1:                                           ; preds = %entry, %entry, %entry
  %call = call fastcc i32 @io_read_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb2:                                           ; preds = %entry, %entry, %entry
  %call3 = call fastcc i32 @io_write_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb4:                                           ; preds = %entry
  %call5 = call fastcc i32 @io_poll_add_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb6:                                           ; preds = %entry
  %call7 = call fastcc i32 @io_poll_update_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb8:                                           ; preds = %entry
  %call9 = call fastcc i32 @io_fsync_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb10:                                          ; preds = %entry
  %call11 = call fastcc i32 @io_sfr_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb12:                                          ; preds = %entry, %entry
  br label %return

sw.bb14:                                          ; preds = %entry, %entry
  br label %return

sw.bb16:                                          ; preds = %entry
  br label %return

sw.bb18:                                          ; preds = %entry
  %call19 = call fastcc i32 @io_timeout_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i1 noundef false) #25
  br label %return

sw.bb20:                                          ; preds = %entry
  %call21 = call fastcc i32 @io_timeout_remove_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb22:                                          ; preds = %entry
  %call23 = call fastcc i32 @io_async_cancel_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb24:                                          ; preds = %entry
  %call25 = call fastcc i32 @io_timeout_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i1 noundef true) #25
  br label %return

sw.bb26:                                          ; preds = %entry
  br label %return

sw.bb28:                                          ; preds = %entry
  %call29 = call fastcc i32 @io_fallocate_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb30:                                          ; preds = %entry
  %call31 = call fastcc i32 @io_openat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb32:                                          ; preds = %entry
  %call33 = call fastcc i32 @io_close_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb34:                                          ; preds = %entry
  %call35 = call fastcc i32 @io_rsrc_update_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb36:                                          ; preds = %entry
  %call37 = call fastcc i32 @io_statx_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb38:                                          ; preds = %entry
  %call39 = call fastcc i32 @io_fadvise_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb40:                                          ; preds = %entry
  %call41 = call fastcc i32 @io_madvise_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb42:                                          ; preds = %entry
  %call43 = call fastcc i32 @io_openat2_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb44:                                          ; preds = %entry
  %call45 = call fastcc i32 @io_epoll_ctl_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb46:                                          ; preds = %entry
  %call47 = call fastcc i32 @io_splice_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb48:                                          ; preds = %entry
  %call49 = call fastcc i32 @io_provide_buffers_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb50:                                          ; preds = %entry
  %call51 = call fastcc i32 @io_remove_buffers_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb52:                                          ; preds = %entry
  %call53 = call fastcc i32 @io_tee_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb54:                                          ; preds = %entry
  br label %return

sw.bb56:                                          ; preds = %entry
  %call57 = call fastcc i32 @io_renameat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb58:                                          ; preds = %entry
  %call59 = call fastcc i32 @io_unlinkat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb60:                                          ; preds = %entry
  %call61 = call fastcc i32 @io_mkdirat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb62:                                          ; preds = %entry
  %call63 = call fastcc i32 @io_symlinkat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.bb64:                                          ; preds = %entry
  %call65 = call fastcc i32 @io_linkat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

sw.epilog:                                        ; preds = %entry
  %.b150 = load i1, i1* @io_req_prep.__already_done, align 1
  br i1 %.b150, label %return, label %if.then, !prof !8

if.then:                                          ; preds = %sw.epilog
  store i1 true, i1* @io_req_prep.__already_done, align 1
  %conv73 = zext i8 %0 to i32
  %call74 = call i32 (i8*, ...) @_printk(i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.26, i64 0, i64 0), i32 noundef %conv73) #30
  br label %return

return:                                           ; preds = %sw.epilog, %if.then, %entry, %sw.bb64, %sw.bb62, %sw.bb60, %sw.bb58, %sw.bb56, %sw.bb54, %sw.bb52, %sw.bb50, %sw.bb48, %sw.bb46, %sw.bb44, %sw.bb42, %sw.bb40, %sw.bb38, %sw.bb36, %sw.bb34, %sw.bb32, %sw.bb30, %sw.bb28, %sw.bb26, %sw.bb24, %sw.bb22, %sw.bb20, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb12, %sw.bb10, %sw.bb8, %sw.bb6, %sw.bb4, %sw.bb2, %sw.bb1
  %retval.0 = phi i32 [ %call65, %sw.bb64 ], [ %call63, %sw.bb62 ], [ %call61, %sw.bb60 ], [ %call59, %sw.bb58 ], [ %call57, %sw.bb56 ], [ -95, %sw.bb54 ], [ %call53, %sw.bb52 ], [ %call51, %sw.bb50 ], [ %call49, %sw.bb48 ], [ %call47, %sw.bb46 ], [ %call45, %sw.bb44 ], [ %call43, %sw.bb42 ], [ %call41, %sw.bb40 ], [ %call39, %sw.bb38 ], [ %call37, %sw.bb36 ], [ %call35, %sw.bb34 ], [ %call33, %sw.bb32 ], [ %call31, %sw.bb30 ], [ %call29, %sw.bb28 ], [ -95, %sw.bb26 ], [ %call25, %sw.bb24 ], [ %call23, %sw.bb22 ], [ %call21, %sw.bb20 ], [ %call19, %sw.bb18 ], [ -95, %sw.bb16 ], [ -95, %sw.bb14 ], [ -95, %sw.bb12 ], [ %call11, %sw.bb10 ], [ %call9, %sw.bb8 ], [ %call7, %sw.bb6 ], [ %call5, %sw.bb4 ], [ %call3, %sw.bb2 ], [ %call, %sw.bb1 ], [ 0, %entry ], [ -22, %if.then ], [ -22, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_queue_sqe(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %drain_active = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %drain_active, align 4
  %1 = and i8 %bf.load, 32
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true, !prof !8

land.lhs.true:                                    ; preds = %entry
  %call = call fastcc i1 @io_drain_req(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %if.end34, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 272
  %tobool4.not = icmp eq i32 %and, 0
  br i1 %tobool4.not, label %if.then14, label %if.else, !prof !8

if.then14:                                        ; preds = %if.end
  call fastcc void @__io_queue_sqe(%struct.io_kiocb* noundef %req) #25
  br label %if.end34

if.else:                                          ; preds = %if.end
  %and16 = and i32 %2, 256
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %if.else19, label %if.then18

if.then18:                                        ; preds = %if.else
  call fastcc void @io_req_complete_fail_submit(%struct.io_kiocb* noundef %req) #25
  br label %if.end34

if.else19:                                        ; preds = %if.else
  %call20 = call fastcc i32 @io_req_prep_async(%struct.io_kiocb* noundef %req) #25
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.else31, label %if.then29, !prof !8

if.then29:                                        ; preds = %if.else19
  %conv30 = sext i32 %call20 to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv30) #25
  br label %if.end34

if.else31:                                        ; preds = %if.else19
  call void @io_queue_async_work(%struct.io_kiocb* noundef %req, i8* noundef null) #25
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %if.else31, %if.then18, %land.lhs.true, %if.then14
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @io_check_restriction(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* nocapture noundef readonly %req, i32 noundef %sqe_flags) unnamed_addr #8 {
entry:
  %restricted = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %restricted, align 4
  %0 = and i8 %bf.load, 8
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !8

if.end:                                           ; preds = %entry
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %1 = load i8, i8* %opcode, align 8
  %conv4 = zext i8 %1 to i32
  %div.i = lshr i32 %conv4, 6
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 1, i64 %idxprom.i
  %2 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i32 %conv4, 63
  %sh_prom.i = zext i32 %and.i to i64
  %3 = shl nuw i64 1, %sh_prom.i
  %4 = and i64 %3, %2
  %tobool5.not = icmp eq i64 %4, 0
  br i1 %tobool5.not, label %return, label %if.end7

if.end7:                                          ; preds = %if.end
  %sqe_flags_required = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 3
  %5 = load i8, i8* %sqe_flags_required, align 1
  %conv9 = zext i8 %5 to i32
  %and = and i32 %conv9, %sqe_flags
  %cmp.not = icmp eq i32 %and, %conv9
  br i1 %cmp.not, label %if.end15, label %return

if.end15:                                         ; preds = %if.end7
  %sqe_flags_allowed = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 2
  %6 = load i8, i8* %sqe_flags_allowed, align 16
  %or31 = or i8 %6, %5
  %or = zext i8 %or31 to i32
  %neg = xor i32 %or, -1
  %and21 = and i32 %neg, %sqe_flags
  %tobool22.not = icmp eq i32 %and21, 0
  br label %return

return:                                           ; preds = %if.end15, %if.end7, %if.end, %entry
  %retval.0 = phi i1 [ true, %entry ], [ false, %if.end ], [ false, %if.end7 ], [ %tobool22.not, %if.end15 ]
  ret i1 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @blk_start_plug(%struct.blk_plug* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.file* @io_file_get(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.io_kiocb* nocapture noundef %req, i32 noundef %fd, i1 noundef %fixed) unnamed_addr #1 {
entry:
  br i1 %fixed, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call fastcc %struct.file* @io_file_get_fixed(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, i32 noundef %fd) #25
  br label %return

if.else:                                          ; preds = %entry
  %call1 = call fastcc %struct.file* @io_file_get_normal(%struct.io_ring_ctx* noundef %ctx, %struct.io_kiocb* noundef %req, i32 noundef %fd) #25
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi %struct.file* [ %call, %if.then ], [ %call1, %if.else ]
  ret %struct.file* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.file* @io_file_get_fixed(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.io_kiocb* nocapture noundef %req, i32 noundef %fd) unnamed_addr #1 {
entry:
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 8
  %0 = load i32, i32* %nr_user_files, align 8
  %cmp.not = icmp ugt i32 %0, %fd
  br i1 %cmp.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %conv3 = sext i32 %fd to i64
  %conv4 = zext i32 %0 to i64
  %call = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv3, i64 noundef %conv4) #25
  %1 = trunc i64 %call to i32
  %conv9 = and i32 %1, %fd
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 7
  %call10 = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %conv9) #25
  %file_ptr11 = getelementptr inbounds %struct.io_fixed_file, %struct.io_fixed_file* %call10, i64 0, i32 0
  %2 = load i64, i64* %file_ptr11, align 8
  %and12 = and i64 %2, -8
  %3 = inttoptr i64 %and12 to %struct.file*
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %4 = load i32, i32* %flags, align 8
  %.tr = trunc i64 %2 to i32
  %5 = shl i32 %.tr, 21
  %6 = and i32 %5, 14680064
  %conv15 = or i32 %6, %4
  store i32 %conv15, i32* %flags, align 8
  call fastcc void @io_req_set_rsrc_node(%struct.io_kiocb* noundef %req) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi %struct.file* [ %3, %if.end ], [ null, %entry ]
  ret %struct.file* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.file* @io_file_get_normal(%struct.io_ring_ctx* nocapture noundef readnone %ctx, %struct.io_kiocb* nocapture noundef %req, i32 noundef %fd) unnamed_addr #1 {
entry:
  %call = call %struct.file* @fget(i32 noundef %fd) #27
  %tobool.not = icmp eq %struct.file* %call, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %f_op = getelementptr inbounds %struct.file, %struct.file* %call, i64 0, i32 3
  %0 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp = icmp eq %struct.file_operations* %0, @io_uring_fops
  br i1 %cmp, label %if.then, label %if.end, !prof !24

if.then:                                          ; preds = %land.lhs.true
  call fastcc void @io_req_track_inflight(%struct.io_kiocb* noundef %req) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret %struct.file* %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_set_rsrc_node(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %fixed_rsrc_refs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 12
  %0 = load %struct.percpu_ref*, %struct.percpu_ref** %fixed_rsrc_refs, align 8
  %tobool.not = icmp eq %struct.percpu_ref* %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %rsrc_node = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 1, i32 6
  %2 = load %struct.io_rsrc_node*, %struct.io_rsrc_node** %rsrc_node, align 8
  %refs = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %2, i64 0, i32 0
  store %struct.percpu_ref* %refs, %struct.percpu_ref** %fixed_rsrc_refs, align 8
  call fastcc void @percpu_ref_get(%struct.percpu_ref* noundef %refs) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_track_inflight(%struct.io_kiocb* nocapture noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 512
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %or = or i32 %0, 512
  store i32 %or, i32* %flags, align 8
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i64 0, i32 85
  %3 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %inflight_tracked = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %3, i64 0, i32 6
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %inflight_tracked) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_read_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 8
  %1 = load i32, i32* %f_mode, align 4
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %call = call fastcc i32 @io_prep_rw(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i32 noundef 0) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -9, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_write_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 8
  %1 = load i32, i32* %f_mode, align 4
  %and = and i32 %1, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end, !prof !24

if.end:                                           ; preds = %entry
  %call = call fastcc i32 @io_prep_rw(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i32 noundef 1) #25
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -9, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nofree noinline norecurse nounwind null_pointer_is_valid
define internal fastcc i32 @io_poll_add_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #9 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags2 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags2, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool6.not = icmp eq i16 %2, 0
  br i1 %tobool6.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %3 = load i16, i16* %buf_index, align 8
  %tobool8.not = icmp eq i16 %3, 0
  br i1 %tobool8.not, label %lor.lhs.false9, label %cleanup

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %4 = load i64, i64* %off, align 8
  %tobool10.not = icmp eq i64 %4, 0
  br i1 %tobool10.not, label %lor.lhs.false11, label %cleanup

lor.lhs.false11:                                  ; preds = %lor.lhs.false9
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %5 = load i64, i64* %addr, align 8
  %tobool12.not = icmp eq i64 %5, 0
  br i1 %tobool12.not, label %do.end, label %cleanup

do.end:                                           ; preds = %lor.lhs.false11
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %6 = load volatile i32, i32* %len, align 8
  %tobool16.not = icmp ult i32 %6, 2
  br i1 %tobool16.not, label %if.end18, label %cleanup

if.end18:                                         ; preds = %do.end
  call fastcc void @io_req_set_refcount(%struct.io_kiocb* noundef %req) #25
  %call = call fastcc i32 @io_poll_parse_events(%struct.io_uring_sqe* noundef %sqe, i32 noundef %6) #25
  %events = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %7 = bitcast void (%struct.kiocb*, i64, i64)** %events to i32*
  store i32 %call, i32* %7, align 8
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end, %lor.lhs.false, %lor.lhs.false9, %lor.lhs.false11, %entry, %if.end18
  %retval.0 = phi i32 [ 0, %if.end18 ], [ -22, %entry ], [ -22, %lor.lhs.false11 ], [ -22, %lor.lhs.false9 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_poll_update_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %poll_update = bitcast %struct.io_kiocb* %req to %struct.io_poll_update*
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags1, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool5.not = icmp eq i16 %2, 0
  br i1 %tobool5.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %3 = load i16, i16* %buf_index, align 8
  %tobool7.not = icmp eq i16 %3, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %4 = load i32, i32* %splice_fd_in, align 4
  %tobool9.not = icmp eq i32 %4, 0
  br i1 %tobool9.not, label %do.end, label %cleanup

do.end:                                           ; preds = %lor.lhs.false8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load volatile i32, i32* %len, align 8
  %tobool13.not = icmp ugt i32 %5, 7
  %cmp = icmp eq i32 %5, 1
  %or.cond67 = or i1 %tobool13.not, %cmp
  br i1 %or.cond67, label %cleanup, label %do.end21

do.end21:                                         ; preds = %do.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %6 = load volatile i64, i64* %addr, align 8
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %6, i64* %7, align 8
  %update_events = getelementptr inbounds %struct.io_poll_update, %struct.io_poll_update* %poll_update, i64 0, i32 4
  %8 = trunc i32 %5 to i8
  %9 = lshr i8 %8, 1
  %10 = and i8 %9, 1
  store i8 %10, i8* %update_events, align 4
  %update_user_data = getelementptr inbounds %struct.io_poll_update, %struct.io_poll_update* %poll_update, i64 0, i32 5
  %11 = lshr i8 %8, 2
  store i8 %11, i8* %update_user_data, align 1
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %12 = load volatile i64, i64* %off, align 8
  %new_user_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %new_user_data to i64*
  store i64 %12, i64* %13, align 8
  %14 = and i8 %8, 4
  %tobool33.not = icmp ne i8 %14, 0
  %tobool35.not = icmp eq i64 %12, 0
  %or.cond = select i1 %tobool33.not, i1 true, i1 %tobool35.not
  br i1 %or.cond, label %if.end37, label %cleanup

if.end37:                                         ; preds = %do.end21
  %tobool39.not = icmp eq i8 %10, 0
  br i1 %tobool39.not, label %if.else, label %if.then40

if.then40:                                        ; preds = %if.end37
  %call = call fastcc i32 @io_poll_parse_events(%struct.io_uring_sqe* noundef %sqe, i32 noundef %5) #25
  %events = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %15 = bitcast i8** %events to i32*
  store i32 %call, i32* %15, align 8
  br label %if.end44

if.else:                                          ; preds = %if.end37
  %poll32_events = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %16 = load i32, i32* %poll32_events, align 4
  %tobool41.not = icmp eq i32 %16, 0
  br i1 %tobool41.not, label %if.end44, label %cleanup

if.end44:                                         ; preds = %if.else, %if.then40
  br label %cleanup

cleanup:                                          ; preds = %if.else, %do.end21, %do.end, %if.end, %lor.lhs.false, %lor.lhs.false8, %entry, %if.end44
  %retval.0 = phi i32 [ 0, %if.end44 ], [ -22, %entry ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %do.end ], [ -22, %do.end21 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_fsync_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %file = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %0 = load %struct.file*, %struct.file** %file, align 8
  %tobool.not = icmp eq %struct.file* %0, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 2
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 1
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %if.end6, label %cleanup, !prof !8

if.end6:                                          ; preds = %if.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %3 = load i64, i64* %addr, align 8
  %tobool7.not = icmp eq i64 %3, 0
  br i1 %tobool7.not, label %lor.lhs.false, label %cleanup, !prof !8

lor.lhs.false:                                    ; preds = %if.end6
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %4 = load i16, i16* %ioprio, align 2
  %tobool9.not = icmp eq i16 %4, 0
  br i1 %tobool9.not, label %lor.lhs.false10, label %cleanup, !prof !8

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %5 = load i16, i16* %buf_index, align 8
  %tobool12.not = icmp eq i16 %5, 0
  br i1 %tobool12.not, label %lor.rhs, label %cleanup, !prof !8

lor.rhs:                                          ; preds = %lor.lhs.false10
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool13.not = icmp eq i32 %6, 0
  br i1 %tobool13.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %lor.rhs
  %fsync_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %7 = load volatile i32, i32* %fsync_flags, align 4
  %flags23 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %8 = bitcast i8** %flags23 to i32*
  store i32 %7, i32* %8, align 8
  %tobool27.not = icmp ult i32 %7, 2
  br i1 %tobool27.not, label %do.end39, label %cleanup, !prof !8

do.end39:                                         ; preds = %do.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %9 = load volatile i64, i64* %off, align 8
  %off42 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %10 = bitcast void (%struct.kiocb*, i64, i64)** %off42 to i64*
  store i64 %9, i64* %10, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %11 = load volatile i32, i32* %len, align 8
  %conv47 = zext i32 %11 to i64
  %12 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %conv47, i64* %12, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %lor.lhs.false, %lor.lhs.false10, %do.end, %lor.rhs, %if.end, %entry, %do.end39
  %retval.0 = phi i32 [ 0, %do.end39 ], [ -9, %entry ], [ -22, %if.end ], [ -22, %lor.rhs ], [ -22, %do.end ], [ -22, %lor.lhs.false10 ], [ -22, %lor.lhs.false ], [ -22, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_sfr_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %2 = load i64, i64* %addr, align 8
  %tobool4.not = icmp eq i64 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup, !prof !8

lor.lhs.false:                                    ; preds = %if.end
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %3 = load i16, i16* %ioprio, align 2
  %tobool6.not = icmp eq i16 %3, 0
  br i1 %tobool6.not, label %lor.lhs.false7, label %cleanup, !prof !8

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %4 = load i16, i16* %buf_index, align 8
  %tobool9.not = icmp eq i16 %4, 0
  br i1 %tobool9.not, label %lor.rhs, label %cleanup, !prof !8

lor.rhs:                                          ; preds = %lor.lhs.false7
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %5 = load i32, i32* %splice_fd_in, align 4
  %tobool10.not = icmp eq i32 %5, 0
  br i1 %tobool10.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %lor.rhs
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %6 = load volatile i64, i64* %off, align 8
  %off20 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %7 = bitcast void (%struct.kiocb*, i64, i64)** %off20 to i64*
  store i64 %6, i64* %7, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %8 = load volatile i32, i32* %len, align 8
  %conv25 = zext i32 %8 to i64
  %9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %conv25, i64* %9, align 8
  %sync_range_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %10 = load volatile i32, i32* %sync_range_flags, align 4
  %flags33 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %11 = bitcast i8** %flags33 to i32*
  store i32 %10, i32* %11, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %lor.lhs.false7, %lor.rhs, %entry, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %entry ], [ -22, %lor.rhs ], [ -22, %lor.lhs.false7 ], [ -22, %lor.lhs.false ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_timeout_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i1 noundef %is_timeout_link) unnamed_addr #1 {
entry:
  %off1 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %0 = load volatile i64, i64* %off1, align 8
  %conv = trunc i64 %0 to i32
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags2 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 2
  %2 = load i32, i32* %flags2, align 8
  %and = and i32 %2, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup410, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %3 = load i16, i16* %ioprio, align 2
  %tobool7.not = icmp eq i16 %3, 0
  br i1 %tobool7.not, label %lor.lhs.false, label %cleanup410

lor.lhs.false:                                    ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %4 = load i16, i16* %buf_index, align 8
  %tobool9.not = icmp eq i16 %4, 0
  br i1 %tobool9.not, label %lor.lhs.false10, label %cleanup410

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load i32, i32* %len, align 8
  %cmp.not = icmp eq i32 %5, 1
  br i1 %cmp.not, label %lor.lhs.false12, label %cleanup410

lor.lhs.false12:                                  ; preds = %lor.lhs.false10
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool13.not = icmp eq i32 %6, 0
  br i1 %tobool13.not, label %if.end15, label %cleanup410

if.end15:                                         ; preds = %lor.lhs.false12
  %tobool16.not = icmp eq i32 %conv, 0
  %is_timeout_link.not = xor i1 %is_timeout_link, true
  %brmerge = or i1 %tobool16.not, %is_timeout_link.not
  br i1 %brmerge, label %do.end23, label %cleanup410

do.end23:                                         ; preds = %if.end15
  %timeout_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %7 = load volatile i32, i32* %timeout_flags, align 4
  %and25 = and i32 %7, -14
  %tobool26.not = icmp eq i32 %and25, 0
  br i1 %tobool26.not, label %cond.false, label %cleanup410

cond.false:                                       ; preds = %do.end23
  %and29 = and i32 %7, 12
  %call = call fastcc i32 @__arch_hweight32(i32 noundef %and29) #25
  %cmp348 = icmp ugt i32 %call, 1
  br i1 %cmp348, label %cleanup410, label %if.end351

if.end351:                                        ; preds = %cond.false
  %list = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %8 = bitcast void (%struct.kiocb*, i64, i64)** %list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %8) #25
  %off353 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %9 = bitcast i64* %off353 to i32*
  store i32 %conv, i32* %9, align 8
  br i1 %tobool16.not, label %if.end371, label %land.rhs

land.rhs:                                         ; preds = %if.end351
  %10 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %off_timeout_used = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %10, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %off_timeout_used, align 4
  %11 = and i8 %bf.load, 16
  %tobool356.not = icmp eq i8 %11, 0
  br i1 %tobool356.not, label %if.then366, label %if.end371, !prof !24

if.then366:                                       ; preds = %land.rhs
  %bf.set = or i8 %bf.load, 16
  store i8 %bf.set, i8* %off_timeout_used, align 4
  br label %if.end371

if.end371:                                        ; preds = %if.end351, %if.then366, %land.rhs
  %async_data = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 1
  %12 = load i8*, i8** %async_data, align 8
  %tobool372.not = icmp eq i8* %12, null
  br i1 %tobool372.not, label %land.lhs.true373, label %if.end371.if.end377_crit_edge

if.end371.if.end377_crit_edge:                    ; preds = %if.end371
  %13 = bitcast i8* %12 to %struct.io_timeout_data*
  br label %if.end377

land.lhs.true373:                                 ; preds = %if.end371
  %call374 = call fastcc i32 @io_alloc_async_data(%struct.io_kiocb* noundef %req) #25
  %tobool375.not = icmp eq i32 %call374, 0
  br i1 %tobool375.not, label %land.lhs.true373.if.end377_crit_edge, label %cleanup410

land.lhs.true373.if.end377_crit_edge:             ; preds = %land.lhs.true373
  %.phi.trans.insert = bitcast i8** %async_data to %struct.io_timeout_data**
  %.pre = load %struct.io_timeout_data*, %struct.io_timeout_data** %.phi.trans.insert, align 8
  br label %if.end377

if.end377:                                        ; preds = %if.end371.if.end377_crit_edge, %land.lhs.true373.if.end377_crit_edge
  %14 = phi %struct.io_timeout_data* [ %.pre, %land.lhs.true373.if.end377_crit_edge ], [ %13, %if.end371.if.end377_crit_edge ]
  %req379 = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %14, i64 0, i32 0
  store %struct.io_kiocb* %req, %struct.io_kiocb** %req379, align 8
  %flags380 = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %14, i64 0, i32 4
  store i32 %7, i32* %flags380, align 4
  %ts = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %14, i64 0, i32 2
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %15 = load i64, i64* %addr, align 8
  %16 = inttoptr i64 %15 to %struct.__kernel_timespec*
  %call385 = call i32 @get_timespec64(%struct.timespec64* noundef %ts, %struct.__kernel_timespec* noundef %16) #27
  %tobool386.not = icmp eq i32 %call385, 0
  br i1 %tobool386.not, label %if.end388, label %cleanup410

if.end388:                                        ; preds = %if.end377
  %call389 = call fastcc i32 @io_translate_timeout_mode(i32 noundef %7) #25
  %mode = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %14, i64 0, i32 3
  store i32 %call389, i32* %mode, align 8
  %timer = getelementptr inbounds %struct.io_timeout_data, %struct.io_timeout_data* %14, i64 0, i32 1
  %call390 = call fastcc i32 @io_timeout_get_clock(%struct.io_timeout_data* noundef %14) #25, !range !97
  %17 = load i32, i32* %mode, align 8
  call void @hrtimer_init(%struct.hrtimer* noundef %timer, i32 noundef %call390, i32 noundef %17) #27
  br i1 %is_timeout_link, label %if.then393, label %cleanup410

if.then393:                                       ; preds = %if.end388
  %18 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %18, i64 0, i32 1, i32 11, i32 1, i32 0
  %19 = load %struct.io_kiocb*, %struct.io_kiocb** %head, align 8
  %tobool396.not = icmp eq %struct.io_kiocb* %19, null
  br i1 %tobool396.not, label %cleanup410, label %if.end398

if.end398:                                        ; preds = %if.then393
  %last = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %18, i64 0, i32 1, i32 11, i32 1, i32 1
  %20 = load %struct.io_kiocb*, %struct.io_kiocb** %last, align 8
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %20, i64 0, i32 2
  %21 = load i8, i8* %opcode, align 8
  %cmp400 = icmp eq i8 %21, 15
  br i1 %cmp400, label %cleanup410, label %if.end403

if.end403:                                        ; preds = %if.end398
  %head406 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %22 = bitcast i32* %head406 to %struct.io_kiocb**
  store %struct.io_kiocb* %20, %struct.io_kiocb** %22, align 8
  %23 = load %struct.io_kiocb*, %struct.io_kiocb** %last, align 8
  %flags408 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %23, i64 0, i32 7
  %24 = load i32, i32* %flags408, align 8
  %or = or i32 %24, 1048576
  store i32 %or, i32* %flags408, align 8
  br label %cleanup410

cleanup410:                                       ; preds = %if.end388, %if.end403, %if.then393, %if.end398, %if.end377, %land.lhs.true373, %cond.false, %do.end23, %if.end15, %if.end, %lor.lhs.false, %lor.lhs.false10, %lor.lhs.false12, %entry
  %retval.1 = phi i32 [ -22, %entry ], [ -22, %lor.lhs.false12 ], [ -22, %lor.lhs.false10 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %if.end15 ], [ -22, %do.end23 ], [ -22, %cond.false ], [ -12, %land.lhs.true373 ], [ -14, %if.end377 ], [ -22, %if.end398 ], [ -22, %if.then393 ], [ 0, %if.end403 ], [ 0, %if.end388 ]
  ret i32 %retval.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_timeout_remove_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %flags3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags3, align 8
  %and4 = and i32 %2, 33
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end14, label %cleanup, !prof !8

if.end14:                                         ; preds = %if.end
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %3 = load i16, i16* %ioprio, align 2
  %tobool16.not = icmp eq i16 %3, 0
  br i1 %tobool16.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end14
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %4 = load i16, i16* %buf_index, align 8
  %tobool18.not = icmp eq i16 %4, 0
  br i1 %tobool18.not, label %lor.lhs.false19, label %cleanup

lor.lhs.false19:                                  ; preds = %lor.lhs.false
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load i32, i32* %len, align 8
  %tobool20.not = icmp eq i32 %5, 0
  br i1 %tobool20.not, label %lor.lhs.false21, label %cleanup

lor.lhs.false21:                                  ; preds = %lor.lhs.false19
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool22.not = icmp eq i32 %6, 0
  br i1 %tobool22.not, label %if.end24, label %cleanup

if.end24:                                         ; preds = %lor.lhs.false21
  %ltimeout = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 5
  %7 = bitcast i16* %ltimeout to i8*
  store i8 0, i8* %7, align 4
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %8 = load volatile i64, i64* %addr, align 8
  %9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %8, i64* %9, align 8
  %timeout_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %10 = load volatile i32, i32* %timeout_flags, align 4
  %11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  store i32 %10, i32* %11, align 8
  %and32 = and i32 %10, 18
  %tobool33.not = icmp eq i32 %and32, 0
  br i1 %tobool33.not, label %if.else, label %cond.false

cond.false:                                       ; preds = %if.end24
  %and36 = and i32 %10, 12
  %call = call fastcc i32 @__arch_hweight32(i32 noundef %and36) #25
  %cmp = icmp ugt i32 %call, 1
  br i1 %cmp, label %cleanup, label %if.end390

if.end390:                                        ; preds = %cond.false
  %12 = load i32, i32* %11, align 8
  %and392 = and i32 %12, 16
  %tobool393.not = icmp eq i32 %and392, 0
  br i1 %tobool393.not, label %if.end396, label %if.then394

if.then394:                                       ; preds = %if.end390
  store i8 1, i8* %7, align 4
  br label %if.end396

if.end396:                                        ; preds = %if.then394, %if.end390
  %and398 = and i32 %12, -20
  %tobool399.not = icmp eq i32 %and398, 0
  br i1 %tobool399.not, label %if.end401, label %cleanup

if.end401:                                        ; preds = %if.end396
  %ts = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %ts to %struct.timespec64*
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %14 = load i64, i64* %addr2, align 8
  %15 = inttoptr i64 %14 to %struct.__kernel_timespec*
  %call406 = call i32 @get_timespec64(%struct.timespec64* noundef %13, %struct.__kernel_timespec* noundef %15) #27
  %tobool407.not = icmp eq i32 %call406, 0
  br i1 %tobool407.not, label %if.end414, label %cleanup

if.else:                                          ; preds = %if.end24
  %tobool411.not = icmp eq i32 %10, 0
  br i1 %tobool411.not, label %if.end414, label %cleanup

if.end414:                                        ; preds = %if.else, %if.end401
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.end401, %if.end396, %cond.false, %if.end14, %lor.lhs.false, %lor.lhs.false19, %lor.lhs.false21, %if.end, %entry, %if.end414
  %retval.0 = phi i32 [ 0, %if.end414 ], [ -22, %entry ], [ -22, %if.end ], [ -22, %lor.lhs.false21 ], [ -22, %lor.lhs.false19 ], [ -22, %lor.lhs.false ], [ -22, %if.end14 ], [ -22, %cond.false ], [ -22, %if.end396 ], [ -14, %if.end401 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_async_cancel_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %return, !prof !8

if.end:                                           ; preds = %entry
  %flags3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %2 = load i32, i32* %flags3, align 8
  %and4 = and i32 %2, 33
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end14, label %return, !prof !8

if.end14:                                         ; preds = %if.end
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %3 = load i16, i16* %ioprio, align 2
  %tobool16.not = icmp eq i16 %3, 0
  br i1 %tobool16.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end14
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %4 = load i64, i64* %off, align 8
  %tobool17.not = icmp eq i64 %4, 0
  br i1 %tobool17.not, label %lor.lhs.false18, label %return

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load i32, i32* %len, align 8
  %tobool19.not = icmp eq i32 %5, 0
  br i1 %tobool19.not, label %lor.lhs.false20, label %return

lor.lhs.false20:                                  ; preds = %lor.lhs.false18
  %cancel_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %6 = load i32, i32* %cancel_flags, align 4
  %tobool21.not = icmp eq i32 %6, 0
  br i1 %tobool21.not, label %lor.lhs.false22, label %return

lor.lhs.false22:                                  ; preds = %lor.lhs.false20
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %7 = load i32, i32* %splice_fd_in, align 4
  %tobool23.not = icmp eq i32 %7, 0
  br i1 %tobool23.not, label %do.end, label %return

do.end:                                           ; preds = %lor.lhs.false22
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %8 = load volatile i64, i64* %addr, align 8
  %9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %8, i64* %9, align 8
  br label %return

return:                                           ; preds = %if.end14, %lor.lhs.false, %lor.lhs.false18, %lor.lhs.false20, %lor.lhs.false22, %if.end, %entry, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %entry ], [ -22, %if.end ], [ -22, %lor.lhs.false22 ], [ -22, %lor.lhs.false20 ], [ -22, %lor.lhs.false18 ], [ -22, %lor.lhs.false ], [ -22, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_fallocate_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %1 = load i16, i16* %buf_index, align 8
  %tobool2.not = icmp eq i16 %1, 0
  br i1 %tobool2.not, label %lor.lhs.false3, label %return

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %2 = load i32, i32* %rw_flags, align 4
  %tobool4.not = icmp eq i32 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false5, label %return

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %3 = load i32, i32* %splice_fd_in, align 4
  %tobool6.not = icmp eq i32 %3, 0
  br i1 %tobool6.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false5
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %4 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %4, i64 0, i32 0, i32 2
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 1
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %do.end, label %return, !prof !8

do.end:                                           ; preds = %if.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %6 = load volatile i64, i64* %off, align 8
  %sync = bitcast %struct.io_kiocb* %req to %struct.io_sync*
  %off13 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %7 = bitcast void (%struct.kiocb*, i64, i64)** %off13 to i64*
  store i64 %6, i64* %7, align 8
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %8 = load volatile i64, i64* %addr, align 8
  %9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %8, i64* %9, align 8
  %len21 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %10 = load volatile i32, i32* %len21, align 8
  %mode = getelementptr inbounds %struct.io_sync, %struct.io_sync* %sync, i64 0, i32 4
  store i32 %10, i32* %mode, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false, %lor.lhs.false3, %lor.lhs.false5, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %lor.lhs.false5 ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_openat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %tmp6 = alloca %struct.open_how, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %0 = load volatile i32, i32* %len, align 8
  %open_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %1 = load volatile i32, i32* %open_flags, align 4
  %how = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %2 = bitcast %struct.open_how* %tmp6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %2) #26
  %conv8 = trunc i32 %0 to i16
  call void @build_open_how(%struct.open_how* nonnull sret(%struct.open_how) align 8 %tmp6, i32 noundef %1, i16 noundef %conv8) #27
  %3 = bitcast i8** %how to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef align 8 dereferenceable(24) %3, i8* noundef nonnull align 8 dereferenceable(24) %2, i64 24, i1 false)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %2) #26
  %call = call fastcc i32 @__io_openat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  ret i32 %call
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_close_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %return, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %3 = load i64, i64* %off, align 8
  %tobool5.not = icmp eq i64 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %return

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %4 = load i64, i64* %addr, align 8
  %tobool7.not = icmp eq i64 %4, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %return

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load i32, i32* %len, align 8
  %tobool9.not = icmp eq i32 %5, 0
  br i1 %tobool9.not, label %lor.lhs.false10, label %return

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %6 = load i32, i32* %rw_flags, align 4
  %tobool11.not = icmp eq i32 %6, 0
  br i1 %tobool11.not, label %lor.lhs.false12, label %return

lor.lhs.false12:                                  ; preds = %lor.lhs.false10
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %7 = load i16, i16* %buf_index, align 8
  %tobool14.not = icmp eq i16 %7, 0
  br i1 %tobool14.not, label %if.end16, label %return

if.end16:                                         ; preds = %lor.lhs.false12
  %flags17 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %8 = load i32, i32* %flags17, align 8
  %and18 = and i32 %8, 1
  %tobool19.not = icmp eq i32 %and18, 0
  br i1 %tobool19.not, label %do.end, label %return

do.end:                                           ; preds = %if.end16
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %9 = load volatile i32, i32* %fd, align 4
  %close = bitcast %struct.io_kiocb* %req to %struct.io_close*
  %fd22 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %10 = bitcast i64* %fd22 to i32*
  store i32 %9, i32* %10, align 8
  %file_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %11 = load volatile i32, i32* %file_index, align 4
  %file_slot = getelementptr inbounds %struct.io_close, %struct.io_close* %close, i64 0, i32 2
  store i32 %11, i32* %file_slot, align 4
  %tobool29.not = icmp eq i32 %11, 0
  %tobool32.not = icmp eq i32 %9, 0
  %or.cond = select i1 %tobool29.not, i1 true, i1 %tobool32.not
  %spec.select = select i1 %or.cond, i32 0, i32 -22
  br label %return

return:                                           ; preds = %do.end, %if.end16, %if.end, %lor.lhs.false, %lor.lhs.false6, %lor.lhs.false8, %lor.lhs.false10, %lor.lhs.false12, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %lor.lhs.false12 ], [ -22, %lor.lhs.false10 ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end16 ], [ %spec.select, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_rsrc_update_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 33
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %return, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %1 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %1, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %2 = load i32, i32* %rw_flags, align 4
  %tobool5.not = icmp eq i32 %2, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %return

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %3 = load i32, i32* %splice_fd_in, align 4
  %tobool7.not = icmp eq i32 %3, 0
  br i1 %tobool7.not, label %do.end, label %return

do.end:                                           ; preds = %lor.lhs.false6
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %4 = load volatile i64, i64* %off, align 8
  %conv10 = trunc i64 %4 to i32
  %rsrc_update = bitcast %struct.io_kiocb* %req to %struct.io_rsrc_update*
  %offset = getelementptr inbounds %struct.io_rsrc_update, %struct.io_rsrc_update* %rsrc_update, i64 0, i32 3
  store i32 %conv10, i32* %offset, align 4
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %5 = load volatile i32, i32* %len, align 8
  %nr_args = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %6 = bitcast void (%struct.kiocb*, i64, i64)** %nr_args to i32*
  store i32 %5, i32* %6, align 8
  %tobool17.not = icmp eq i32 %5, 0
  br i1 %tobool17.not, label %return, label %do.end21

do.end21:                                         ; preds = %do.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %7 = load volatile i64, i64* %addr, align 8
  %8 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %7, i64* %8, align 8
  br label %return

return:                                           ; preds = %do.end, %if.end, %lor.lhs.false, %lor.lhs.false6, %entry, %do.end21
  %retval.0 = phi i32 [ 0, %do.end21 ], [ -22, %entry ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_statx_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %return, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %3 = load i16, i16* %buf_index, align 8
  %tobool6.not = icmp eq i16 %3, 0
  br i1 %tobool6.not, label %lor.lhs.false7, label %return

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %4 = load i32, i32* %splice_fd_in, align 4
  %tobool8.not = icmp eq i32 %4, 0
  br i1 %tobool8.not, label %if.end10, label %return

if.end10:                                         ; preds = %lor.lhs.false7
  %flags11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %5 = load i32, i32* %flags11, align 8
  %and12 = and i32 %5, 1
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %do.end, label %return

do.end:                                           ; preds = %if.end10
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %6 = load volatile i32, i32* %fd, align 4
  %statx = bitcast %struct.io_kiocb* %req to %struct.io_statx*
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %7 = bitcast i64* %dfd to i32*
  store i32 %6, i32* %7, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %8 = load volatile i32, i32* %len, align 8
  %mask = getelementptr inbounds %struct.io_statx, %struct.io_statx* %statx, i64 0, i32 2
  store i32 %8, i32* %mask, align 4
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %9 = load volatile i64, i64* %addr, align 8
  %10 = inttoptr i64 %9 to i8*
  %11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  store i8* %10, i8** %11, align 8
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %12 = load volatile i64, i64* %addr2, align 8
  %13 = inttoptr i64 %12 to %struct.statx*
  %buffer = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %14 = bitcast i32* %buffer to %struct.statx**
  store %struct.statx* %13, %struct.statx** %14, align 8
  %statx_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %15 = load volatile i32, i32* %statx_flags, align 4
  %flags41 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %16 = bitcast void (%struct.kiocb*, i64, i64)** %flags41 to i32*
  store i32 %15, i32* %16, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.end, %lor.lhs.false, %lor.lhs.false7, %entry, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %entry ], [ -22, %lor.lhs.false7 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_fadvise_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %1 = load i16, i16* %buf_index, align 8
  %tobool2.not = icmp eq i16 %1, 0
  br i1 %tobool2.not, label %lor.lhs.false3, label %return

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %2 = load i64, i64* %addr, align 8
  %tobool4.not = icmp eq i64 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false5, label %return

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %3 = load i32, i32* %splice_fd_in, align 4
  %tobool6.not = icmp eq i32 %3, 0
  br i1 %tobool6.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false5
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %4 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %4, i64 0, i32 0, i32 2
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 1
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %do.end, label %return, !prof !8

do.end:                                           ; preds = %if.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %6 = load volatile i64, i64* %off, align 8
  %fadvise = bitcast %struct.io_kiocb* %req to %struct.io_fadvise*
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %6, i64* %7, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %8 = load volatile i32, i32* %len, align 8
  %len17 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %9 = bitcast void (%struct.kiocb*, i64, i64)** %len17 to i32*
  store i32 %8, i32* %9, align 8
  %fadvise_advice = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %10 = load volatile i32, i32* %fadvise_advice, align 4
  %advice = getelementptr inbounds %struct.io_fadvise, %struct.io_fadvise* %fadvise, i64 0, i32 3
  store i32 %10, i32* %advice, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false, %lor.lhs.false3, %lor.lhs.false5, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %lor.lhs.false5 ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_madvise_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #8 {
entry:
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %1 = load i16, i16* %buf_index, align 8
  %tobool2.not = icmp eq i16 %1, 0
  br i1 %tobool2.not, label %lor.lhs.false3, label %return

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %2 = load i64, i64* %off, align 8
  %tobool4.not = icmp eq i64 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false5, label %return

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %3 = load i32, i32* %splice_fd_in, align 4
  %tobool6.not = icmp eq i32 %3, 0
  br i1 %tobool6.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false5
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %4 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %4, i64 0, i32 0, i32 2
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 1
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %do.end, label %return, !prof !8

do.end:                                           ; preds = %if.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %6 = load volatile i64, i64* %addr, align 8
  %madvise = bitcast %struct.io_kiocb* %req to %struct.io_madvise*
  %7 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %6, i64* %7, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %8 = load volatile i32, i32* %len, align 8
  %len18 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %9 = bitcast void (%struct.kiocb*, i64, i64)** %len18 to i32*
  store i32 %8, i32* %9, align 8
  %fadvise_advice = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %10 = load volatile i32, i32* %fadvise_advice, align 4
  %advice = getelementptr inbounds %struct.io_madvise, %struct.io_madvise* %madvise, i64 0, i32 3
  store i32 %10, i32* %advice, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false, %lor.lhs.false3, %lor.lhs.false5, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ -22, %lor.lhs.false5 ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_openat2_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %0 = load volatile i64, i64* %addr2, align 8
  %len7 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %1 = load volatile i32, i32* %len7, align 8
  %cmp9 = icmp ult i32 %1, 24
  br i1 %cmp9, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = inttoptr i64 %0 to i8*
  %how11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %3 = bitcast i8** %how11 to i8*
  %cmp.i.not = icmp eq i32 %1, 24
  br i1 %cmp.i.not, label %if.end19.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end
  %conv8 = zext i32 %1 to i64
  %sub.i = add nsw i64 %conv8, -24
  %add.ptr10.i = getelementptr i8, i8* %2, i64 24
  %call11.i = call i32 @check_zeroed_user(i8* noundef %add.ptr10.i, i64 noundef %sub.i) #27
  %cmp12.i = icmp slt i32 %call11.i, 1
  %tobool.not.i = icmp eq i32 %call11.i, 0
  %..i = select i1 %tobool.not.i, i32 -7, i32 %call11.i
  br i1 %cmp12.i, label %cleanup, label %if.end19.i

if.end19.i:                                       ; preds = %if.then9.i, %if.end
  %call2.i.i = call fastcc i64 @_copy_from_user(i8* noundef %3, i8* noundef %2, i64 noundef 24) #27
  %tobool21.not.i = icmp eq i64 %call2.i.i, 0
  br i1 %tobool21.not.i, label %if.end13, label %cleanup

if.end13:                                         ; preds = %if.end19.i
  %call14 = call fastcc i32 @__io_openat_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end19.i, %if.then9.i, %entry, %if.end13
  %retval.0 = phi i32 [ %call14, %if.end13 ], [ -22, %entry ], [ -14, %if.end19.i ], [ %..i, %if.then9.i ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_epoll_ctl_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %1 = load i16, i16* %buf_index, align 8
  %tobool2.not = icmp eq i16 %1, 0
  br i1 %tobool2.not, label %lor.lhs.false3, label %return

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %2 = load i32, i32* %splice_fd_in, align 4
  %tobool4.not = icmp eq i32 %2, 0
  br i1 %tobool4.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false3
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 0, i32 2
  %4 = load i32, i32* %flags, align 8
  %and = and i32 %4, 1
  %tobool5.not = icmp eq i32 %and, 0
  br i1 %tobool5.not, label %do.end, label %return, !prof !8

do.end:                                           ; preds = %if.end
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %5 = load volatile i32, i32* %fd, align 4
  %epoll = bitcast %struct.io_kiocb* %req to %struct.io_epoll*
  %epfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %6 = bitcast i64* %epfd to i32*
  store i32 %5, i32* %6, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %7 = load volatile i32, i32* %len, align 8
  %op = getelementptr inbounds %struct.io_epoll, %struct.io_epoll* %epoll, i64 0, i32 2
  store i32 %7, i32* %op, align 4
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %8 = load volatile i64, i64* %off, align 8
  %conv18 = trunc i64 %8 to i32
  %fd20 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %9 = bitcast void (%struct.kiocb*, i64, i64)** %fd20 to i32*
  store i32 %conv18, i32* %9, align 8
  %call = call fastcc i32 @ep_op_has_event(i32 noundef %7) #25
  %tobool23.not = icmp eq i32 %call, 0
  br i1 %tobool23.not, label %if.end36, label %if.then24

if.then24:                                        ; preds = %do.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %10 = load volatile i64, i64* %addr, align 8
  %11 = inttoptr i64 %10 to i8*
  %event = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %12 = bitcast i8** %event to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef %12, i8* noundef %11, i64 noundef 16) #27
  %tobool33.not = icmp eq i64 %call2.i, 0
  br i1 %tobool33.not, label %if.end36, label %return

if.end36:                                         ; preds = %if.then24, %do.end
  br label %return

return:                                           ; preds = %if.then24, %if.end, %entry, %lor.lhs.false, %lor.lhs.false3, %if.end36
  %retval.1 = phi i32 [ -14, %if.then24 ], [ 0, %if.end36 ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ]
  ret i32 %retval.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_splice_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %splice_off_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %0 = load volatile i64, i64* %splice_off_in, align 8
  %off_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %1 = bitcast i8** %off_in to i64*
  store i64 %0, i64* %1, align 8
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %2 = load volatile i64, i64* %off, align 8
  %off_out = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %3 = bitcast void (%struct.kiocb*, i64, i64)** %off_out to i64*
  store i64 %2, i64* %3, align 8
  %call = call fastcc i32 @__io_splice_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  ret i32 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_provide_buffers_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %pbuf = bitcast %struct.io_kiocb* %req to %struct.io_provide_buf*
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %1 = load i32, i32* %rw_flags, align 4
  %tobool1.not = icmp eq i32 %1, 0
  br i1 %tobool1.not, label %lor.lhs.false2, label %cleanup

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %2 = load i32, i32* %splice_fd_in, align 4
  %tobool3.not = icmp eq i32 %2, 0
  br i1 %tobool3.not, label %do.end, label %cleanup

do.end:                                           ; preds = %lor.lhs.false2
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %3 = load volatile i32, i32* %fd, align 4
  %4 = add i32 %3, -65536
  %5 = icmp ult i32 %4, -65535
  br i1 %5, label %cleanup, label %if.end10

if.end10:                                         ; preds = %do.end
  %conv11 = trunc i32 %3 to i16
  %nbufs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %6 = bitcast i8** %nbufs to i16*
  store i16 %conv11, i16* %6, align 8
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %7 = load volatile i64, i64* %addr, align 8
  %8 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %7, i64* %8, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %9 = load volatile i32, i32* %len, align 8
  %len21 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %10 = bitcast void (%struct.kiocb*, i64, i64)** %len21 to i32*
  store i32 %9, i32* %10, align 8
  %conv23 = zext i32 %9 to i64
  %conv25 = zext i32 %3 to i64
  %11 = mul nuw nsw i64 %conv23, %conv25
  %12 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %7, i64 %11)
  %13 = extractvalue { i64, i1 } %12, 1
  br i1 %13, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end10
  %14 = inttoptr i64 %7 to i8*
  %call57 = call fastcc i64 @__range_ok(i8* noundef %14, i64 noundef %11) #25
  %tobool58.not = icmp eq i64 %call57, 0
  br i1 %tobool58.not, label %cleanup, label %do.end63

do.end63:                                         ; preds = %if.end47
  %buf_group = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %15 = load volatile i16, i16* %buf_group, align 8
  %conv65 = zext i16 %15 to i32
  %bgid = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 3
  store i32 %conv65, i32* %bgid, align 4
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %16 = load volatile i64, i64* %off, align 8
  %cmp70 = icmp ugt i64 %16, 65535
  br i1 %cmp70, label %cleanup, label %if.end73

if.end73:                                         ; preds = %do.end63
  %conv74 = trunc i64 %16 to i16
  %bid = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 5
  store i16 %conv74, i16* %bid, align 2
  br label %cleanup

cleanup:                                          ; preds = %do.end63, %if.end47, %if.end10, %do.end, %entry, %lor.lhs.false, %lor.lhs.false2, %if.end73
  %retval.0 = phi i32 [ 0, %if.end73 ], [ -22, %lor.lhs.false2 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -7, %do.end ], [ -75, %if.end10 ], [ -14, %if.end47 ], [ -7, %do.end63 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_remove_buffers_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %pbuf = bitcast %struct.io_kiocb* %req to %struct.io_provide_buf*
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %0 = load i16, i16* %ioprio, align 2
  %tobool.not = icmp eq i16 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %1 = load i32, i32* %rw_flags, align 4
  %tobool1.not = icmp eq i32 %1, 0
  br i1 %tobool1.not, label %lor.lhs.false2, label %cleanup

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %2 = load i64, i64* %addr, align 8
  %tobool3.not = icmp eq i64 %2, 0
  br i1 %tobool3.not, label %lor.lhs.false4, label %cleanup

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %3 = load i32, i32* %len, align 8
  %tobool5.not = icmp eq i32 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %4 = load i64, i64* %off, align 8
  %tobool7.not = icmp eq i64 %4, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %5 = load i32, i32* %splice_fd_in, align 4
  %tobool9.not = icmp eq i32 %5, 0
  br i1 %tobool9.not, label %do.end, label %cleanup

do.end:                                           ; preds = %lor.lhs.false8
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %6 = load volatile i32, i32* %fd, align 4
  %7 = add i32 %6, -65536
  %8 = icmp ult i32 %7, -65535
  br i1 %8, label %cleanup, label %if.end16

if.end16:                                         ; preds = %do.end
  %9 = bitcast %struct.io_kiocb* %req to i8*
  %call = call i8* @memset(i8* noundef %9, i32 noundef 0, i64 noundef 32) #27
  %conv17 = trunc i32 %6 to i16
  %nbufs = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %10 = bitcast i8** %nbufs to i16*
  store i16 %conv17, i16* %10, align 8
  %buf_group = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %11 = load volatile i16, i16* %buf_group, align 8
  %conv22 = zext i16 %11 to i32
  %bgid = getelementptr inbounds %struct.io_provide_buf, %struct.io_provide_buf* %pbuf, i64 0, i32 3
  store i32 %conv22, i32* %bgid, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %entry, %lor.lhs.false, %lor.lhs.false2, %lor.lhs.false4, %lor.lhs.false6, %lor.lhs.false8, %if.end16
  %retval.0 = phi i32 [ 0, %if.end16 ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false4 ], [ -22, %lor.lhs.false2 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_tee_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %splice_off_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %0 = load volatile i64, i64* %splice_off_in, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %do.end2, label %return

do.end2:                                          ; preds = %entry
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %1 = load volatile i64, i64* %off, align 8
  %tobool4.not = icmp eq i64 %1, 0
  br i1 %tobool4.not, label %if.end, label %return

if.end:                                           ; preds = %do.end2
  %call = call fastcc i32 @__io_splice_prep(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe) #25
  br label %return

return:                                           ; preds = %entry, %do.end2, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -22, %do.end2 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_renameat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %rename = bitcast %struct.io_kiocb* %req to %struct.io_rename*
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %3 = load i16, i16* %buf_index, align 8
  %tobool6.not = icmp eq i16 %3, 0
  br i1 %tobool6.not, label %lor.lhs.false7, label %cleanup

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %4 = load i32, i32* %splice_fd_in, align 4
  %tobool8.not = icmp eq i32 %4, 0
  br i1 %tobool8.not, label %if.end10, label %cleanup

if.end10:                                         ; preds = %lor.lhs.false7
  %flags11 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %5 = load i32, i32* %flags11, align 8
  %and12 = and i32 %5, 1
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %if.end10
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %6 = load volatile i32, i32* %fd, align 4
  %old_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %7 = bitcast i64* %old_dfd to i32*
  store i32 %6, i32* %7, align 8
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %8 = load volatile i64, i64* %addr, align 8
  %9 = inttoptr i64 %8 to i8*
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %10 = load volatile i64, i64* %addr2, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %11 = load volatile i32, i32* %len, align 8
  %new_dfd = getelementptr inbounds %struct.io_rename, %struct.io_rename* %rename, i64 0, i32 2
  store i32 %11, i32* %new_dfd, align 4
  %rename_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %12 = load volatile i32, i32* %rename_flags, align 4
  %13 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  store i32 %12, i32* %13, align 8
  %call = call %struct.filename* @getname(i8* noundef %9) #27
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %14 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  store %struct.filename* %call, %struct.filename** %14, align 8
  %15 = bitcast %struct.filename* %call to i8*
  %call50 = call fastcc i1 @IS_ERR(i8* noundef %15) #25
  br i1 %call50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %do.end
  %call53 = call fastcc i64 @PTR_ERR(i8* noundef %15) #25
  %conv54 = trunc i64 %call53 to i32
  br label %cleanup

if.end55:                                         ; preds = %do.end
  %16 = inttoptr i64 %10 to i8*
  %call56 = call %struct.filename* @getname(i8* noundef %16) #27
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %17 = bitcast i8** %newpath to %struct.filename**
  store %struct.filename* %call56, %struct.filename** %17, align 8
  %18 = bitcast %struct.filename* %call56 to i8*
  %call58 = call fastcc i1 @IS_ERR(i8* noundef %18) #25
  br i1 %call58, label %if.then59, label %if.end64

if.then59:                                        ; preds = %if.end55
  %19 = load %struct.filename*, %struct.filename** %14, align 8
  call void @putname(%struct.filename* noundef %19) #27
  %20 = load i8*, i8** %newpath, align 8
  %call62 = call fastcc i64 @PTR_ERR(i8* noundef %20) #25
  %conv63 = trunc i64 %call62 to i32
  br label %cleanup

if.end64:                                         ; preds = %if.end55
  %21 = load i32, i32* %flags11, align 8
  %or = or i32 %21, 8192
  store i32 %or, i32* %flags11, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end, %lor.lhs.false, %lor.lhs.false7, %entry, %if.end64, %if.then59, %if.then51
  %retval.0 = phi i32 [ %conv54, %if.then51 ], [ %conv63, %if.then59 ], [ 0, %if.end64 ], [ -22, %entry ], [ -22, %lor.lhs.false7 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_unlinkat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %unlink = bitcast %struct.io_kiocb* %req to %struct.io_unlink*
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %3 = load i64, i64* %off, align 8
  %tobool5.not = icmp eq i64 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %4 = load i32, i32* %len, align 8
  %tobool7.not = icmp eq i32 %4, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %5 = load i16, i16* %buf_index, align 8
  %tobool10.not = icmp eq i16 %5, 0
  br i1 %tobool10.not, label %lor.lhs.false11, label %cleanup

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool12.not = icmp eq i32 %6, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %lor.lhs.false11
  %flags15 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %7 = load i32, i32* %flags15, align 8
  %and16 = and i32 %7, 1
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %if.end14
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %8 = load volatile i32, i32* %fd, align 4
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %9 = bitcast i64* %dfd to i32*
  store i32 %8, i32* %9, align 8
  %unlink_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %10 = load volatile i32, i32* %unlink_flags, align 4
  %flags31 = getelementptr inbounds %struct.io_unlink, %struct.io_unlink* %unlink, i64 0, i32 2
  store i32 %10, i32* %flags31, align 4
  %and33 = and i32 %10, -513
  %tobool34.not = icmp eq i32 %and33, 0
  br i1 %tobool34.not, label %if.end36, label %cleanup

if.end36:                                         ; preds = %do.end
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %11 = load volatile i64, i64* %addr, align 8
  %12 = inttoptr i64 %11 to i8*
  %call = call %struct.filename* @getname(i8* noundef %12) #27
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  store %struct.filename* %call, %struct.filename** %13, align 8
  %14 = bitcast %struct.filename* %call to i8*
  %call45 = call fastcc i1 @IS_ERR(i8* noundef %14) #25
  br i1 %call45, label %if.then46, label %if.end50

if.then46:                                        ; preds = %if.end36
  %call48 = call fastcc i64 @PTR_ERR(i8* noundef %14) #25
  %conv49 = trunc i64 %call48 to i32
  br label %cleanup

if.end50:                                         ; preds = %if.end36
  %15 = load i32, i32* %flags15, align 8
  %or = or i32 %15, 8192
  store i32 %or, i32* %flags15, align 8
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end14, %if.end, %lor.lhs.false, %lor.lhs.false6, %lor.lhs.false8, %lor.lhs.false11, %entry, %if.end50, %if.then46
  %retval.0 = phi i32 [ %conv49, %if.then46 ], [ 0, %if.end50 ], [ -22, %entry ], [ -22, %lor.lhs.false11 ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end14 ], [ -22, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_mkdirat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %mkdir = bitcast %struct.io_kiocb* %req to %struct.io_mkdir*
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %3 = load i64, i64* %off, align 8
  %tobool5.not = icmp eq i64 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %4 = load i32, i32* %rw_flags, align 4
  %tobool7.not = icmp eq i32 %4, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %5 = load i16, i16* %buf_index, align 8
  %tobool10.not = icmp eq i16 %5, 0
  br i1 %tobool10.not, label %lor.lhs.false11, label %cleanup

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool12.not = icmp eq i32 %6, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %lor.lhs.false11
  %flags15 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %7 = load i32, i32* %flags15, align 8
  %and16 = and i32 %7, 1
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %if.end14
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %8 = load volatile i32, i32* %fd, align 4
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %9 = bitcast i64* %dfd to i32*
  store i32 %8, i32* %9, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %10 = load volatile i32, i32* %len, align 8
  %conv31 = trunc i32 %10 to i16
  %mode = getelementptr inbounds %struct.io_mkdir, %struct.io_mkdir* %mkdir, i64 0, i32 2
  store i16 %conv31, i16* %mode, align 4
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %11 = load volatile i64, i64* %addr, align 8
  %12 = inttoptr i64 %11 to i8*
  %call = call %struct.filename* @getname(i8* noundef %12) #27
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  store %struct.filename* %call, %struct.filename** %13, align 8
  %14 = bitcast %struct.filename* %call to i8*
  %call40 = call fastcc i1 @IS_ERR(i8* noundef %14) #25
  br i1 %call40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %do.end
  %call43 = call fastcc i64 @PTR_ERR(i8* noundef %14) #25
  %conv44 = trunc i64 %call43 to i32
  br label %cleanup

if.end45:                                         ; preds = %do.end
  %15 = load i32, i32* %flags15, align 8
  %or = or i32 %15, 8192
  store i32 %or, i32* %flags15, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.end, %lor.lhs.false, %lor.lhs.false6, %lor.lhs.false8, %lor.lhs.false11, %entry, %if.end45, %if.then41
  %retval.0 = phi i32 [ %conv44, %if.then41 ], [ 0, %if.end45 ], [ -22, %entry ], [ -22, %lor.lhs.false11 ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_symlinkat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %3 = load i32, i32* %len, align 8
  %tobool5.not = icmp eq i32 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %4 = load i32, i32* %rw_flags, align 4
  %tobool7.not = icmp eq i32 %4, 0
  br i1 %tobool7.not, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %5 = load i16, i16* %buf_index, align 8
  %tobool10.not = icmp eq i16 %5, 0
  br i1 %tobool10.not, label %lor.lhs.false11, label %cleanup

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %6 = load i32, i32* %splice_fd_in, align 4
  %tobool12.not = icmp eq i32 %6, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %lor.lhs.false11
  %flags15 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %7 = load i32, i32* %flags15, align 8
  %and16 = and i32 %7, 1
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %if.end14
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %8 = load volatile i32, i32* %fd, align 4
  %new_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %9 = bitcast i64* %new_dfd to i32*
  store i32 %8, i32* %9, align 8
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %10 = load volatile i64, i64* %addr, align 8
  %11 = inttoptr i64 %10 to i8*
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %12 = load volatile i64, i64* %addr2, align 8
  %call = call %struct.filename* @getname(i8* noundef %11) #27
  %oldpath44 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %13 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath44 to %struct.filename**
  store %struct.filename* %call, %struct.filename** %13, align 8
  %14 = bitcast %struct.filename* %call to i8*
  %call46 = call fastcc i1 @IS_ERR(i8* noundef %14) #25
  br i1 %call46, label %if.then47, label %if.end51

if.then47:                                        ; preds = %do.end
  %call49 = call fastcc i64 @PTR_ERR(i8* noundef %14) #25
  %conv50 = trunc i64 %call49 to i32
  br label %cleanup

if.end51:                                         ; preds = %do.end
  %15 = inttoptr i64 %12 to i8*
  %call52 = call %struct.filename* @getname(i8* noundef %15) #27
  %newpath53 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %16 = bitcast i8** %newpath53 to %struct.filename**
  store %struct.filename* %call52, %struct.filename** %16, align 8
  %17 = bitcast %struct.filename* %call52 to i8*
  %call55 = call fastcc i1 @IS_ERR(i8* noundef %17) #25
  br i1 %call55, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end51
  %18 = load %struct.filename*, %struct.filename** %13, align 8
  call void @putname(%struct.filename* noundef %18) #27
  %19 = load i8*, i8** %newpath53, align 8
  %call59 = call fastcc i64 @PTR_ERR(i8* noundef %19) #25
  %conv60 = trunc i64 %call59 to i32
  br label %cleanup

if.end61:                                         ; preds = %if.end51
  %20 = load i32, i32* %flags15, align 8
  %or = or i32 %20, 8192
  store i32 %or, i32* %flags15, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.end, %lor.lhs.false, %lor.lhs.false6, %lor.lhs.false8, %lor.lhs.false11, %entry, %if.end61, %if.then56, %if.then47
  %retval.0 = phi i32 [ %conv50, %if.then47 ], [ %conv60, %if.then56 ], [ 0, %if.end61 ], [ -22, %entry ], [ -22, %lor.lhs.false11 ], [ -22, %lor.lhs.false8 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_linkat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %hardlink = bitcast %struct.io_kiocb* %req to %struct.io_hardlink*
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %3 = load i32, i32* %rw_flags, align 4
  %tobool5.not = icmp eq i32 %3, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %4 = load i16, i16* %buf_index, align 8
  %tobool8.not = icmp eq i16 %4, 0
  br i1 %tobool8.not, label %lor.lhs.false9, label %cleanup

lor.lhs.false9:                                   ; preds = %lor.lhs.false6
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %5 = load i32, i32* %splice_fd_in, align 4
  %tobool10.not = icmp eq i32 %5, 0
  br i1 %tobool10.not, label %if.end12, label %cleanup

if.end12:                                         ; preds = %lor.lhs.false9
  %flags13 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %6 = load i32, i32* %flags13, align 8
  %and14 = and i32 %6, 1
  %tobool15.not = icmp eq i32 %and14, 0
  br i1 %tobool15.not, label %do.end, label %cleanup, !prof !8

do.end:                                           ; preds = %if.end12
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %7 = load volatile i32, i32* %fd, align 4
  %old_dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %8 = bitcast i64* %old_dfd to i32*
  store i32 %7, i32* %8, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %9 = load volatile i32, i32* %len, align 8
  %new_dfd = getelementptr inbounds %struct.io_hardlink, %struct.io_hardlink* %hardlink, i64 0, i32 2
  store i32 %9, i32* %new_dfd, align 4
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %10 = load volatile i64, i64* %addr, align 8
  %11 = inttoptr i64 %10 to i8*
  %addr2 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %12 = load volatile i64, i64* %addr2, align 8
  %13 = load volatile i32, i32* %rw_flags, align 4
  %14 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  store i32 %13, i32* %14, align 8
  %call = call %struct.filename* @getname(i8* noundef %11) #27
  %oldpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %15 = bitcast void (%struct.kiocb*, i64, i64)** %oldpath to %struct.filename**
  store %struct.filename* %call, %struct.filename** %15, align 8
  %16 = bitcast %struct.filename* %call to i8*
  %call52 = call fastcc i1 @IS_ERR(i8* noundef %16) #25
  br i1 %call52, label %if.then53, label %if.end57

if.then53:                                        ; preds = %do.end
  %call55 = call fastcc i64 @PTR_ERR(i8* noundef %16) #25
  %conv56 = trunc i64 %call55 to i32
  br label %cleanup

if.end57:                                         ; preds = %do.end
  %17 = inttoptr i64 %12 to i8*
  %call58 = call %struct.filename* @getname(i8* noundef %17) #27
  %newpath = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %18 = bitcast i8** %newpath to %struct.filename**
  store %struct.filename* %call58, %struct.filename** %18, align 8
  %19 = bitcast %struct.filename* %call58 to i8*
  %call60 = call fastcc i1 @IS_ERR(i8* noundef %19) #25
  br i1 %call60, label %if.then61, label %if.end66

if.then61:                                        ; preds = %if.end57
  %20 = load %struct.filename*, %struct.filename** %15, align 8
  call void @putname(%struct.filename* noundef %20) #27
  %21 = load i8*, i8** %newpath, align 8
  %call64 = call fastcc i64 @PTR_ERR(i8* noundef %21) #25
  %conv65 = trunc i64 %call64 to i32
  br label %cleanup

if.end66:                                         ; preds = %if.end57
  %22 = load i32, i32* %flags13, align 8
  %or = or i32 %22, 8192
  store i32 %or, i32* %flags13, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.end, %lor.lhs.false, %lor.lhs.false6, %lor.lhs.false9, %entry, %if.end66, %if.then61, %if.then53
  %retval.0 = phi i32 [ %conv56, %if.then53 ], [ %conv65, %if.then61 ], [ 0, %if.end66 ], [ -22, %entry ], [ -22, %lor.lhs.false9 ], [ -22, %lor.lhs.false6 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -9, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_prep_rw(%struct.io_kiocb* noundef %req, %struct.io_uring_sqe* noundef %sqe, i32 noundef %rw) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %kiocb3 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0
  %file4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 0
  %1 = load %struct.file*, %struct.file** %file4, align 8
  %call = call fastcc i1 @io_req_ffs_set(%struct.io_kiocb* noundef %req) #25
  br i1 %call, label %do.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call5 = call fastcc %struct.inode* @file_inode(%struct.file* noundef %1) #25
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call5, i64 0, i32 0
  %2 = load i16, i16* %i_mode, align 8
  %3 = and i16 %2, -4096
  %cmp = icmp eq i16 %3, -32768
  br i1 %cmp, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %4 = load i32, i32* %flags, align 8
  %or = or i32 %4, 8388608
  store i32 %or, i32* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %entry, %land.lhs.true, %if.then
  %off = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 4, i32 0
  %5 = load volatile i64, i64* %off, align 8
  %ki_pos = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  store i64 %5, i64* %ki_pos, align 8
  %cmp8 = icmp eq i64 %5, -1
  br i1 %cmp8, label %land.lhs.true10, label %if.end16

land.lhs.true10:                                  ; preds = %do.end
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %1, i64 0, i32 8
  %6 = load i32, i32* %f_mode, align 4
  %and11 = and i32 %6, 2097152
  %tobool.not = icmp eq i32 %and11, 0
  br i1 %tobool.not, label %if.then12, label %if.end16

if.then12:                                        ; preds = %land.lhs.true10
  %flags13 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %7 = load i32, i32* %flags13, align 8
  %or14 = or i32 %7, 1024
  store i32 %or14, i32* %flags13, align 8
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %1, i64 0, i32 10
  %8 = load i64, i64* %f_pos, align 8
  store i64 %8, i64* %ki_pos, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %land.lhs.true10, %do.end
  %call17 = call fastcc i32 @file_write_hint(%struct.file* noundef %1) #25
  %call18 = call fastcc i16 @ki_hint_validate(i32 noundef %call17) #25
  %ki_hint = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 5
  store i16 %call18, i16* %ki_hint, align 4
  %call20 = call fastcc i32 @iocb_flags(%struct.file* noundef %1) #25
  %ki_flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  store i32 %call20, i32* %ki_flags, align 8
  %rw_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %9 = load volatile i32, i32* %rw_flags, align 4
  %call25 = call fastcc i32 @kiocb_set_rw_flags(%struct.kiocb* noundef %kiocb3, i32 noundef %9) #25
  %tobool26.not = icmp eq i32 %call25, 0
  br i1 %tobool26.not, label %if.end31, label %cleanup, !prof !8

if.end31:                                         ; preds = %if.end16
  %10 = load i32, i32* %ki_flags, align 8
  %and33 = and i32 %10, 8
  %tobool34.not = icmp eq i32 %and33, 0
  br i1 %tobool34.not, label %lor.lhs.false, label %if.then39

lor.lhs.false:                                    ; preds = %if.end31
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %1, i64 0, i32 7
  %11 = load i32, i32* %f_flags, align 8
  %and35 = and i32 %11, 2048
  %tobool36.not = icmp eq i32 %and35, 0
  br i1 %tobool36.not, label %do.end45, label %land.lhs.true37

land.lhs.true37:                                  ; preds = %lor.lhs.false
  %call38 = call fastcc i1 @io_file_supports_nowait(%struct.io_kiocb* noundef %req, i32 noundef %rw) #25
  br i1 %call38, label %do.end45, label %if.then39

if.then39:                                        ; preds = %land.lhs.true37, %if.end31
  %flags40 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %12 = load i32, i32* %flags40, align 8
  %or41 = or i32 %12, 2048
  store i32 %or41, i32* %flags40, align 8
  br label %do.end45

do.end45:                                         ; preds = %lor.lhs.false, %land.lhs.true37, %if.then39
  %ioprio47 = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %13 = load volatile i16, i16* %ioprio47, align 2
  %tobool49.not = icmp eq i16 %13, 0
  br i1 %tobool49.not, label %if.else, label %if.then50

if.then50:                                        ; preds = %do.end45
  %conv48 = zext i16 %13 to i32
  %call51 = call i32 @ioprio_check_cap(i32 noundef %conv48) #27
  %tobool52.not = icmp eq i32 %call51, 0
  br i1 %tobool52.not, label %if.end59, label %cleanup

if.else:                                          ; preds = %do.end45
  %call56 = call fastcc i32 @get_current_ioprio() #25
  %conv57 = trunc i32 %call56 to i16
  br label %if.end59

if.end59:                                         ; preds = %if.then50, %if.else
  %conv57.sink = phi i16 [ %conv57, %if.else ], [ %13, %if.then50 ]
  %ki_ioprio58 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 6
  store i16 %conv57.sink, i16* %ki_ioprio58, align 2
  %flags60 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %14 = load i32, i32* %flags60, align 8
  %and61 = and i32 %14, 1
  %tobool62.not = icmp eq i32 %and61, 0
  %15 = load i32, i32* %ki_flags, align 8
  br i1 %tobool62.not, label %if.else74, label %if.then63

if.then63:                                        ; preds = %if.end59
  %and65 = and i32 %15, 131072
  %tobool66.not = icmp eq i32 %and65, 0
  br i1 %tobool66.not, label %cleanup, label %lor.lhs.false67

lor.lhs.false67:                                  ; preds = %if.then63
  %16 = load %struct.file*, %struct.file** %file4, align 8
  %f_op = getelementptr inbounds %struct.file, %struct.file* %16, i64 0, i32 3
  %17 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %iopoll = getelementptr inbounds %struct.file_operations, %struct.file_operations* %17, i64 0, i32 6
  %18 = load i32 (%struct.kiocb*, i1)*, i32 (%struct.kiocb*, i1)** %iopoll, align 8
  %tobool69.not = icmp eq i32 (%struct.kiocb*, i1)* %18, null
  br i1 %tobool69.not, label %cleanup, label %if.end71

if.end71:                                         ; preds = %lor.lhs.false67
  %or73 = or i32 %15, 2097153
  store i32 %or73, i32* %ki_flags, align 8
  %ki_complete = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  store void (%struct.kiocb*, i64, i64)* @io_complete_rw_iopoll, void (%struct.kiocb*, i64, i64)** %ki_complete, align 8
  %iopoll_completed = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 3
  store i8 0, i8* %iopoll_completed, align 1
  br label %if.end81

if.else74:                                        ; preds = %if.end59
  %and76 = and i32 %15, 1
  %tobool77.not = icmp eq i32 %and76, 0
  br i1 %tobool77.not, label %if.end79, label %cleanup

if.end79:                                         ; preds = %if.else74
  %ki_complete80 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  store void (%struct.kiocb*, i64, i64)* @io_complete_rw, void (%struct.kiocb*, i64, i64)** %ki_complete80, align 8
  br label %if.end81

if.end81:                                         ; preds = %if.end79, %if.end71
  %opcode = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 2
  %19 = load i8, i8* %opcode, align 8
  %20 = and i8 %19, -2
  %switch = icmp eq i8 %20, 4
  br i1 %switch, label %if.then90, label %do.end94

if.then90:                                        ; preds = %if.end81
  %imu = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 19
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %imu, align 8
  call fastcc void @io_req_set_rsrc_node(%struct.io_kiocb* noundef %req) #25
  br label %do.end94

do.end94:                                         ; preds = %if.end81, %if.then90
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %21 = load volatile i64, i64* %addr, align 8
  %addr97 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  store i64 %21, i64* %addr97, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %22 = load volatile i32, i32* %len, align 8
  %conv102 = zext i32 %22 to i64
  %len104 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 2
  store i64 %conv102, i64* %len104, align 8
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %23 = load volatile i16, i16* %buf_index, align 8
  %buf_index109 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 4
  store i16 %23, i16* %buf_index109, align 2
  br label %cleanup

cleanup:                                          ; preds = %if.else74, %if.then63, %lor.lhs.false67, %if.then50, %if.end16, %do.end94
  %retval.0 = phi i32 [ 0, %do.end94 ], [ %call25, %if.end16 ], [ %call51, %if.then50 ], [ -95, %lor.lhs.false67 ], [ -95, %if.then63 ], [ -22, %if.else74 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i1 @io_req_ffs_set(%struct.io_kiocb* nocapture noundef readonly %req) unnamed_addr #3 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i16 @ki_hint_validate(i32 noundef %hint) unnamed_addr #0 {
entry:
  %0 = icmp ult i32 %hint, 65536
  %retval.05 = select i1 %0, i32 %hint, i32 65536
  %1 = trunc i32 %retval.05 to i16
  ret i16 %1
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @file_write_hint(%struct.file* nocapture noundef readonly %file) unnamed_addr #3 {
entry:
  %f_write_hint = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 5
  %0 = load i32, i32* %f_write_hint, align 4
  %cmp.not = icmp eq i32 %0, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = call fastcc %struct.inode* @file_inode(%struct.file* noundef %file) #25
  %i_write_hint = getelementptr inbounds %struct.inode, %struct.inode* %call, i64 0, i32 18
  %1 = load i8, i8* %i_write_hint, align 1
  %conv = zext i8 %1 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv, %if.end ], [ %0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn
define internal fastcc i32 @iocb_flags(%struct.file* nocapture noundef readonly %file) unnamed_addr #3 {
entry:
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 7
  %0 = load i32, i32* %f_flags, align 8
  %and = lshr i32 %0, 6
  %1 = and i32 %and, 16
  %and2 = shl i32 %0, 1
  %2 = and i32 %and2, 131072
  %3 = or i32 %2, %1
  %and8 = and i32 %0, 4096
  %tobool9.not = icmp eq i32 %and8, 0
  br i1 %tobool9.not, label %lor.lhs.false, label %if.then17

lor.lhs.false:                                    ; preds = %entry
  %f_mapping = getelementptr inbounds %struct.file, %struct.file* %file, i64 0, i32 17
  %4 = load %struct.address_space*, %struct.address_space** %f_mapping, align 8
  %host = getelementptr inbounds %struct.address_space, %struct.address_space* %4, i64 0, i32 0
  %5 = load %struct.inode*, %struct.inode** %host, align 8
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %5, i64 0, i32 6
  %6 = load %struct.super_block*, %struct.super_block** %i_sb, align 8
  %s_flags = getelementptr inbounds %struct.super_block, %struct.super_block* %6, i64 0, i32 10
  %7 = load i64, i64* %s_flags, align 16
  %and10 = and i64 %7, 16
  %tobool11.not = icmp eq i64 %and10, 0
  br i1 %tobool11.not, label %lor.lhs.false12, label %if.then17

lor.lhs.false12:                                  ; preds = %lor.lhs.false
  %i_flags = getelementptr inbounds %struct.inode, %struct.inode* %5, i64 0, i32 4
  %8 = load i32, i32* %i_flags, align 4
  %and15 = and i32 %8, 1
  %tobool16.not = icmp eq i32 %and15, 0
  br i1 %tobool16.not, label %if.end19, label %if.then17

if.then17:                                        ; preds = %lor.lhs.false12, %lor.lhs.false, %entry
  %or18 = or i32 %3, 2
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %lor.lhs.false12
  %res.2 = phi i32 [ %or18, %if.then17 ], [ %3, %lor.lhs.false12 ]
  %and21 = lshr i32 %0, 18
  %9 = and i32 %and21, 4
  %10 = or i32 %res.2, %9
  ret i32 %10
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @kiocb_set_rw_flags(%struct.kiocb* nocapture noundef %ki, i32 noundef %flags) unnamed_addr #12 {
entry:
  %tobool.not = icmp eq i32 %flags, 0
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool1.not = icmp ult i32 %flags, 32
  br i1 %tobool1.not, label %if.end5, label %cleanup, !prof !8

if.end5:                                          ; preds = %if.end
  %and6 = and i32 %flags, 8
  %tobool7.not = icmp eq i32 %and6, 0
  br i1 %tobool7.not, label %if.end13, label %if.then8

if.then8:                                         ; preds = %if.end5
  %ki_filp = getelementptr inbounds %struct.kiocb, %struct.kiocb* %ki, i64 0, i32 0
  %0 = load %struct.file*, %struct.file** %ki_filp, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 8
  %1 = load i32, i32* %f_mode, align 4
  %and9 = and i32 %1, 134217728
  %tobool10.not = icmp eq i32 %and9, 0
  br i1 %tobool10.not, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end5
  %kiocb_flags.0 = phi i32 [ 0, %if.end5 ], [ 1048576, %if.then8 ]
  %and16 = lshr i32 %flags, 1
  %2 = and i32 %and16, 2
  %ki_flags = getelementptr inbounds %struct.kiocb, %struct.kiocb* %ki, i64 0, i32 4
  %3 = load i32, i32* %ki_flags, align 8
  %or15 = or i32 %2, %flags
  %4 = or i32 %or15, %kiocb_flags.0
  %or21 = or i32 %4, %3
  store i32 %or21, i32* %ki_flags, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %if.end, %entry, %if.end13
  %retval.0 = phi i32 [ 0, %if.end13 ], [ 0, %entry ], [ -95, %if.end ], [ -95, %if.then8 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @ioprio_check_cap(i32 noundef) local_unnamed_addr #4

; Function Attrs: nofree noinline nounwind null_pointer_is_valid readonly
define internal fastcc i32 @get_current_ioprio() unnamed_addr #13 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_context = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 112
  %2 = load %struct.io_context*, %struct.io_context** %io_context, align 16
  %tobool.not = icmp eq %struct.io_context* %2, null
  br i1 %tobool.not, label %cleanup, label %if.then

if.then:                                          ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_context, %struct.io_context* %2, i64 0, i32 4
  %3 = load i16, i16* %ioprio, align 4
  %conv = zext i16 %3 to i32
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ 16388, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_complete_rw_iopoll(%struct.kiocb* noundef %kiocb, i64 noundef %res, i64 noundef %res2) #1 {
entry:
  %0 = bitcast %struct.kiocb* %kiocb to %struct.io_kiocb*
  %ki_flags = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 0, i32 4
  %1 = load i32, i32* %ki_flags, align 8
  %and = and i32 %1, 262144
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @kiocb_end_write(%struct.io_kiocb* noundef %0) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 5
  %2 = load i32, i32* %result, align 4
  %conv = zext i32 %2 to i64
  %cmp.not = icmp eq i64 %conv, %res
  br i1 %cmp.not, label %do.body16, label %if.then5, !prof !8

if.then5:                                         ; preds = %if.end
  %cmp6 = icmp eq i64 %res, -11
  br i1 %cmp6, label %land.lhs.true, label %do.body16

land.lhs.true:                                    ; preds = %if.then5
  %call = call fastcc i1 @io_rw_should_reissue(%struct.io_kiocb* noundef %0) #25
  br i1 %call, label %if.then9, label %do.body16

if.then9:                                         ; preds = %land.lhs.true
  %flags = getelementptr inbounds %struct.kiocb, %struct.kiocb* %kiocb, i64 1, i32 7
  %3 = bitcast %union.anon.40* %flags to i32*
  %4 = load i32, i32* %3, align 8
  %or = or i32 %4, 131072
  store i32 %or, i32* %3, align 8
  br label %cleanup

do.body16:                                        ; preds = %if.end, %land.lhs.true, %if.then5
  %conv17 = trunc i64 %res to i32
  store volatile i32 %conv17, i32* %result, align 4
  call void asm sideeffect "dmb ishst", "~{memory}"() #26, !srcloc !115
  %iopoll_completed = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %0, i64 0, i32 3
  store volatile i8 1, i8* %iopoll_completed, align 1
  br label %cleanup

cleanup:                                          ; preds = %do.body16, %if.then9
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @io_poll_parse_events(%struct.io_uring_sqe* noundef %sqe, i32 noundef %flags) unnamed_addr #8 {
entry:
  %poll32_events = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %0 = load volatile i32, i32* %poll32_events, align 4
  %and = shl i32 %flags, 30
  %1 = xor i32 %and, 1073741824
  %2 = or i32 %0, %1
  %conv = trunc i32 %0 to i16
  %call = call fastcc i32 @demangle_poll(i16 noundef %conv) #25
  %and1 = and i32 %2, 1342177280
  %or2 = or i32 %and1, %call
  ret i32 %or2
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @demangle_poll(i16 noundef %val) unnamed_addr #0 {
entry:
  %0 = and i16 %val, 10239
  %or43 = zext i16 %0 to i32
  ret i32 %or43
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__arch_hweight32(i32 noundef %w) unnamed_addr #1 {
entry:
  %call = call i32 @__sw_hweight32(i32 noundef %w) #27
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @get_timespec64(%struct.timespec64* noundef, %struct.__kernel_timespec* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__sw_hweight32(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @build_open_how(%struct.open_how* sret(%struct.open_how) align 8, i32 noundef, i16 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_openat_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %ioprio = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 2
  %2 = load i16, i16* %ioprio, align 2
  %tobool4.not = icmp eq i16 %2, 0
  br i1 %tobool4.not, label %lor.rhs, label %cleanup, !prof !8

lor.rhs:                                          ; preds = %if.end
  %buf_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 9, i32 0
  %3 = load i16, i16* %buf_index, align 8
  %tobool6.not = icmp eq i16 %3, 0
  br i1 %tobool6.not, label %if.end15, label %cleanup, !prof !8

if.end15:                                         ; preds = %lor.rhs
  %flags16 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %4 = load i32, i32* %flags16, align 8
  %and17 = and i32 %4, 1
  %tobool18.not = icmp eq i32 %and17, 0
  br i1 %tobool18.not, label %if.end27, label %cleanup, !prof !8

if.end27:                                         ; preds = %if.end15
  %open = bitcast %struct.io_kiocb* %req to %struct.io_open*
  %how = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 3
  %flags28 = bitcast i8** %how to i64*
  %5 = load i64, i64* %flags28, align 8
  %and29 = and i64 %5, 2097152
  %tobool30.not = icmp eq i64 %and29, 0
  br i1 %tobool30.not, label %if.then31, label %do.end

if.then31:                                        ; preds = %if.end27
  %or = or i64 %5, 131072
  store i64 %or, i64* %flags28, align 8
  br label %do.end

do.end:                                           ; preds = %if.end27, %if.then31
  %fd = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 3
  %6 = load volatile i32, i32* %fd, align 4
  %dfd = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %7 = bitcast i64* %dfd to i32*
  store i32 %6, i32* %7, align 8
  %addr = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 5, i32 0
  %8 = load volatile i64, i64* %addr, align 8
  %9 = inttoptr i64 %8 to i8*
  %call = call %struct.filename* @getname(i8* noundef %9) #27
  %filename = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 2
  %10 = bitcast void (%struct.kiocb*, i64, i64)** %filename to %struct.filename**
  store %struct.filename* %call, %struct.filename** %10, align 8
  %11 = bitcast %struct.filename* %call to i8*
  %call47 = call fastcc i1 @IS_ERR(i8* noundef %11) #25
  br i1 %call47, label %if.then48, label %do.end58

if.then48:                                        ; preds = %do.end
  %call51 = call fastcc i64 @PTR_ERR(i8* noundef %11) #25
  %conv52 = trunc i64 %call51 to i32
  store %struct.filename* null, %struct.filename** %10, align 8
  br label %cleanup

do.end58:                                         ; preds = %do.end
  %file_index = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %12 = load volatile i32, i32* %file_index, align 4
  %file_slot = getelementptr inbounds %struct.io_open, %struct.io_open* %open, i64 0, i32 2
  store i32 %12, i32* %file_slot, align 4
  %tobool63.not = icmp eq i32 %12, 0
  br i1 %tobool63.not, label %if.end70, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end58
  %13 = load i64, i64* %flags28, align 8
  %and67 = and i64 %13, 524288
  %tobool68.not = icmp eq i64 %and67, 0
  br i1 %tobool68.not, label %if.end70, label %cleanup

if.end70:                                         ; preds = %land.lhs.true, %do.end58
  %call71 = call fastcc i64 @rlimit(i32 noundef 7) #25
  %14 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 1
  store i64 %call71, i64* %14, align 8
  %15 = load i32, i32* %flags16, align 8
  %or74 = or i32 %15, 8192
  store i32 %or74, i32* %flags16, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end, %land.lhs.true, %if.end15, %lor.rhs, %entry, %if.end70, %if.then48
  %retval.0 = phi i32 [ %conv52, %if.then48 ], [ 0, %if.end70 ], [ -22, %entry ], [ -22, %lor.rhs ], [ -9, %if.end15 ], [ -22, %land.lhs.true ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.filename* @getname(i8* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @check_zeroed_user(i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @ep_op_has_event(i32 noundef %op) unnamed_addr #0 {
entry:
  %cmp = icmp ne i32 %op, 2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_splice_prep(%struct.io_kiocb* nocapture noundef %req, %struct.io_uring_sqe* noundef %sqe) unnamed_addr #1 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 2
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup, !prof !8

if.end:                                           ; preds = %entry
  %file_in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 1
  %2 = bitcast i64* %file_in to %struct.file**
  store %struct.file* null, %struct.file** %2, align 8
  %len = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 6
  %3 = load volatile i32, i32* %len, align 8
  %conv3 = zext i32 %3 to i64
  %len4 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 4
  %4 = bitcast i32* %len4 to i64*
  store i64 %conv3, i64* %4, align 8
  %splice_flags = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 7, i32 0
  %5 = load volatile i32, i32* %splice_flags, align 4
  %flags9 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 0, i32 0, i32 0, i32 7
  %6 = bitcast %union.anon.40* %flags9 to i32*
  store i32 %5, i32* %6, align 8
  %and11 = and i32 %5, 2147483632
  %tobool12.not = icmp eq i32 %and11, 0
  br i1 %tobool12.not, label %if.end21, label %cleanup, !prof !8

if.end21:                                         ; preds = %if.end
  %splice_fd_in = getelementptr inbounds %struct.io_uring_sqe, %struct.io_uring_sqe* %sqe, i64 0, i32 11, i32 0
  %7 = load volatile i32, i32* %splice_fd_in, align 4
  %tobool29 = icmp slt i32 %5, 0
  %call = call fastcc %struct.file* @io_file_get(%struct.io_ring_ctx* noundef %0, %struct.io_kiocb* noundef %req, i32 noundef %7, i1 noundef %tobool29) #25
  store %struct.file* %call, %struct.file** %2, align 8
  %tobool32.not = icmp eq %struct.file* %call, null
  br i1 %tobool32.not, label %cleanup, label %if.end34

if.end34:                                         ; preds = %if.end21
  %flags35 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %8 = load i32, i32* %flags35, align 8
  %or = or i32 %8, 8192
  store i32 %or, i32* %flags35, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.end, %entry, %if.end34
  %retval.0 = phi i32 [ 0, %if.end34 ], [ -22, %entry ], [ -22, %if.end ], [ -9, %if.end21 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_drain_req(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 256
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @io_req_complete_fail_submit(%struct.io_kiocb* noundef %req) #25
  br label %cleanup

if.end:                                           ; preds = %entry
  %drain_next = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %drain_next, align 4
  %2 = and i8 %bf.load, 2
  %tobool2.not = icmp eq i8 %2, 0
  br i1 %tobool2.not, label %if.end8, label %if.then3

if.then3:                                         ; preds = %if.end
  %or = or i32 %1, 2
  store i32 %or, i32* %flags, align 8
  %bf.load6 = load i8, i8* %drain_next, align 4
  %bf.clear7 = and i8 %bf.load6, -3
  store i8 %bf.clear7, i8* %drain_next, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %bf.load15 = phi i8 [ %bf.clear7, %if.then3 ], [ %bf.load, %if.end ]
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end8
  %req.pn = phi %struct.io_kiocb* [ %req, %if.end8 ], [ %pos.0, %for.body ]
  %pos.0.in = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.pn, i64 0, i32 11
  %pos.0 = load %struct.io_kiocb*, %struct.io_kiocb** %pos.0.in, align 8
  %tobool9.not = icmp eq %struct.io_kiocb* %pos.0, null
  br i1 %tobool9.not, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %flags10 = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %pos.0, i64 0, i32 7
  %3 = load i32, i32* %flags10, align 8
  %and11 = and i32 %3, 2
  %tobool12.not = icmp eq i32 %and11, 0
  br i1 %tobool12.not, label %for.cond, label %if.then13

if.then13:                                        ; preds = %for.body
  %bf.set17 = or i8 %bf.load15, 2
  store i8 %bf.set17, i8* %drain_next, align 4
  %4 = load i32, i32* %flags, align 8
  %or19 = or i32 %4, 2
  store i32 %or19, i32* %flags, align 8
  br label %for.end

for.end:                                          ; preds = %for.cond, %if.then13
  %defer_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 5
  %call = call fastcc i32 @list_empty_careful(%struct.list_head* noundef %defer_list) #25
  %tobool22.not = icmp eq i32 %call, 0
  br i1 %tobool22.not, label %if.end33, label %land.rhs, !prof !24

land.rhs:                                         ; preds = %for.end
  %5 = load i32, i32* %flags, align 8
  %and24 = and i32 %5, 2
  %tobool25.not = icmp eq i32 %and24, 0
  br i1 %tobool25.not, label %if.then29, label %if.end33, !prof !8

if.then29:                                        ; preds = %land.rhs
  %bf.load30 = load i8, i8* %drain_next, align 4
  %bf.clear31 = and i8 %bf.load30, -33
  store i8 %bf.clear31, i8* %drain_next, align 4
  br label %cleanup

if.end33:                                         ; preds = %for.end, %land.rhs
  %call34 = call fastcc i32 @io_get_sequence(%struct.io_kiocb* noundef %req) #25
  %call35 = call fastcc i1 @req_need_defer(%struct.io_kiocb* noundef %req, i32 noundef %call34) #25
  br i1 %call35, label %if.end40, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end33
  %call37 = call fastcc i32 @list_empty_careful(%struct.list_head* noundef %defer_list) #25
  %tobool38.not = icmp eq i32 %call37, 0
  br i1 %tobool38.not, label %if.end40, label %cleanup

if.end40:                                         ; preds = %land.lhs.true, %if.end33
  %call41 = call fastcc i32 @io_req_prep_async(%struct.io_kiocb* noundef %req) #25
  %tobool42.not = icmp eq i32 %call41, 0
  br i1 %tobool42.not, label %if.end44, label %fail

if.end44:                                         ; preds = %if.end40
  call fastcc void @io_prep_async_link(%struct.io_kiocb* noundef %req) #25
  %6 = load %struct.kmem_cache*, %struct.kmem_cache** getelementptr inbounds ([3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 0, i64 7), align 8
  %call.i.i = call noalias align 8 i8* @kmem_cache_alloc(%struct.kmem_cache* noundef %6, i32 noundef 3264) #27
  %tobool46.not = icmp eq i8* %call.i.i, null
  br i1 %tobool46.not, label %fail, label %if.end49

fail:                                             ; preds = %if.end44, %if.end40
  %ret.0 = phi i32 [ %call41, %if.end40 ], [ -12, %if.end44 ]
  %conv48 = sext i32 %ret.0 to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv48) #25
  br label %cleanup

if.end49:                                         ; preds = %if.end44
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %call50 = call fastcc i1 @req_need_defer(%struct.io_kiocb* noundef %req, i32 noundef %call34) #25
  br i1 %call50, label %if.end57, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %if.end49
  %call53 = call fastcc i32 @list_empty(%struct.list_head* noundef %defer_list) #25
  %tobool54.not = icmp eq i32 %call53, 0
  br i1 %tobool54.not, label %if.end57, label %if.then55

if.then55:                                        ; preds = %land.lhs.true51
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call void @kfree(i8* noundef nonnull %call.i.i) #27
  call void @io_queue_async_work(%struct.io_kiocb* noundef %req, i8* noundef null) #25
  br label %cleanup

if.end57:                                         ; preds = %land.lhs.true51, %if.end49
  %req58 = getelementptr inbounds i8, i8* %call.i.i, i64 16
  %7 = bitcast i8* %req58 to %struct.io_kiocb**
  store %struct.io_kiocb* %req, %struct.io_kiocb** %7, align 8
  %seq59 = getelementptr inbounds i8, i8* %call.i.i, i64 24
  %8 = bitcast i8* %seq59 to i32*
  store i32 %call34, i32* %8, align 8
  %list = bitcast i8* %call.i.i to %struct.list_head*
  call fastcc void @list_add_tail(%struct.list_head* noundef nonnull %list, %struct.list_head* noundef %defer_list) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true, %if.end57, %if.then55, %fail, %if.then29, %if.then
  %retval.0 = phi i1 [ true, %if.then ], [ false, %if.then29 ], [ true, %fail ], [ true, %if.end57 ], [ true, %if.then55 ], [ false, %land.lhs.true ]
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_req_complete_fail_submit(%struct.io_kiocb* noundef %req) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 7
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, -13
  %or = or i32 %and, 4
  store i32 %or, i32* %flags, align 8
  %result = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 5
  %1 = load i32, i32* %result, align 4
  %conv = zext i32 %1 to i64
  call fastcc void @io_req_complete_failed(%struct.io_kiocb* noundef %req, i64 noundef %conv) #25
  ret void
}

; Function Attrs: nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly
define internal fastcc i32 @io_get_sequence(%struct.io_kiocb* noundef readonly %req) unnamed_addr #7 {
entry:
  %ctx = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req, i64 0, i32 6
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx, align 8
  %cached_sq_head = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 1, i32 3
  %1 = load i32, i32* %cached_sq_head, align 16
  %tobool.not6 = icmp eq %struct.io_kiocb* %req, null
  br i1 %tobool.not6, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %seq.08 = phi i32 [ %dec, %for.body ], [ %1, %entry ]
  %req.addr.07 = phi %struct.io_kiocb* [ %2, %for.body ], [ %req, %entry ]
  %dec = add i32 %seq.08, -1
  %link = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.addr.07, i64 0, i32 11
  %2 = load %struct.io_kiocb*, %struct.io_kiocb** %link, align 8
  %tobool.not = icmp eq %struct.io_kiocb* %2, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %seq.0.lcssa = phi i32 [ %1, %entry ], [ %dec, %for.body ]
  ret i32 %seq.0.lcssa
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @blk_finish_plug(%struct.blk_plug* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @timespec64_to_jiffies(%struct.timespec64* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @set_user_sigmask(%struct.sigset_t* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal i32 @io_wake_function(%struct.wait_queue_entry* noundef %curr, i32 noundef %mode, i32 noundef %wake_flags, i8* noundef %key) #1 {
entry:
  %0 = bitcast %struct.wait_queue_entry* %curr to %struct.io_wait_queue*
  %call = call fastcc i1 @io_should_wake(%struct.io_wait_queue* noundef %0) #25
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %ctx = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %curr, i64 1
  %1 = bitcast %struct.wait_queue_entry* %ctx to %struct.io_ring_ctx**
  %2 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %1, align 8
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %2, i64 0, i32 8
  %3 = load volatile i64, i64* %check_cq_overflow, align 8
  %conv.i7 = and i64 %3, 1
  %tobool.not = icmp eq i64 %conv.i7, 0
  br i1 %tobool.not, label %cleanup, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call2 = call i32 @autoremove_wake_function(%struct.wait_queue_entry* noundef %curr, i32 noundef %mode, i32 noundef %wake_flags, i8* noundef %key) #27
  br label %cleanup

cleanup:                                          ; preds = %lor.lhs.false, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ -1, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @prepare_to_wait_exclusive(%struct.wait_queue_head* noundef, %struct.wait_queue_entry* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_cqring_wait_schedule(%struct.io_ring_ctx* noundef %ctx, %struct.io_wait_queue* nocapture noundef readonly %iowq, i64* nocapture noundef %timeout) unnamed_addr #1 {
entry:
  %call = call fastcc i32 @io_run_task_work_sig() #25
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %call1 = call fastcc i1 @io_should_wake(%struct.io_wait_queue* noundef %iowq) #25
  br i1 %call1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %check_cq_overflow = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 8
  %0 = load volatile i64, i64* %check_cq_overflow, align 8
  %conv.i12 = and i64 %0, 1
  %tobool3.not = icmp eq i64 %conv.i12, 0
  br i1 %tobool3.not, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %1 = load i64, i64* %timeout, align 8
  %call6 = call i64 @schedule_timeout(i64 noundef %1) #27
  store i64 %call6, i64* %timeout, align 8
  %tobool7.not = icmp eq i64 %call6, 0
  %cond = select i1 %tobool7.not, i32 -62, i32 1
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %lor.lhs.false, %if.end5
  %retval.0 = phi i32 [ %cond, %if.end5 ], [ 0, %lor.lhs.false ], [ %call, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @restore_saved_sigmask_unless(i1 noundef %interrupted) unnamed_addr #1 {
entry:
  br i1 %interrupted, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %call1 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %1) #25
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.then11, label %if.end19, !prof !24

if.then11:                                        ; preds = %if.then
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22include/linux/sched/signal.h\22; .popsection; .long 14472b - 14470b; .short 515; .short (1 << 0)|(((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !116
  br label %if.end19

if.else:                                          ; preds = %entry
  call fastcc void @restore_saved_sigmask() #25
  br label %if.end19

if.end19:                                         ; preds = %if.then, %if.then11, %if.else
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @io_should_wake(%struct.io_wait_queue* nocapture noundef readonly %iowq) unnamed_addr #8 {
entry:
  %ctx1 = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 1
  %0 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx1, align 8
  %cached_cq_tail = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 0
  %1 = load i32, i32* %cached_cq_tail, align 64
  %cq_tail = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 2
  %2 = load i32, i32* %cq_tail, align 8
  %sub = sub i32 %1, %2
  %cmp = icmp sgt i32 %sub, -1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %counter.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %0, i64 0, i32 10, i32 6, i32 0
  %3 = load volatile i32, i32* %counter.i, align 4
  %nr_timeouts = getelementptr inbounds %struct.io_wait_queue, %struct.io_wait_queue* %iowq, i64 0, i32 3
  %4 = load i32, i32* %nr_timeouts, align 4
  %cmp2 = icmp ne i32 %3, %4
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_run_task_work_sig() unnamed_addr #1 {
entry:
  %call = call fastcc i1 @io_run_task_work() #25
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %call2 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %1) #25
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %2 = getelementptr %struct.task_struct, %struct.task_struct* %1, i64 0, i32 0
  %call6 = call fastcc i32 @test_ti_thread_flag(%struct.thread_info* noundef %2, i32 noundef 6) #25
  %tobool7.not = icmp eq i32 %call6, 0
  %. = select i1 %tobool7.not, i32 -4, i32 -512
  br label %return

return:                                           ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.end ], [ %., %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @schedule_timeout(i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @restore_saved_sigmask() unnamed_addr #1 {
entry:
  %call = call fastcc i1 @test_and_clear_restore_sigmask() #25
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %saved_sigmask = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 91
  call void @__set_current_blocked(%struct.sigset_t* noundef %saved_sigmask) #27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @test_and_clear_restore_sigmask() unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %2 = getelementptr %struct.task_struct, %struct.task_struct* %1, i64 0, i32 0
  %call1 = call fastcc i32 @test_and_clear_ti_thread_flag(%struct.thread_info* noundef %2) #25
  %tobool = icmp ne i32 %call1, 0
  ret i1 %tobool
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__set_current_blocked(%struct.sigset_t* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @test_and_clear_ti_thread_flag(%struct.thread_info* noundef %ti) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i64 0, i32 0
  %call = call fastcc i1 @test_and_clear_bit(i64* noundef %flags) #25
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @test_and_clear_bit(i64* noundef %addr) unnamed_addr #1 {
entry:
  %0 = load volatile i64, i64* %addr, align 8
  %and.i = and i64 %0, 1048576
  %tobool.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i, label %arch_test_and_clear_bit.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %1 = bitcast i64* %addr to %struct.atomic64_t*
  %call.i.i.i = call fastcc i64 @__ll_sc_atomic64_fetch_andnot(%struct.atomic64_t* noundef %1) #27
  %2 = and i64 %call.i.i.i, 1048576
  %phi.cmp = icmp ne i64 %2, 0
  br label %arch_test_and_clear_bit.exit

arch_test_and_clear_bit.exit:                     ; preds = %entry, %if.end.i
  %retval.0.i = phi i1 [ %phi.cmp, %if.end.i ], [ false, %entry ]
  ret i1 %retval.0.i
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__ll_sc_atomic64_fetch_andnot(%struct.atomic64_t* noundef %v) unnamed_addr #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i64 0, i32 0
  %0 = call { i64, i64, i64 } asm sideeffect "// atomic64_fetch_andnot\0A\09prfm\09pstl1strm, $3\0A1:\09ldxr\09$0, $3\0A\09bic\09$1, $0, $4\0A\09stlxr\09${2:w}, $1, $3\0A\09cbnz\09${2:w}, 1b\0A\09dmb ish", "=&r,=&r,=&r,=*Q,r,*Q,~{memory}"(i64* elementtype(i64) %counter, i64 1048576, i64* elementtype(i64) %counter) #26, !srcloc !117
  %asmresult = extractvalue { i64, i64, i64 } %0, 0
  ret i64 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__do_sys_io_uring_setup(i32 noundef %entries, %struct.io_uring_params* noundef %params) unnamed_addr #1 {
entry:
  %call = call fastcc i64 @io_uring_setup(i32 noundef %entries, %struct.io_uring_params* noundef %params) #25
  ret i64 %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @io_uring_setup(i32 noundef %entries, %struct.io_uring_params* noundef %params) unnamed_addr #1 {
entry:
  %p = alloca %struct.io_uring_params, align 8
  %0 = bitcast %struct.io_uring_params* %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 120, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(120) %0, i8 0, i64 120, i1 false), !annotation !14
  %1 = bitcast %struct.io_uring_params* %params to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %1, i64 noundef 120) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  br i1 %tobool.not, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 7, i64 0
  %2 = load i32, i32* %arrayidx, align 4
  %tobool2.not = icmp eq i32 %2, 0
  %arrayidx.1 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 7, i64 1
  %3 = load i32, i32* %arrayidx.1, align 8
  %tobool2.not.1 = icmp eq i32 %3, 0
  %or.cond = select i1 %tobool2.not, i1 %tobool2.not.1, i1 false
  %arrayidx.2 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 7, i64 2
  %4 = load i32, i32* %arrayidx.2, align 4
  %tobool2.not.2 = icmp eq i32 %4, 0
  %or.cond18 = select i1 %or.cond, i1 %tobool2.not.2, i1 false
  %flags = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %5 = load i32, i32* %flags, align 8
  %tobool5.not = icmp ult i32 %5, 128
  %or.cond19 = select i1 %or.cond18, i1 %tobool5.not, i1 false
  br i1 %or.cond19, label %if.end7, label %cleanup

if.end7:                                          ; preds = %for.body.preheader
  %call8 = call fastcc i32 @io_uring_create(i32 noundef %entries, %struct.io_uring_params* noundef nonnull %p, %struct.io_uring_params* noundef %params) #25
  %conv9 = sext i32 %call8 to i64
  br label %cleanup

cleanup:                                          ; preds = %for.body.preheader, %entry, %if.end7
  %retval.0 = phi i64 [ %conv9, %if.end7 ], [ -14, %entry ], [ -22, %for.body.preheader ]
  call void @llvm.lifetime.end.p0i8(i64 120, i8* nonnull %0) #26
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_uring_create(i32 noundef %entries, %struct.io_uring_params* noundef %p, %struct.io_uring_params* noundef %params) unnamed_addr #1 {
entry:
  %tobool.not = icmp eq i32 %entries, 0
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i32 %entries, 32768
  br i1 %cmp, label %if.then1, label %cond.end24

if.then1:                                         ; preds = %if.end
  %flags = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 16
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %cleanup, label %cond.end24

cond.end24:                                       ; preds = %if.then1, %if.end
  %entries.addr.0 = phi i32 [ %entries, %if.end ], [ 32768, %if.then1 ]
  %conv22 = zext i32 %entries.addr.0 to i64
  %call23 = call fastcc i64 @__roundup_pow_of_two(i64 noundef %conv22) #31
  %conv26 = trunc i64 %call23 to i32
  %sq_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 0
  store i32 %conv26, i32* %sq_entries, align 8
  %flags27 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %1 = load i32, i32* %flags27, align 8
  %and28 = and i32 %1, 8
  %tobool29.not = icmp eq i32 %and28, 0
  br i1 %tobool29.not, label %if.else, label %if.then30

if.then30:                                        ; preds = %cond.end24
  %cq_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 1
  %2 = load i32, i32* %cq_entries, align 4
  %tobool31.not = icmp eq i32 %2, 0
  br i1 %tobool31.not, label %cleanup, label %if.end33

if.end33:                                         ; preds = %if.then30
  %cmp35 = icmp ugt i32 %2, 65536
  br i1 %cmp35, label %if.then37, label %cond.end83

if.then37:                                        ; preds = %if.end33
  %and39 = and i32 %1, 16
  %tobool40.not = icmp eq i32 %and39, 0
  br i1 %tobool40.not, label %cleanup, label %cond.end83

cond.end83:                                       ; preds = %if.then37, %if.end33
  %3 = phi i32 [ %2, %if.end33 ], [ 65536, %if.then37 ]
  %conv81 = zext i32 %3 to i64
  %call82 = call fastcc i64 @__roundup_pow_of_two(i64 noundef %conv81) #31
  %conv85 = trunc i64 %call82 to i32
  store i32 %conv85, i32* %cq_entries, align 4
  %cmp89 = icmp ugt i32 %conv26, %conv85
  br i1 %cmp89, label %cleanup, label %if.end95

if.else:                                          ; preds = %cond.end24
  %mul = shl i32 %conv26, 1
  %cq_entries94 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 1
  store i32 %mul, i32* %cq_entries94, align 4
  br label %if.end95

if.end95:                                         ; preds = %cond.end83, %if.else
  %call96 = call fastcc %struct.io_ring_ctx* @io_ring_ctx_alloc(%struct.io_uring_params* noundef %p) #25
  %tobool97.not = icmp eq %struct.io_ring_ctx* %call96, null
  br i1 %tobool97.not, label %cleanup, label %if.end99

if.end99:                                         ; preds = %if.end95
  %compat = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %call96, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %compat, align 4
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %compat, align 4
  %call102 = call i1 @capable(i32 noundef 14) #27
  br i1 %call102, label %if.end108, label %do.end

do.end:                                           ; preds = %if.end99
  %4 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %5 = inttoptr i64 %4 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i64 0, i32 80
  %6 = load %struct.cred*, %struct.cred** %cred, align 8
  %user = getelementptr inbounds %struct.cred, %struct.cred* %6, i64 0, i32 15
  %7 = load %struct.user_struct*, %struct.user_struct** %user, align 8
  %call106 = call fastcc %struct.user_struct* @get_uid(%struct.user_struct* noundef %7) #25
  %user107 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %call96, i64 0, i32 14, i32 1
  store %struct.user_struct* %7, %struct.user_struct** %user107, align 8
  br label %if.end108

if.end108:                                        ; preds = %if.end99, %do.end
  %8 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %9 = inttoptr i64 %8 to %struct.task_struct*
  %mm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %9, i64 0, i32 35
  %10 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  call fastcc void @mmgrab(%struct.mm_struct* noundef %10) #25
  %11 = load %struct.mm_struct*, %struct.mm_struct** %mm, align 8
  %mm_account = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %call96, i64 0, i32 14, i32 2
  store %struct.mm_struct* %11, %struct.mm_struct** %mm_account, align 16
  %call112 = call fastcc i32 @io_allocate_scq_urings(%struct.io_ring_ctx* noundef nonnull %call96, %struct.io_uring_params* noundef %p) #25
  %tobool113.not = icmp eq i32 %call112, 0
  br i1 %tobool113.not, label %if.end115, label %err

if.end115:                                        ; preds = %if.end108
  %call116 = call fastcc i32 @io_sq_offload_create(%struct.io_ring_ctx* noundef nonnull %call96, %struct.io_uring_params* noundef %p) #25
  %tobool117.not = icmp eq i32 %call116, 0
  br i1 %tobool117.not, label %if.end119, label %err

if.end119:                                        ; preds = %if.end115
  %call120 = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef nonnull %call96) #25
  %tobool121.not = icmp eq i32 %call120, 0
  br i1 %tobool121.not, label %if.end123, label %err

if.end123:                                        ; preds = %if.end119
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef nonnull %call96, %struct.io_rsrc_data* noundef null) #25
  %sq_off = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8
  %12 = bitcast %struct.io_sqring_offsets* %sq_off to i8*
  %call124 = call i8* @memset(i8* noundef %12, i32 noundef 0, i64 noundef 40) #27
  %head = getelementptr inbounds %struct.io_sqring_offsets, %struct.io_sqring_offsets* %sq_off, i64 0, i32 0
  store i32 0, i32* %head, align 8
  %tail = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 1
  store i32 64, i32* %tail, align 4
  %ring_mask = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 2
  store i32 256, i32* %ring_mask, align 8
  %ring_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 3
  store i32 264, i32* %ring_entries, align 4
  %flags130 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 4
  store i32 276, i32* %flags130, align 8
  %dropped = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 5
  store i32 272, i32* %dropped, align 4
  %sq_array = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %call96, i64 0, i32 1, i32 1
  %13 = bitcast i32** %sq_array to i8**
  %14 = load i8*, i8** %13, align 32
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %call96, i64 0, i32 0, i32 1
  %15 = bitcast %struct.io_rings** %rings to i8**
  %16 = load i8*, i8** %15, align 16
  %sub.ptr.lhs.cast = ptrtoint i8* %14 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %16 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv132 = trunc i64 %sub.ptr.sub to i32
  %array = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 8, i32 6
  store i32 %conv132, i32* %array, align 8
  %cq_off = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9
  %17 = bitcast %struct.io_cqring_offsets* %cq_off to i8*
  %call134 = call i8* @memset(i8* noundef %17, i32 noundef 0, i64 noundef 40) #27
  %head136 = getelementptr inbounds %struct.io_cqring_offsets, %struct.io_cqring_offsets* %cq_off, i64 0, i32 0
  store i32 128, i32* %head136, align 8
  %tail138 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 1
  store i32 192, i32* %tail138, align 4
  %ring_mask140 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 2
  store i32 260, i32* %ring_mask140, align 8
  %ring_entries142 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 3
  store i32 268, i32* %ring_entries142, align 4
  %overflow = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 4
  store i32 284, i32* %overflow, align 8
  %cqes = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 5
  store i32 320, i32* %cqes, align 4
  %flags146 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 9, i32 6
  store i32 280, i32* %flags146, align 8
  %features = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 5
  store i32 2047, i32* %features, align 4
  %18 = bitcast %struct.io_uring_params* %params to i8*
  %19 = bitcast %struct.io_uring_params* %p to i8*
  %call2.i = call fastcc i64 @_copy_to_user(i8* noundef %18, i8* noundef %19, i64 noundef 120) #27
  %tobool148.not = icmp eq i64 %call2.i, 0
  br i1 %tobool148.not, label %if.end150, label %err

if.end150:                                        ; preds = %if.end123
  %call151 = call fastcc %struct.file* @io_uring_get_file(%struct.io_ring_ctx* noundef nonnull %call96) #25
  %20 = bitcast %struct.file* %call151 to i8*
  %call152 = call fastcc i1 @IS_ERR(i8* noundef %20) #25
  br i1 %call152, label %if.then153, label %if.end156

if.then153:                                       ; preds = %if.end150
  %call154 = call fastcc i64 @PTR_ERR(i8* noundef %20) #25
  %conv155 = trunc i64 %call154 to i32
  br label %err

if.end156:                                        ; preds = %if.end150
  %call157 = call fastcc i32 @io_uring_install_fd(%struct.io_ring_ctx* noundef nonnull %call96, %struct.file* noundef %call151) #25
  %cmp158 = icmp slt i32 %call157, 0
  br i1 %cmp158, label %if.then160, label %cleanup

if.then160:                                       ; preds = %if.end156
  call void @fput(%struct.file* noundef %call151) #27
  br label %cleanup

err:                                              ; preds = %if.end123, %if.end119, %if.end115, %if.end108, %if.then153
  %ret.0 = phi i32 [ %call112, %if.end108 ], [ %call116, %if.end115 ], [ %call120, %if.end119 ], [ %conv155, %if.then153 ], [ -14, %if.end123 ]
  call fastcc void @io_ring_ctx_wait_and_kill(%struct.io_ring_ctx* noundef nonnull %call96) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end156, %if.end95, %cond.end83, %if.then37, %if.then30, %if.then1, %entry, %err, %if.then160
  %retval.0 = phi i32 [ %ret.0, %err ], [ %call157, %if.then160 ], [ -22, %entry ], [ -22, %if.then1 ], [ -22, %if.then30 ], [ -22, %if.then37 ], [ -22, %cond.end83 ], [ -12, %if.end95 ], [ %call157, %if.end156 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @__ilog2_u32(i32 noundef %n) unnamed_addr #19 {
entry:
  %tobool.not.i = icmp eq i32 %n, 0
  %0 = call i32 @llvm.ctlz.i32(i32 %n, i1 false) #26, !range !118
  %narrow.i.op = sub nsw i32 31, %0
  %sub = select i1 %tobool.not.i, i32 -1, i32 %narrow.i.op
  ret i32 %sub
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @__roundup_pow_of_two(i64 noundef %n) unnamed_addr #19 {
entry:
  %sub = add i64 %n, -1
  %call = call fastcc i32 @fls_long(i64 noundef %sub) #25
  %sh_prom = zext i32 %call to i64
  %shl = shl nuw i64 1, %sh_prom
  ret i64 %shl
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_ring_ctx* @io_ring_ctx_alloc(%struct.io_uring_params* nocapture noundef readonly %p) unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kzalloc(i64 noundef 1664, i32 noundef 3264) #25
  %0 = bitcast i8* %call to %struct.io_ring_ctx*
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup, label %cond.end7

cond.end7:                                        ; preds = %entry
  %cq_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 1
  %1 = load i32, i32* %cq_entries, align 4
  %call6 = call fastcc i32 @__ilog2_u32(i32 noundef %1) #31
  %sub9 = add i32 %call6, -5
  %2 = icmp sgt i32 %sub9, 1
  %spec.store.select = select i1 %2, i32 %sub9, i32 1
  %3 = getelementptr inbounds i8, i8* %call, i64 1152
  %cancel_hash_bits = getelementptr inbounds i8, i8* %call, i64 1184
  %4 = bitcast i8* %cancel_hash_bits to i32*
  store i32 %spec.store.select, i32* %4, align 32
  %shl = shl nuw i32 1, %spec.store.select
  %conv14 = zext i32 %shl to i64
  %mul = shl nuw nsw i64 %conv14, 3
  %call10.i = call noalias align 128 i8* @__kmalloc(i64 noundef %mul, i32 noundef 3264) #27
  %cancel_hash = getelementptr inbounds i8, i8* %call, i64 1176
  %5 = bitcast i8* %cancel_hash to i8**
  store i8* %call10.i, i8** %5, align 8
  %tobool17.not = icmp eq i8* %call10.i, null
  br i1 %tobool17.not, label %err, label %if.end19

if.end19:                                         ; preds = %cond.end7
  %6 = bitcast i8* %call10.i to %struct.hlist_head*
  call fastcc void @__hash_init(%struct.hlist_head* noundef nonnull %6, i32 noundef %shl) #25
  %call22 = call fastcc i8* @kzalloc(i64 noundef 32, i32 noundef 3264) #25
  %dummy_ubuf = getelementptr inbounds i8, i8* %call, i64 1248
  %7 = bitcast i8* %dummy_ubuf to i8**
  store i8* %call22, i8** %7, align 8
  %tobool24.not = icmp eq i8* %call22, null
  br i1 %tobool24.not, label %err, label %if.end26

if.end26:                                         ; preds = %if.end19
  %ubuf = bitcast i8* %call22 to i64*
  store i64 -1, i64* %ubuf, align 8
  %refs = bitcast i8* %call to %struct.percpu_ref*
  %call28 = call i32 @percpu_ref_init(%struct.percpu_ref* noundef nonnull %refs, void (%struct.percpu_ref*)* noundef nonnull @io_ring_ctx_ref_free, i32 noundef 4, i32 noundef 3264) #27
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.end31, label %err

if.end31:                                         ; preds = %if.end26
  %flags = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %8 = load i32, i32* %flags, align 8
  %flags32 = getelementptr inbounds i8, i8* %call, i64 24
  %9 = bitcast i8* %flags32 to i32*
  store i32 %8, i32* %9, align 8
  %sqo_sq_wait = getelementptr inbounds i8, i8* %call, i64 936
  %10 = bitcast i8* %sqo_sq_wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %10, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.27, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_ring_ctx_alloc.__key) #27
  %sqd_list = getelementptr inbounds i8, i8* %call, i64 960
  %11 = bitcast i8* %sqd_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %11) #25
  %poll_wait = getelementptr inbounds i8, i8* %call, i64 1040
  %12 = bitcast i8* %poll_wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %12, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.29, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_ring_ctx_alloc.__key.28) #27
  %13 = getelementptr inbounds i8, i8* %call, i64 64
  %cq_overflow_list = getelementptr inbounds i8, i8* %call, i64 808
  %14 = bitcast i8* %cq_overflow_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %14) #25
  %ref_comp = getelementptr inbounds i8, i8* %call, i64 1560
  %15 = bitcast i8* %ref_comp to %struct.completion*
  call fastcc void @init_completion(%struct.completion* noundef %15) #25
  %io_buffers = getelementptr inbounds i8, i8* %call, i64 824
  %16 = bitcast i8* %io_buffers to %struct.xarray*
  call fastcc void @xa_init_flags(%struct.xarray* noundef %16, i32 noundef 12) #25
  %personalities = getelementptr inbounds i8, i8* %call, i64 840
  %17 = bitcast i8* %personalities to %struct.xarray*
  call fastcc void @xa_init_flags(%struct.xarray* noundef %17, i32 noundef 12) #25
  %uring_lock = bitcast i8* %13 to %struct.mutex*
  call void @__mutex_init(%struct.mutex* noundef %uring_lock, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.31, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_ring_ctx_alloc.__key.30) #27
  %cq_wait = getelementptr inbounds i8, i8* %call, i64 1064
  %18 = bitcast i8* %cq_wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %18, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.33, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_ring_ctx_alloc.__key.32) #27
  %19 = bitcast i8* %3 to i32*
  store i32 0, i32* %19, align 64
  %timeout_lock = getelementptr inbounds i8, i8* %call, i64 1156
  %20 = bitcast i8* %timeout_lock to i32*
  store i32 0, i32* %20, align 4
  %iopoll_list = getelementptr inbounds i8, i8* %call, i64 1160
  %21 = bitcast i8* %iopoll_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %21) #25
  %defer_list = getelementptr inbounds i8, i8* %call, i64 120
  %22 = bitcast i8* %defer_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %22) #25
  %timeout_list = getelementptr inbounds i8, i8* %call, i64 776
  %23 = bitcast i8* %timeout_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %23) #25
  %ltimeout_list = getelementptr inbounds i8, i8* %call, i64 792
  %24 = bitcast i8* %ltimeout_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %24) #25
  %rsrc_ref_lock = getelementptr inbounds i8, i8* %call, i64 1384
  %25 = bitcast i8* %rsrc_ref_lock to i32*
  store i32 0, i32* %25, align 8
  %rsrc_ref_list = getelementptr inbounds i8, i8* %call, i64 1368
  %26 = bitcast i8* %rsrc_ref_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %26) #25
  %.compoundliteral71.sroa.0.0..sroa_idx = getelementptr inbounds i8, i8* %call, i64 1272
  %27 = bitcast i8* %.compoundliteral71.sroa.0.0..sroa_idx to i64*
  store i64 68719476704, i64* %27, align 8
  %entry75 = getelementptr inbounds i8, i8* %call, i64 1280
  %28 = bitcast i8* %entry75 to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %28) #25
  %func = getelementptr inbounds i8, i8* %call, i64 1296
  %29 = bitcast i8* %func to void (%struct.work_struct*)**
  store void (%struct.work_struct*)* @io_rsrc_put_work, void (%struct.work_struct*)** %29, align 8
  %timer = getelementptr inbounds i8, i8* %call, i64 1304
  %30 = bitcast i8* %timer to %struct.timer_list*
  call void @init_timer_key(%struct.timer_list* noundef %30, void (%struct.timer_list*)* noundef nonnull @delayed_work_timer_fn, i32 noundef 2097152, i8* noundef null, %struct.lock_class_key* noundef null) #27
  %rsrc_put_llist = getelementptr inbounds i8, i8* %call, i64 1360
  %31 = bitcast i8* %rsrc_put_llist to %struct.llist_head*
  call fastcc void @init_llist_head(%struct.llist_head* noundef %31) #25
  %tctx_list = getelementptr inbounds i8, i8* %call, i64 1544
  %32 = bitcast i8* %tctx_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %32) #25
  %free_list = getelementptr inbounds i8, i8* %call, i64 752
  %33 = bitcast i8* %free_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %33) #25
  %locked_free_list = getelementptr inbounds i8, i8* %call, i64 896
  %34 = bitcast i8* %locked_free_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %34) #25
  %.compoundliteral89.sroa.0.0..sroa_idx = getelementptr inbounds i8, i8* %call, i64 1424
  %35 = bitcast i8* %.compoundliteral89.sroa.0.0..sroa_idx to i64*
  store i64 68719476704, i64* %35, align 16
  %entry93 = getelementptr inbounds i8, i8* %call, i64 1432
  %36 = bitcast i8* %entry93 to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %36) #25
  %func96 = getelementptr inbounds i8, i8* %call, i64 1448
  %37 = bitcast i8* %func96 to void (%struct.work_struct*)**
  store void (%struct.work_struct*)* @io_fallback_req_func, void (%struct.work_struct*)** %37, align 8
  %timer100 = getelementptr inbounds i8, i8* %call, i64 1456
  %38 = bitcast i8* %timer100 to %struct.timer_list*
  call void @init_timer_key(%struct.timer_list* noundef %38, void (%struct.timer_list*)* noundef nonnull @delayed_work_timer_fn, i32 noundef 2097152, i8* noundef null, %struct.lock_class_key* noundef null) #27
  br label %cleanup

err:                                              ; preds = %cond.end7, %if.end26, %if.end19
  %dummy_ubuf103 = getelementptr inbounds i8, i8* %call, i64 1248
  %39 = bitcast i8* %dummy_ubuf103 to i8**
  %40 = load i8*, i8** %39, align 8
  call void @kfree(i8* noundef %40) #27
  %41 = load i8*, i8** %5, align 8
  call void @kfree(i8* noundef %41) #27
  call void @kfree(i8* noundef nonnull %call) #27
  br label %cleanup

cleanup:                                          ; preds = %entry, %err, %if.end31
  %retval.0 = phi %struct.io_ring_ctx* [ null, %err ], [ %0, %if.end31 ], [ null, %entry ]
  ret %struct.io_ring_ctx* %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @capable(i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.user_struct* @get_uid(%struct.user_struct* noundef returned %u) unnamed_addr #1 {
entry:
  %__count = getelementptr inbounds %struct.user_struct, %struct.user_struct* %u, i64 0, i32 0
  call fastcc void @refcount_inc(%struct.refcount_struct* noundef %__count) #25
  ret %struct.user_struct* %u
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @mmgrab(%struct.mm_struct* noundef %mm) unnamed_addr #1 {
entry:
  %mm_count = getelementptr inbounds %struct.mm_struct, %struct.mm_struct* %mm, i64 0, i32 0, i32 11
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %mm_count) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_allocate_scq_urings(%struct.io_ring_ctx* nocapture noundef %ctx, %struct.io_uring_params* nocapture noundef readonly %p) unnamed_addr #1 {
entry:
  %sq_array_offset = alloca i64, align 8
  %0 = bitcast i64* %sq_array_offset to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64 0, i64* %sq_array_offset, align 8, !annotation !14
  %sq_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 0
  %1 = load i32, i32* %sq_entries, align 8
  %sq_entries1 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 4
  store i32 %1, i32* %sq_entries1, align 4
  %cq_entries = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 1
  %2 = load i32, i32* %cq_entries, align 4
  %cq_entries2 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 1
  store i32 %2, i32* %cq_entries2, align 4
  %3 = load i32, i32* %sq_entries, align 8
  %4 = load i32, i32* %cq_entries, align 4
  %call = call fastcc i64 @rings_size(i32 noundef %3, i32 noundef %4, i64* noundef nonnull %sq_array_offset) #25
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call5 = call fastcc i8* @io_mem_alloc(i64 noundef %call) #25
  %tobool.not = icmp eq i8* %call5, null
  br i1 %tobool.not, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %rings8 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %5 = bitcast %struct.io_rings** %rings8 to i8**
  store i8* %call5, i8** %5, align 16
  %6 = load i64, i64* %sq_array_offset, align 8
  %add.ptr = getelementptr i8, i8* %call5, i64 %6
  %sq_array = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 1
  %7 = bitcast i32** %sq_array to i8**
  store i8* %add.ptr, i8** %7, align 32
  %8 = load i32, i32* %sq_entries, align 8
  %sub = add i32 %8, -1
  %sq_ring_mask = getelementptr inbounds i8, i8* %call5, i64 256
  %9 = bitcast i8* %sq_ring_mask to i32*
  store i32 %sub, i32* %9, align 64
  %10 = load i32, i32* %cq_entries, align 4
  %sub11 = add i32 %10, -1
  %cq_ring_mask = getelementptr inbounds i8, i8* %call5, i64 260
  %11 = bitcast i8* %cq_ring_mask to i32*
  store i32 %sub11, i32* %11, align 4
  %12 = load i32, i32* %sq_entries, align 8
  %sq_ring_entries = getelementptr inbounds i8, i8* %call5, i64 264
  %13 = bitcast i8* %sq_ring_entries to i32*
  store i32 %12, i32* %13, align 8
  %14 = load i32, i32* %cq_entries, align 4
  %cq_ring_entries = getelementptr inbounds i8, i8* %call5, i64 268
  %15 = bitcast i8* %cq_ring_entries to i32*
  store i32 %14, i32* %15, align 4
  %16 = load i32, i32* %sq_entries, align 8
  %conv = zext i32 %16 to i64
  %call15 = call fastcc i64 @array_size(i64 noundef 64, i64 noundef %conv) #25
  %cmp16 = icmp eq i64 %call15, -1
  br i1 %cmp16, label %cleanup.sink.split, label %if.end21

if.end21:                                         ; preds = %if.end7
  %call22 = call fastcc i8* @io_mem_alloc(i64 noundef %call15) #25
  %sq_sqes = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 2
  %17 = bitcast %struct.io_uring_sqe** %sq_sqes to i8**
  store i8* %call22, i8** %17, align 8
  %tobool24.not = icmp eq i8* %call22, null
  br i1 %tobool24.not, label %cleanup.sink.split, label %cleanup

cleanup.sink.split:                               ; preds = %if.end21, %if.end7
  %retval.0.ph = phi i32 [ -75, %if.end7 ], [ -12, %if.end21 ]
  %18 = load i8*, i8** %5, align 16
  call fastcc void @io_mem_free(i8* noundef %18) #25
  store %struct.io_rings* null, %struct.io_rings** %rings8, align 16
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %if.end21, %if.end, %entry
  %retval.0 = phi i32 [ -75, %entry ], [ -12, %if.end ], [ 0, %if.end21 ], [ %retval.0.ph, %cleanup.sink.split ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sq_offload_create(%struct.io_ring_ctx* noundef %ctx, %struct.io_uring_params* nocapture noundef readonly %p) unnamed_addr #1 {
entry:
  %attached = alloca i8, align 4
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 34
  %cmp = icmp eq i32 %and, 32
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %wq_fd = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 6
  %1 = load i32, i32* %wq_fd, align 8
  %call = call fastcc [2 x i64] @fdget(i32 noundef %1) #25
  %call.fca.0.extract = extractvalue [2 x i64] %call, 0
  %tobool.not = icmp eq i64 %call.fca.0.extract, 0
  br i1 %tobool.not, label %cleanup77, label %if.end

if.end:                                           ; preds = %if.then
  %2 = inttoptr i64 %call.fca.0.extract to %struct.file*
  %f_op = getelementptr inbounds %struct.file, %struct.file* %2, i64 0, i32 3
  %3 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp3.not = icmp eq %struct.file_operations* %3, @io_uring_fops
  call fastcc void @fdput([2 x i64] %call) #25
  br i1 %cmp3.not, label %cleanup, label %cleanup77

cleanup:                                          ; preds = %if.end
  %.pre = load i32, i32* %flags, align 8
  br label %if.end6

if.end6:                                          ; preds = %cleanup, %entry
  %4 = phi i32 [ %.pre, %cleanup ], [ %0, %entry ]
  %and8 = and i32 %4, 2
  %tobool9.not = icmp eq i32 %and8, 0
  br i1 %tobool9.not, label %if.else69, label %if.then10

if.then10:                                        ; preds = %if.end6
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %attached) #26
  store i8 0, i8* %attached, align 4, !annotation !14
  %call11 = call fastcc %struct.io_sq_data* @io_get_sq_data(%struct.io_uring_params* noundef %p, i8* noundef nonnull %attached) #25
  %5 = bitcast %struct.io_sq_data* %call11 to i8*
  %call12 = call fastcc i1 @IS_ERR(i8* noundef %5) #25
  br i1 %call12, label %if.then13, label %do.end

if.then13:                                        ; preds = %if.then10
  %call14 = call fastcc i64 @PTR_ERR(i8* noundef %5) #25
  %conv = trunc i64 %call14 to i32
  br label %cleanup64.thread

do.end:                                           ; preds = %if.then10
  %6 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %7 = inttoptr i64 %6 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %7, i64 0, i32 80
  %8 = load %struct.cred*, %struct.cred** %cred, align 8
  %call18 = call fastcc %struct.cred* @get_cred(%struct.cred* noundef %8) #25
  %sq_creds = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 4
  store %struct.cred* %call18, %struct.cred** %sq_creds, align 8
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  store %struct.io_sq_data* %call11, %struct.io_sq_data** %sq_data, align 32
  %sq_thread_idle = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 4
  %9 = load i32, i32* %sq_thread_idle, align 8
  %call2.i = call i64 @__msecs_to_jiffies(i32 noundef %9) #27
  %conv20 = trunc i64 %call2.i to i32
  %sq_thread_idle21 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 18
  %tobool23.not = icmp eq i32 %conv20, 0
  %spec.select = select i1 %tobool23.not, i32 250, i32 %conv20
  store i32 %spec.select, i32* %sq_thread_idle21, align 4
  call fastcc void @io_sq_thread_park(%struct.io_sq_data* noundef %call11) #25
  %sqd_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 7
  %ctx_list = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 3
  call fastcc void @list_add(%struct.list_head* noundef %sqd_list, %struct.list_head* noundef %ctx_list) #25
  call fastcc void @io_sqd_update_thread_idle(%struct.io_sq_data* noundef %call11) #25
  %10 = load i8, i8* %attached, align 4, !range !18
  %tobool27.not = icmp eq i8 %10, 0
  br i1 %tobool27.not, label %if.end36, label %land.end

land.end:                                         ; preds = %do.end
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 4
  %11 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool29.not = icmp eq %struct.task_struct* %11, null
  call fastcc void @io_sq_thread_unpark(%struct.io_sq_data* noundef %call11) #25
  br i1 %tobool29.not, label %cleanup64.thread, label %cleanup64.thread153

cleanup64.thread153:                              ; preds = %land.end
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %attached) #26
  br label %cleanup77

if.end36:                                         ; preds = %do.end
  call fastcc void @io_sq_thread_unpark(%struct.io_sq_data* noundef %call11) #25
  %flags37 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %12 = load i32, i32* %flags37, align 8
  %and38 = and i32 %12, 4
  %tobool39.not = icmp eq i32 %and38, 0
  br i1 %tobool39.not, label %if.end50, label %if.then40

if.then40:                                        ; preds = %if.end36
  %sq_thread_cpu = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 3
  %13 = load i32, i32* %sq_thread_cpu, align 4
  %14 = load i32, i32* @nr_cpu_ids, align 4
  %cmp41.not = icmp ult i32 %13, %14
  br i1 %cmp41.not, label %lor.lhs.false, label %err_sqpoll

lor.lhs.false:                                    ; preds = %if.then40
  %call43 = call fastcc i1 @cpu_online(i32 noundef %13) #25
  br i1 %call43, label %if.end50, label %err_sqpoll

if.end50:                                         ; preds = %if.end36, %lor.lhs.false
  %.sink = phi i32 [ %13, %lor.lhs.false ], [ -1, %if.end36 ]
  %sq_cpu = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 7
  store i32 %.sink, i32* %sq_cpu, align 4
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %7, i64 0, i32 50
  %15 = load i32, i32* %pid, align 32
  %task_pid = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 8
  store i32 %15, i32* %task_pid, align 8
  %tgid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %7, i64 0, i32 51
  %16 = load i32, i32* %tgid, align 4
  %task_tgid = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 9
  store i32 %16, i32* %task_tgid, align 4
  %call53 = call %struct.task_struct* @create_io_thread(i32 (i8*)* noundef nonnull @io_sq_thread, i8* noundef %5, i32 noundef -1) #27
  %17 = bitcast %struct.task_struct* %call53 to i8*
  %call54 = call fastcc i1 @IS_ERR(i8* noundef %17) #25
  br i1 %call54, label %if.then55, label %if.end58

if.then55:                                        ; preds = %if.end50
  %call56 = call fastcc i64 @PTR_ERR(i8* noundef %17) #25
  %conv57 = trunc i64 %call56 to i32
  br label %err_sqpoll

if.end58:                                         ; preds = %if.end50
  %thread59 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %call11, i64 0, i32 4
  store %struct.task_struct* %call53, %struct.task_struct** %thread59, align 8
  %call60 = call fastcc i32 @io_uring_alloc_task_context(%struct.task_struct* noundef %call53, %struct.io_ring_ctx* noundef %ctx) #25
  call void @wake_up_new_task(%struct.task_struct* noundef %call53) #27
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %cleanup64, label %cleanup64.thread

cleanup64.thread:                                 ; preds = %land.end, %if.then13, %if.end58
  %ret.0.ph = phi i32 [ %call60, %if.end58 ], [ %conv, %if.then13 ], [ -6, %land.end ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %attached) #26
  br label %err

cleanup64:                                        ; preds = %if.end58
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %attached) #26
  br label %cleanup77

if.else69:                                        ; preds = %if.end6
  %flags70 = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %18 = load i32, i32* %flags70, align 8
  %and71 = and i32 %18, 4
  %tobool72.not = icmp eq i32 %and71, 0
  br i1 %tobool72.not, label %cleanup77, label %err

err_sqpoll:                                       ; preds = %if.then40, %lor.lhs.false, %if.then55
  %ret.0.ph147 = phi i32 [ %conv57, %if.then55 ], [ -22, %lor.lhs.false ], [ -22, %if.then40 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %attached) #26
  %19 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %exited = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %19, i64 0, i32 11
  call void @complete(%struct.completion* noundef %exited) #27
  br label %err

err:                                              ; preds = %cleanup64.thread, %if.else69, %err_sqpoll
  %ret.1 = phi i32 [ %ret.0.ph147, %err_sqpoll ], [ -22, %if.else69 ], [ %ret.0.ph, %cleanup64.thread ]
  call fastcc void @io_sq_thread_finish(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup77

cleanup77:                                        ; preds = %if.end, %if.then, %if.else69, %cleanup64, %cleanup64.thread153, %err
  %retval.3 = phi i32 [ %ret.1, %err ], [ 0, %cleanup64.thread153 ], [ 0, %cleanup64 ], [ 0, %if.else69 ], [ -6, %if.then ], [ -22, %if.end ]
  ret i32 %retval.3
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.file* @io_uring_get_file(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.io_ring_ctx* %ctx to i8*
  %call = call %struct.file* @anon_inode_getfile(i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.38, i64 0, i64 0), %struct.file_operations* noundef nonnull @io_uring_fops, i8* noundef %0, i32 noundef 524290) #27
  ret %struct.file* %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_uring_install_fd(%struct.io_ring_ctx* noundef %ctx, %struct.file* noundef %file) unnamed_addr #1 {
entry:
  %call = call i32 @get_unused_fd_flags(i32 noundef 524290) #27
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call fastcc i32 @io_uring_add_tctx_node(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  call void @put_unused_fd(i32 noundef %call) #27
  br label %cleanup

if.end3:                                          ; preds = %if.end
  call void @fd_install(i32 noundef %call, %struct.file* noundef %file) #27
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end3, %if.then2
  %retval.0 = phi i32 [ %call1, %if.then2 ], [ %call, %if.end3 ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #11

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i32 @fls_long(i64 noundef %l) unnamed_addr #19 {
entry:
  %cmp.i = icmp eq i64 %l, 0
  %0 = call i64 @llvm.ctlz.i64(i64 %l, i1 false) #26, !range !119
  %1 = trunc i64 %0 to i32
  %conv.i = sub nuw nsw i32 64, %1
  %retval.0.i = select i1 %cmp.i, i32 0, i32 %conv.i
  ret i32 %retval.0.i
}

; Function Attrs: nofree noinline norecurse nosync nounwind null_pointer_is_valid writeonly
define internal fastcc void @__hash_init(%struct.hlist_head* nocapture noundef writeonly %ht, i32 noundef %sz) unnamed_addr #20 {
entry:
  %cmp4.not = icmp eq i32 %sz, 0
  br i1 %cmp4.not, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %sz to i64
  %min.iters.check = icmp eq i32 %sz, 1
  br i1 %min.iters.check, label %for.body.preheader8, label %vector.ph

vector.ph:                                        ; preds = %for.body.preheader
  %n.vec = and i64 %wide.trip.count, 4294967294
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %induction7 = or i64 %index, 1
  %0 = getelementptr %struct.hlist_head, %struct.hlist_head* %ht, i64 %index, i32 0
  %1 = getelementptr %struct.hlist_head, %struct.hlist_head* %ht, i64 %induction7, i32 0
  store %struct.hlist_node* null, %struct.hlist_node** %0, align 8
  store %struct.hlist_node* null, %struct.hlist_node** %1, align 8
  %index.next = add nuw i64 %index, 2
  %2 = icmp eq i64 %index.next, %n.vec
  br i1 %2, label %middle.block, label %vector.body, !llvm.loop !120

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %for.end, label %for.body.preheader8

for.body.preheader8:                              ; preds = %for.body.preheader, %middle.block
  %indvars.iv.ph = phi i64 [ 0, %for.body.preheader ], [ %n.vec, %middle.block ]
  br label %for.body

for.body:                                         ; preds = %for.body.preheader8, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ %indvars.iv.ph, %for.body.preheader8 ]
  %first = getelementptr %struct.hlist_head, %struct.hlist_head* %ht, i64 %indvars.iv, i32 0
  store %struct.hlist_node* null, %struct.hlist_node** %first, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !122

for.end:                                          ; preds = %for.body, %middle.block, %entry
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_ring_ctx_ref_free(%struct.percpu_ref* noundef %ref) #1 {
entry:
  %ref_comp = getelementptr inbounds %struct.percpu_ref, %struct.percpu_ref* %ref, i64 97, i32 1
  %0 = bitcast %struct.percpu_ref_data** %ref_comp to %struct.completion*
  call void @complete(%struct.completion* noundef %0) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mutex_init(%struct.mutex* noundef, i8* noundef, %struct.lock_class_key* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_rsrc_put_work(%struct.work_struct* noundef %work) #1 {
entry:
  %add.ptr = getelementptr %struct.work_struct, %struct.work_struct* %work, i64 -40, i32 1
  %0 = getelementptr inbounds %struct.list_head, %struct.list_head* %add.ptr, i64 77, i32 1
  %rsrc_put_llist = getelementptr inbounds %struct.list_head*, %struct.list_head** %0, i64 15
  %1 = bitcast %struct.list_head** %rsrc_put_llist to %struct.llist_head*
  %call = call fastcc %struct.llist_node* @llist_del_all(%struct.llist_head* noundef %1) #25
  %tobool.not17 = icmp eq %struct.llist_node* %call, null
  br i1 %tobool.not17, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %node.018 = phi %struct.llist_node* [ %2, %while.body ], [ %call, %entry ]
  %next1 = getelementptr inbounds %struct.llist_node, %struct.llist_node* %node.018, i64 0, i32 0
  %2 = load %struct.llist_node*, %struct.llist_node** %next1, align 8
  %add.ptr716 = getelementptr %struct.llist_node, %struct.llist_node* %node.018, i64 -7
  %3 = bitcast %struct.llist_node* %add.ptr716 to %struct.io_rsrc_node*
  call fastcc void @__io_rsrc_put_work(%struct.io_rsrc_node* noundef %3) #25
  %tobool.not = icmp eq %struct.llist_node* %2, null
  br i1 %tobool.not, label %while.end, label %while.body

while.end:                                        ; preds = %while.body, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @init_timer_key(%struct.timer_list* noundef, void (%struct.timer_list*)* noundef, i32 noundef, i8* noundef, %struct.lock_class_key* noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @delayed_work_timer_fn(%struct.timer_list* noundef) #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @init_llist_head(%struct.llist_head* nocapture noundef writeonly %list) unnamed_addr #10 {
entry:
  %first = getelementptr inbounds %struct.llist_head, %struct.llist_head* %list, i64 0, i32 0
  store %struct.llist_node* null, %struct.llist_node** %first, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_fallback_req_func(%struct.work_struct* noundef %work) #1 {
entry:
  %locked = alloca i8, align 4
  %add.ptr = getelementptr %struct.work_struct, %struct.work_struct* %work, i64 -45, i32 1, i32 1
  %0 = bitcast %struct.list_head** %add.ptr to %struct.io_ring_ctx*
  %fallback_llist = getelementptr inbounds %struct.list_head*, %struct.list_head** %add.ptr, i64 177
  %1 = bitcast %struct.list_head** %fallback_llist to %struct.llist_head*
  %call = call fastcc %struct.llist_node* @llist_del_all(%struct.llist_head* noundef %1) #25
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %locked) #26
  store i8 0, i8* %locked, align 4
  %refs = bitcast %struct.list_head** %add.ptr to %struct.percpu_ref*
  call fastcc void @percpu_ref_get(%struct.percpu_ref* noundef %refs) #25
  %add.ptr734 = getelementptr %struct.llist_node, %struct.llist_node* %call, i64 -18
  %cmp.not35 = icmp eq %struct.llist_node* %add.ptr734, inttoptr (i64 -144 to %struct.llist_node*)
  br i1 %cmp.not35, label %if.end17, label %land.rhs.preheader

land.rhs.preheader:                               ; preds = %entry
  %2 = bitcast %struct.llist_node* %add.ptr734 to %struct.io_kiocb*
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.preheader, %land.rhs
  %req.036 = phi %struct.io_kiocb* [ %5, %land.rhs ], [ %2, %land.rhs.preheader ]
  %io_task_work = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.036, i64 0, i32 14
  %3 = bitcast %struct.io_task_work* %io_task_work to i8**
  %4 = load i8*, i8** %3, align 8
  %add.ptr13 = getelementptr i8, i8* %4, i64 -144
  %5 = bitcast i8* %add.ptr13 to %struct.io_kiocb*
  %func = getelementptr inbounds %struct.io_kiocb, %struct.io_kiocb* %req.036, i64 0, i32 14, i32 1
  %6 = load void (%struct.io_kiocb*, i8*)*, void (%struct.io_kiocb*, i8*)** %func, align 8
  call void %6(%struct.io_kiocb* noundef %req.036, i8* noundef nonnull %locked) #27
  %cmp.not = icmp eq i8* %add.ptr13, inttoptr (i64 -144 to i8*)
  br i1 %cmp.not, label %for.end, label %land.rhs

for.end:                                          ; preds = %land.rhs
  %.pre = load i8, i8* %locked, align 4, !range !18
  %phi.cmp = icmp eq i8 %.pre, 0
  br i1 %phi.cmp, label %if.end17, label %if.then

if.then:                                          ; preds = %for.end
  %7 = getelementptr inbounds %struct.list_head*, %struct.list_head** %add.ptr, i64 8
  %compl_nr = getelementptr inbounds %struct.list_head*, %struct.list_head** %add.ptr, i64 93
  %8 = bitcast %struct.list_head** %compl_nr to i32*
  %9 = load i32, i32* %8, align 8
  %tobool15.not = icmp eq i32 %9, 0
  br i1 %tobool15.not, label %if.end, label %if.then16

if.then16:                                        ; preds = %if.then
  call fastcc void @io_submit_flush_completions(%struct.io_ring_ctx* noundef %0) #25
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.then
  %uring_lock = bitcast %struct.list_head** %7 to %struct.mutex*
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end17

if.end17:                                         ; preds = %entry, %if.end, %for.end
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %refs) #25
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %locked) #26
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.llist_node* @llist_del_all(%struct.llist_head* noundef %head) unnamed_addr #1 {
entry:
  %0 = bitcast %struct.llist_head* %head to i8*
  %call11.i = call fastcc i64 @__xchg_case_mb_64(i8* noundef %0) #27
  %1 = inttoptr i64 %call11.i to %struct.llist_node*
  ret %struct.llist_node* %1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__io_rsrc_put_work(%struct.io_rsrc_node* noundef %ref_node) unnamed_addr #1 {
entry:
  %rsrc_data1 = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %ref_node, i64 0, i32 3
  %0 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %rsrc_data1, align 8
  %ctx2 = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %0, i64 0, i32 0
  %1 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %ctx2, align 8
  %rsrc_list = getelementptr inbounds %struct.io_rsrc_node, %struct.io_rsrc_node* %ref_node, i64 0, i32 2
  %2 = bitcast %struct.list_head* %rsrc_list to %struct.io_rsrc_put**
  %3 = load %struct.io_rsrc_put*, %struct.io_rsrc_put** %2, align 8
  %list1163 = getelementptr inbounds %struct.io_rsrc_put, %struct.io_rsrc_put* %3, i64 0, i32 0
  %cmp.not64 = icmp eq %struct.list_head* %list1163, %rsrc_list
  br i1 %cmp.not64, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 0, i32 2
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 11, i32 0, i32 0, i32 0
  %cq_extra = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %1, i64 0, i32 10, i32 5
  %do_put = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %0, i64 0, i32 3
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end
  %list1167 = phi %struct.list_head* [ %list1163, %for.body.lr.ph ], [ %list11, %if.end ]
  %prsrc.065 = phi %struct.io_rsrc_put* [ %3, %for.body.lr.ph ], [ %tmp.066, %if.end ]
  %tmp.066.in = bitcast %struct.io_rsrc_put* %prsrc.065 to %struct.io_rsrc_put**
  %tmp.066 = load %struct.io_rsrc_put*, %struct.io_rsrc_put** %tmp.066.in, align 8
  call fastcc void @list_del(%struct.list_head* noundef %list1167) #25
  %tag = getelementptr inbounds %struct.io_rsrc_put, %struct.io_rsrc_put* %prsrc.065, i64 0, i32 1
  %4 = load i64, i64* %tag, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 1
  %tobool14 = icmp ne i32 %and, 0
  call fastcc void @io_ring_submit_lock(%struct.io_ring_ctx* noundef %1, i1 noundef %tobool14) #25
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %6 = load i64, i64* %tag, align 8
  %call = call fastcc i1 @io_cqring_fill_event(%struct.io_ring_ctx* noundef %1, i64 noundef %6, i64 noundef 0, i32 noundef 0) #25
  %7 = load i32, i32* %cq_extra, align 64
  %inc = add i32 %7, 1
  store i32 %inc, i32* %cq_extra, align 64
  call fastcc void @io_commit_cqring(%struct.io_ring_ctx* noundef %1) #25
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  call fastcc void @io_cqring_ev_posted(%struct.io_ring_ctx* noundef %1) #25
  call fastcc void @io_ring_submit_unlock(%struct.io_ring_ctx* noundef %1, i1 noundef %tobool14) #25
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %8 = load void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)*, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)** %do_put, align 8
  call void %8(%struct.io_ring_ctx* noundef %1, %struct.io_rsrc_put* noundef %prsrc.065) #27
  %9 = bitcast %struct.io_rsrc_put* %prsrc.065 to i8*
  call void @kfree(i8* noundef %9) #27
  %list11 = getelementptr inbounds %struct.io_rsrc_put, %struct.io_rsrc_put* %tmp.066, i64 0, i32 0
  %cmp.not = icmp eq %struct.list_head* %list11, %rsrc_list
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.end, %entry
  call fastcc void @io_rsrc_node_destroy(%struct.io_rsrc_node* noundef %ref_node) #25
  %refs = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %0, i64 0, i32 4
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %refs) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.i.i, label %if.then28, label %if.end29

if.then28:                                        ; preds = %for.end
  %done = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %0, i64 0, i32 5
  call void @complete(%struct.completion* noundef %done) #27
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %for.end
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__xchg_case_mb_64(i8* noundef %ptr) unnamed_addr #1 {
entry:
  %0 = bitcast i8* %ptr to i64*
  %1 = call { i64, i64 } asm sideeffect "\09prfm\09pstl1strm, $2\0A1:\09ldxr\09$0, $2\0A\09stlxr\09${1:w}, $3, $2\0A\09cbnz\09${1:w}, 1b\0A\09dmb ish", "=&r,=&r,=*Q,r,*Q,~{memory}"(i64* elementtype(i64) %0, i64 0, i64* elementtype(i64) %0) #26, !srcloc !123
  %asmresult = extractvalue { i64, i64 } %1, 0
  ret i64 %asmresult
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @refcount_inc(%struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  call fastcc void @__refcount_inc(%struct.refcount_struct* noundef %r) #25
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @__refcount_inc(%struct.refcount_struct* noundef %r) unnamed_addr #1 {
entry:
  call fastcc void @__refcount_add(i32 noundef 1, %struct.refcount_struct* noundef %r) #25
  ret void
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc i64 @rings_size(i32 noundef %sq_entries, i32 noundef %cq_entries, i64* noundef writeonly %sq_offset) unnamed_addr #21 {
entry:
  %conv = zext i32 %cq_entries to i64
  %call = call fastcc i64 @__ab_c_size(i64 noundef %conv, i64 noundef 16, i64 noundef 320) #25
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %add = add i64 %call, 63
  %and = and i64 %add, -64
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %tobool.not = icmp eq i64* %sq_offset, null
  br i1 %tobool.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end5
  store i64 %and, i64* %sq_offset, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end5
  %conv8 = zext i32 %sq_entries to i64
  %call9 = call fastcc i64 @array_size(i64 noundef 4, i64 noundef %conv8) #25
  %cmp10 = icmp eq i64 %call9, -1
  %spec.select = call i64 @llvm.uadd.sat.i64(i64 %and, i64 %call9)
  %spec.select30 = select i1 %cmp10, i64 -1, i64 %spec.select
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end, %entry
  %retval.0 = phi i64 [ -1, %entry ], [ -1, %if.end ], [ %spec.select30, %if.end7 ]
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @io_mem_alloc(i64 noundef %size) unnamed_addr #1 {
entry:
  %dec.i = add i64 %size, -1
  %cmp.i.i = icmp ult i64 %dec.i, 4096
  %shr.i = lshr i64 %dec.i, 12
  %0 = call i64 @llvm.ctlz.i64(i64 %shr.i, i1 false) #26, !range !119
  %1 = trunc i64 %0 to i32
  %conv.i.i = sub nuw nsw i32 64, %1
  %retval.0.i.i = select i1 %cmp.i.i, i32 0, i32 %conv.i.i
  %call1 = call i64 @__get_free_pages(i32 noundef 4533696, i32 noundef %retval.0.i.i) #27
  %2 = inttoptr i64 %call1 to i8*
  ret i8* %2
}

; Function Attrs: mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i64 @array_size(i64 noundef %a, i64 noundef %b) unnamed_addr #19 {
entry:
  %0 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
  %1 = extractvalue { i64, i1 } %0, 1
  %2 = extractvalue { i64, i1 } %0, 0
  %retval.0 = select i1 %1, i64 -1, i64 %2
  ret i64 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__get_free_pages(i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_sq_data* @io_get_sq_data(%struct.io_uring_params* nocapture noundef readonly %p, i8* nocapture noundef writeonly %attached) unnamed_addr #1 {
entry:
  store i8 0, i8* %attached, align 1
  %flags = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 32
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end6, label %if.then

if.then:                                          ; preds = %entry
  %call = call fastcc %struct.io_sq_data* @io_attach_sq_data(%struct.io_uring_params* noundef %p) #25
  %1 = bitcast %struct.io_sq_data* %call to i8*
  %call1 = call fastcc i1 @IS_ERR(i8* noundef %1) #25
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  store i8 1, i8* %attached, align 1
  br label %cleanup

if.end:                                           ; preds = %if.then
  %call3 = call fastcc i64 @PTR_ERR(i8* noundef %1) #25
  %cmp.not = icmp eq i64 %call3, -1
  br i1 %cmp.not, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end, %entry
  %call7 = call fastcc i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #25
  %tobool8.not = icmp eq i8* %call7, null
  br i1 %tobool8.not, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end6
  %call10 = call fastcc i8* @ERR_PTR(i64 noundef -12) #25
  %2 = bitcast i8* %call10 to %struct.io_sq_data*
  br label %cleanup

if.end11:                                         ; preds = %if.end6
  %3 = bitcast i8* %call7 to %struct.io_sq_data*
  %park_pending = getelementptr inbounds i8, i8* %call7, i64 4
  %counter.i = bitcast i8* %park_pending to i32*
  store volatile i32 0, i32* %counter.i, align 4
  %refs = bitcast i8* %call7 to %struct.refcount_struct*
  call fastcc void @refcount_set(%struct.refcount_struct* noundef nonnull %refs) #25
  %ctx_list = getelementptr inbounds i8, i8* %call7, i64 40
  %4 = bitcast i8* %ctx_list to %struct.list_head*
  call fastcc void @INIT_LIST_HEAD(%struct.list_head* noundef %4) #25
  %lock = getelementptr inbounds i8, i8* %call7, i64 8
  %5 = bitcast i8* %lock to %struct.mutex*
  call void @__mutex_init(%struct.mutex* noundef %5, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_get_sq_data.__key) #27
  %wait = getelementptr inbounds i8, i8* %call7, i64 64
  %6 = bitcast i8* %wait to %struct.wait_queue_head*
  call void @__init_waitqueue_head(%struct.wait_queue_head* noundef %6, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.36, i64 0, i64 0), %struct.lock_class_key* noundef nonnull @io_get_sq_data.__key.35) #27
  %exited = getelementptr inbounds i8, i8* %call7, i64 112
  %7 = bitcast i8* %exited to %struct.completion*
  call fastcc void @init_completion(%struct.completion* noundef %7) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end11, %if.then9, %if.then2
  %retval.0 = phi %struct.io_sq_data* [ %3, %if.end11 ], [ %2, %if.then9 ], [ %call, %if.then2 ], [ %call, %if.end ]
  ret %struct.io_sq_data* %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @cpu_online(i32 noundef %cpu) unnamed_addr #8 {
entry:
  %call = call fastcc i32 @cpumask_test_cpu(i32 noundef %cpu) #25
  %tobool = icmp ne i32 %call, 0
  ret i1 %tobool
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.task_struct* @create_io_thread(i32 (i8*)* noundef, i8* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline noreturn nounwind null_pointer_is_valid
define internal i32 @io_sq_thread(i8* noundef %data) #22 {
entry:
  %buf = alloca [16 x i8], align 1
  %wait = alloca %struct.wait_queue_entry, align 8
  %0 = bitcast i8* %data to %struct.io_sq_data*
  %1 = getelementptr inbounds [16 x i8], [16 x i8]* %buf, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %1) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(16) %1, i8 0, i64 16, i1 false), !annotation !14
  %2 = bitcast %struct.wait_queue_entry* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %2) #26
  %private = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 1
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %5 = bitcast i8** %private to %struct.task_struct**
  %6 = bitcast %struct.wait_queue_entry* %wait to i64*
  store i64 0, i64* %6, align 8
  store %struct.task_struct* %4, %struct.task_struct** %5, align 8
  %func = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 2
  store i32 (%struct.wait_queue_entry*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.wait_queue_entry*, i32, i32, i8*)** %func, align 8
  %entry1 = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i64 0, i32 0
  store %struct.list_head* %entry1, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.wait_queue_entry, %struct.wait_queue_entry* %wait, i64 0, i32 3, i32 1
  store %struct.list_head* %entry1, %struct.list_head** %prev, align 8
  %task_pid = getelementptr inbounds i8, i8* %data, i64 96
  %7 = bitcast i8* %task_pid to i32*
  %8 = load i32, i32* %7, align 8
  %call4 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* noundef nonnull %1, i64 noundef 16, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i64 0, i64 0), i32 noundef %8) #27
  call fastcc void @set_task_comm(%struct.task_struct* noundef %4, i8* noundef nonnull %1) #25
  %sq_cpu = getelementptr inbounds i8, i8* %data, i64 92
  %9 = bitcast i8* %sq_cpu to i32*
  %10 = load i32, i32* %9, align 4
  %cmp.not = icmp eq i32 %10, -1
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call9 = call fastcc %struct.cpumask* @get_cpu_mask(i32 noundef %10) #25
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %__cpu_online_mask.sink = phi %struct.cpumask* [ %call9, %if.then ], [ @__cpu_online_mask, %entry ]
  %call12 = call i32 @set_cpus_allowed_ptr(%struct.task_struct* noundef %4, %struct.cpumask* noundef nonnull %__cpu_online_mask.sink) #27
  %flags14 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 4
  %11 = load i32, i32* %flags14, align 4
  %or = or i32 %11, 67108864
  store i32 %or, i32* %flags14, align 4
  %lock = getelementptr inbounds i8, i8* %data, i64 8
  %12 = bitcast i8* %lock to %struct.mutex*
  call void @mutex_lock(%struct.mutex* noundef %12) #27
  %sq_thread_idle = getelementptr inbounds i8, i8* %data, i64 88
  %13 = bitcast i8* %sq_thread_idle to i32*
  %ctx_list = getelementptr inbounds i8, i8* %data, i64 40
  %14 = bitcast i8* %ctx_list to %struct.list_head*
  %.pn.in235 = bitcast i8* %ctx_list to i8**
  %wait67 = getelementptr inbounds i8, i8* %data, i64 64
  %15 = bitcast i8* %wait67 to %struct.wait_queue_head*
  %task_works = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i64 0, i32 96
  br label %while.cond

while.cond:                                       ; preds = %while.cond.backedge, %if.end
  %timeout.0 = phi i64 [ 0, %if.end ], [ %timeout.0.be, %while.cond.backedge ]
  %call15 = call fastcc i1 @io_sqd_events_pending(%struct.io_sq_data* noundef %0) #25
  br i1 %call15, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.cond
  %call17 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %4) #25
  %tobool.not = icmp eq i32 %call17, 0
  br i1 %tobool.not, label %if.end22, label %if.then18

if.then18:                                        ; preds = %lor.lhs.false, %while.cond
  %call19 = call fastcc i1 @io_sqd_handle_event(%struct.io_sq_data* noundef %0) #25
  br i1 %call19, label %while.end, label %if.end21

if.end21:                                         ; preds = %if.then18
  %16 = load volatile i64, i64* @jiffies, align 64
  %17 = load i32, i32* %13, align 8
  %conv = zext i32 %17 to i64
  %add = add i64 %16, %conv
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false
  %timeout.1 = phi i64 [ %add, %if.end21 ], [ %timeout.0, %lor.lhs.false ]
  %call23 = call fastcc i32 @list_is_singular(%struct.list_head* noundef %14) #25
  %tobool24.not = icmp eq i32 %call23, 0
  %.pn236 = load i8*, i8** %.pn.in235, align 8
  %cmp28.not237 = icmp eq i8* %.pn236, %ctx_list
  br i1 %cmp28.not237, label %for.end, label %for.body

for.body:                                         ; preds = %if.end22, %if.end40
  %.pn239 = phi i8* [ %.pn, %if.end40 ], [ %.pn236, %if.end22 ]
  %sqt_spin.0.off0238 = phi i1 [ %sqt_spin.1.off0, %if.end40 ], [ false, %if.end22 ]
  %ctx.0.in = getelementptr i8, i8* %.pn239, i64 -960
  %ctx.0 = bitcast i8* %ctx.0.in to %struct.io_ring_ctx*
  %call32 = call fastcc i32 @__io_sq_thread(%struct.io_ring_ctx* noundef %ctx.0, i1 noundef %tobool24.not) #25
  br i1 %sqt_spin.0.off0238, label %if.end40, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %cmp34 = icmp sgt i32 %call32, 0
  br i1 %cmp34, label %if.then39, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %land.lhs.true
  %iopoll_list = getelementptr i8, i8* %.pn239, i64 200
  %18 = bitcast i8* %iopoll_list to %struct.list_head*
  %call37 = call fastcc i32 @list_empty(%struct.list_head* noundef %18) #25
  %tobool38.not = icmp eq i32 %call37, 0
  br i1 %tobool38.not, label %if.then39, label %if.end40

if.then39:                                        ; preds = %lor.lhs.false36, %land.lhs.true
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %lor.lhs.false36, %for.body
  %sqt_spin.1.off0 = phi i1 [ true, %for.body ], [ true, %if.then39 ], [ false, %lor.lhs.false36 ]
  %.pn.in = bitcast i8* %.pn239 to i8**
  %.pn = load i8*, i8** %.pn.in, align 8
  %cmp28.not = icmp eq i8* %.pn, %ctx_list
  br i1 %cmp28.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.end40, %if.end22
  %sqt_spin.0.off0.lcssa = phi i1 [ false, %if.end22 ], [ %sqt_spin.1.off0, %if.end40 ]
  %call49 = call fastcc i1 @io_run_task_work() #25
  %spec.select = or i1 %sqt_spin.0.off0.lcssa, %call49
  br i1 %spec.select, label %if.then61, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %for.end
  %19 = load volatile i64, i64* @jiffies, align 64
  %sub = sub i64 %timeout.1, %19
  %cmp55 = icmp slt i64 %sub, 0
  br i1 %cmp55, label %if.end66, label %if.then57

if.then57:                                        ; preds = %lor.lhs.false54
  call fastcc void @_cond_resched() #25
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.then57, %if.then61, %if.end140
  %timeout.0.be = phi i64 [ %add144, %if.end140 ], [ %add64, %if.then61 ], [ %timeout.1, %if.then57 ]
  br label %while.cond

if.then61:                                        ; preds = %for.end
  call fastcc void @_cond_resched() #25
  %20 = load volatile i64, i64* @jiffies, align 64
  %21 = load i32, i32* %13, align 8
  %conv63 = zext i32 %21 to i64
  %add64 = add i64 %20, %conv63
  br label %while.cond.backedge

if.end66:                                         ; preds = %lor.lhs.false54
  call void @prepare_to_wait(%struct.wait_queue_head* noundef %15, %struct.wait_queue_entry* noundef nonnull %wait, i32 noundef 1) #27
  %call68 = call fastcc i1 @io_sqd_events_pending(%struct.io_sq_data* noundef %0) #25
  br i1 %call68, label %if.end140, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %if.end66
  %22 = load %struct.callback_head*, %struct.callback_head** %task_works, align 32
  %tobool71.not = icmp eq %struct.callback_head* %22, null
  br i1 %tobool71.not, label %for.cond81, label %if.end140

for.cond81:                                       ; preds = %land.lhs.true69, %if.end95
  %.pn229.in.in = phi i8* [ %.pn229, %if.end95 ], [ %ctx_list, %land.lhs.true69 ]
  %.pn229.in = bitcast i8* %.pn229.in.in to i8**
  %.pn229 = load i8*, i8** %.pn229.in, align 8
  %ctx.1.in = getelementptr i8, i8* %.pn229, i64 -960
  %ctx.1 = bitcast i8* %ctx.1.in to %struct.io_ring_ctx*
  %cmp84.not = icmp eq i8* %.pn229, %ctx_list
  br i1 %cmp84.not, label %if.then111.critedge, label %for.body87

for.body87:                                       ; preds = %for.cond81
  call fastcc void @io_ring_set_wakeup_flag(%struct.io_ring_ctx* noundef %ctx.1) #25
  %flags88 = getelementptr i8, i8* %.pn229, i64 -936
  %23 = bitcast i8* %flags88 to i32*
  %24 = load i32, i32* %23, align 8
  %and = and i32 %24, 1
  %tobool89.not = icmp eq i32 %and, 0
  br i1 %tobool89.not, label %if.end95, label %land.lhs.true90

land.lhs.true90:                                  ; preds = %for.body87
  %iopoll_list91 = getelementptr i8, i8* %.pn229, i64 200
  %25 = bitcast i8* %iopoll_list91 to %struct.list_head*
  %call92 = call fastcc i32 @list_empty_careful(%struct.list_head* noundef %25) #25
  %tobool93.not = icmp eq i32 %call92, 0
  br i1 %tobool93.not, label %if.end114, label %if.end95

if.end95:                                         ; preds = %land.lhs.true90, %for.body87
  %call96 = call fastcc i32 @io_sqring_entries(%struct.io_ring_ctx* noundef %ctx.1) #25
  %tobool97.not = icmp eq i32 %call96, 0
  br i1 %tobool97.not, label %for.cond81, label %if.end114

if.then111.critedge:                              ; preds = %for.cond81
  call void @mutex_unlock(%struct.mutex* noundef %12) #27
  call void @schedule() #27
  call void @mutex_lock(%struct.mutex* noundef %12) #27
  br label %if.end114

if.end114:                                        ; preds = %land.lhs.true90, %if.end95, %if.then111.critedge
  %.pn230241 = load i8*, i8** %.pn.in235, align 8
  %cmp126.not242 = icmp eq i8* %.pn230241, %ctx_list
  br i1 %cmp126.not242, label %if.end140, label %for.body129

for.body129:                                      ; preds = %if.end114, %for.body129
  %.pn230243 = phi i8* [ %.pn230, %for.body129 ], [ %.pn230241, %if.end114 ]
  %ctx.2.in = getelementptr i8, i8* %.pn230243, i64 -960
  %ctx.2 = bitcast i8* %ctx.2.in to %struct.io_ring_ctx*
  call fastcc void @io_ring_clear_wakeup_flag(%struct.io_ring_ctx* noundef %ctx.2) #25
  %.pn230.in = bitcast i8* %.pn230243 to i8**
  %.pn230 = load i8*, i8** %.pn230.in, align 8
  %cmp126.not = icmp eq i8* %.pn230, %ctx_list
  br i1 %cmp126.not, label %if.end140, label %for.body129

if.end140:                                        ; preds = %for.body129, %if.end114, %land.lhs.true69, %if.end66
  call void @finish_wait(%struct.wait_queue_head* noundef %15, %struct.wait_queue_entry* noundef nonnull %wait) #27
  %26 = load volatile i64, i64* @jiffies, align 64
  %27 = load i32, i32* %13, align 8
  %conv143 = zext i32 %27 to i64
  %add144 = add i64 %26, %conv143
  br label %while.cond.backedge

while.end:                                        ; preds = %if.then18
  call fastcc void @io_uring_cancel_generic(i1 noundef true, %struct.io_sq_data* noundef %0) #25
  %thread = getelementptr inbounds i8, i8* %data, i64 56
  %28 = bitcast i8* %thread to %struct.task_struct**
  store %struct.task_struct* null, %struct.task_struct** %28, align 8
  %.pn228245 = load i8*, i8** %.pn.in235, align 8
  %cmp157.not246 = icmp eq i8* %.pn228245, %ctx_list
  br i1 %cmp157.not246, label %for.end170, label %for.body160

for.body160:                                      ; preds = %while.end, %for.body160
  %.pn228247 = phi i8* [ %.pn228, %for.body160 ], [ %.pn228245, %while.end ]
  %ctx.3.in = getelementptr i8, i8* %.pn228247, i64 -960
  %ctx.3 = bitcast i8* %ctx.3.in to %struct.io_ring_ctx*
  call fastcc void @io_ring_set_wakeup_flag(%struct.io_ring_ctx* noundef %ctx.3) #25
  %.pn228.in = bitcast i8* %.pn228247 to i8**
  %.pn228 = load i8*, i8** %.pn228.in, align 8
  %cmp157.not = icmp eq i8* %.pn228, %ctx_list
  br i1 %cmp157.not, label %for.end170, label %for.body160

for.end170:                                       ; preds = %for.body160, %while.end
  %call171 = call fastcc i1 @io_run_task_work() #25
  call void @mutex_unlock(%struct.mutex* noundef %12) #27
  %exited = getelementptr inbounds i8, i8* %data, i64 112
  %29 = bitcast i8* %exited to %struct.completion*
  call void @complete(%struct.completion* noundef %29) #27
  call void @do_exit(i64 noundef 0) #32
  unreachable
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @wake_up_new_task(%struct.task_struct* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc %struct.io_sq_data* @io_attach_sq_data(%struct.io_uring_params* nocapture noundef readonly %p) unnamed_addr #1 {
entry:
  %wq_fd = getelementptr inbounds %struct.io_uring_params, %struct.io_uring_params* %p, i64 0, i32 6
  %0 = load i32, i32* %wq_fd, align 8
  %call = call fastcc [2 x i64] @fdget(i32 noundef %0) #25
  %call.fca.0.extract = extractvalue [2 x i64] %call, 0
  %1 = inttoptr i64 %call.fca.0.extract to %struct.file*
  %tobool.not = icmp eq i64 %call.fca.0.extract, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call fastcc i8* @ERR_PTR(i64 noundef -6) #25
  %2 = bitcast i8* %call1 to %struct.io_sq_data*
  br label %cleanup

if.end:                                           ; preds = %entry
  %f_op = getelementptr inbounds %struct.file, %struct.file* %1, i64 0, i32 3
  %3 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp.not = icmp eq %struct.file_operations* %3, @io_uring_fops
  br i1 %cmp.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  call fastcc void @fdput([2 x i64] %call) #25
  %call4 = call fastcc i8* @ERR_PTR(i64 noundef -22) #25
  %4 = bitcast i8* %call4 to %struct.io_sq_data*
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %private_data = getelementptr inbounds %struct.file, %struct.file* %1, i64 0, i32 15
  %5 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %6 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %5, align 8
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %6, i64 0, i32 5
  %7 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool7.not = icmp eq %struct.io_sq_data* %7, null
  br i1 %tobool7.not, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  call fastcc void @fdput([2 x i64] %call) #25
  %call9 = call fastcc i8* @ERR_PTR(i64 noundef -22) #25
  %8 = bitcast i8* %call9 to %struct.io_sq_data*
  br label %cleanup

if.end10:                                         ; preds = %if.end5
  %task_tgid = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %7, i64 0, i32 9
  %9 = load i32, i32* %task_tgid, align 4
  %10 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %11 = inttoptr i64 %10 to %struct.task_struct*
  %tgid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %11, i64 0, i32 51
  %12 = load i32, i32* %tgid, align 4
  %cmp12.not = icmp eq i32 %9, %12
  br i1 %cmp12.not, label %if.end15, label %if.then13

if.then13:                                        ; preds = %if.end10
  call fastcc void @fdput([2 x i64] %call) #25
  %call14 = call fastcc i8* @ERR_PTR(i64 noundef -1) #25
  %13 = bitcast i8* %call14 to %struct.io_sq_data*
  br label %cleanup

if.end15:                                         ; preds = %if.end10
  %refs = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %7, i64 0, i32 0
  call fastcc void @refcount_inc(%struct.refcount_struct* noundef %refs) #25
  call fastcc void @fdput([2 x i64] %call) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi %struct.io_sq_data* [ %4, %if.then3 ], [ %13, %if.then13 ], [ %7, %if.end15 ], [ %8, %if.then8 ], [ %2, %if.then ]
  ret %struct.io_sq_data* %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__msecs_to_jiffies(i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i32 @cpumask_test_cpu(i32 noundef %cpu) unnamed_addr #8 {
entry:
  %div.i = lshr i32 %cpu, 6
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr %struct.cpumask, %struct.cpumask* @__cpu_online_mask, i64 0, i32 0, i64 %idxprom.i
  %0 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i32 %cpu, 63
  %sh_prom.i = zext i32 %and.i to i64
  %shr.i = lshr i64 %0, %sh_prom.i
  %1 = trunc i64 %shr.i to i32
  %conv.i = and i32 %1, 1
  ret i32 %conv.i
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @snprintf(i8* noundef, i64 noundef, i8* noundef, ...) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @set_task_comm(%struct.task_struct* noundef %tsk, i8* noundef %from) unnamed_addr #1 {
entry:
  call void @__set_task_comm(%struct.task_struct* noundef %tsk, i8* noundef %from, i1 noundef false) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @set_cpus_allowed_ptr(%struct.task_struct* noundef, %struct.cpumask* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc nonnull %struct.cpumask* @get_cpu_mask(i32 noundef %cpu) unnamed_addr #0 {
entry:
  %rem = and i32 %cpu, 63
  %add = add nuw nsw i32 %rem, 1
  %idxprom = zext i32 %add to i64
  %div = lshr i32 %cpu, 6
  %idx.ext = zext i32 %div to i64
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr = getelementptr [65 x [4 x i64]], [65 x [4 x i64]]* @cpu_bit_bitmap, i64 0, i64 %idxprom, i64 %idx.neg
  %0 = bitcast i64* %add.ptr to %struct.cpumask*
  ret %struct.cpumask* %0
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn
define internal fastcc i1 @io_sqd_events_pending(%struct.io_sq_data* noundef %sqd) unnamed_addr #8 {
entry:
  %state = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 10
  %0 = load volatile i64, i64* %state, align 8
  %tobool = icmp ne i64 %0, 0
  ret i1 %tobool
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_sqd_handle_event(%struct.io_sq_data* noundef %sqd) unnamed_addr #1 {
entry:
  %ksig = alloca %struct.ksignal, align 8
  %0 = bitcast %struct.ksignal* %ksig to i8*
  call void @llvm.lifetime.start.p0i8(i64 88, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(88) %0, i8 0, i64 88, i1 false), !annotation !14
  %state = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 10
  %1 = load volatile i64, i64* %state, align 8
  %2 = and i64 %1, 2
  %tobool.not = icmp eq i64 %2, 0
  br i1 %tobool.not, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %4 = inttoptr i64 %3 to %struct.task_struct*
  %call2 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %4) #25
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %lor.rhs, label %if.then

if.then:                                          ; preds = %entry, %lor.lhs.false
  %lock = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd, i64 0, i32 2
  call void @mutex_unlock(%struct.mutex* noundef %lock) #27
  %5 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %6 = inttoptr i64 %5 to %struct.task_struct*
  %call5 = call fastcc i32 @signal_pending(%struct.task_struct* noundef %6) #25
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %lor.rhs.critedge19, label %if.then7

if.then7:                                         ; preds = %if.then
  %call8 = call i1 @get_signal(%struct.ksignal* noundef nonnull %ksig) #27
  call fastcc void @_cond_resched() #25
  call void @mutex_lock(%struct.mutex* noundef %lock) #27
  br i1 %call8, label %lor.end, label %lor.rhs

lor.rhs.critedge19:                               ; preds = %if.then
  call fastcc void @_cond_resched() #25
  call void @mutex_lock(%struct.mutex* noundef %lock) #27
  br label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false, %lor.rhs.critedge19, %if.then7
  %7 = load volatile i64, i64* %state, align 8
  %conv.i2021 = and i64 %7, 1
  %tobool15 = icmp ne i64 %conv.i2021, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then7
  %8 = phi i1 [ true, %if.then7 ], [ %tobool15, %lor.rhs ]
  call void @llvm.lifetime.end.p0i8(i64 88, i8* nonnull %0) #26
  ret i1 %8
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_sq_thread(%struct.io_ring_ctx* noundef %ctx, i1 noundef %cap_entries) unnamed_addr #1 {
entry:
  %nr_events = alloca i32, align 4
  %call = call fastcc i32 @io_sqring_entries(%struct.io_ring_ctx* noundef %ctx) #25
  %cmp = icmp ugt i32 %call, 8
  %or.cond = select i1 %cap_entries, i1 %cmp, i1 false
  %spec.store.select = select i1 %or.cond, i32 8, i32 %call
  %iopoll_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 2
  %call1 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool2 = icmp eq i32 %call1, 0
  %tobool3 = icmp ne i32 %spec.store.select, 0
  %or.cond40 = select i1 %tobool2, i1 true, i1 %tobool3
  br i1 %or.cond40, label %if.then4, label %if.end39

if.then4:                                         ; preds = %entry
  %0 = bitcast i32* %nr_events to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #26
  store i32 0, i32* %nr_events, align 4
  %sq_creds = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 4
  %1 = load %struct.cred*, %struct.cred** %sq_creds, align 8
  %2 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %3 = inttoptr i64 %2 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %3, i64 0, i32 80
  %4 = load %struct.cred*, %struct.cred** %cred, align 8
  %cmp6.not = icmp eq %struct.cred* %1, %4
  br i1 %cmp6.not, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.then4
  %call9 = call %struct.cred* @override_creds(%struct.cred* noundef %1) #27
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.then4
  %creds.0 = phi %struct.cred* [ %call9, %if.then7 ], [ null, %if.then4 ]
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %call12 = call fastcc i32 @list_empty(%struct.list_head* noundef %iopoll_list) #25
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end10
  %call15 = call fastcc i32 @io_do_iopoll(%struct.io_ring_ctx* noundef %ctx, i32* noundef nonnull %nr_events, i64 noundef 0) #25
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end10
  br i1 %tobool3, label %land.lhs.true18, label %if.end27

land.lhs.true18:                                  ; preds = %if.end16
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  %call19 = call fastcc i1 @percpu_ref_is_dying(%struct.percpu_ref* noundef %refs) #25
  br i1 %call19, label %land.lhs.true30, label %land.lhs.true23, !prof !24

land.lhs.true23:                                  ; preds = %land.lhs.true18
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %5 = load i32, i32* %flags, align 8
  %and = and i32 %5, 64
  %tobool24.not = icmp eq i32 %and, 0
  br i1 %tobool24.not, label %if.then25, label %land.lhs.true30

if.then25:                                        ; preds = %land.lhs.true23
  %call26 = call fastcc i32 @io_submit_sqes(%struct.io_ring_ctx* noundef %ctx, i32 noundef %spec.store.select) #25
  br label %land.lhs.true30

if.end27:                                         ; preds = %if.end16
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end35

land.lhs.true30:                                  ; preds = %if.then25, %land.lhs.true23, %land.lhs.true18
  %ret.0.ph = phi i32 [ 0, %land.lhs.true18 ], [ %call26, %if.then25 ], [ 0, %land.lhs.true23 ]
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %sqo_sq_wait = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 6
  %call31 = call fastcc i1 @wq_has_sleeper(%struct.wait_queue_head* noundef %sqo_sq_wait) #25
  br i1 %call31, label %if.then33, label %if.end35

if.then33:                                        ; preds = %land.lhs.true30
  call void @__wake_up(%struct.wait_queue_head* noundef %sqo_sq_wait, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %if.end35

if.end35:                                         ; preds = %if.end27, %if.then33, %land.lhs.true30
  %ret.062 = phi i32 [ %ret.0.ph, %if.then33 ], [ %ret.0.ph, %land.lhs.true30 ], [ 0, %if.end27 ]
  %tobool36.not = icmp eq %struct.cred* %creds.0, null
  br i1 %tobool36.not, label %if.end38, label %if.then37

if.then37:                                        ; preds = %if.end35
  call void @revert_creds(%struct.cred* noundef nonnull %creds.0) #27
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end35
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #26
  br label %if.end39

if.end39:                                         ; preds = %entry, %if.end38
  %ret.1 = phi i32 [ %ret.062, %if.end38 ], [ 0, %entry ]
  ret i32 %ret.1
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_set_wakeup_flag(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %sq_flags = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 7
  %1 = load i32, i32* %sq_flags, align 4
  %or = or i32 %1, 1
  store volatile i32 %or, i32* %sq_flags, align 4
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_ring_clear_wakeup_flag(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 11, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %rings = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 1
  %0 = load %struct.io_rings*, %struct.io_rings** %rings, align 16
  %sq_flags = getelementptr inbounds %struct.io_rings, %struct.io_rings* %0, i64 0, i32 7
  %1 = load i32, i32* %sq_flags, align 4
  %and = and i32 %1, -2
  store volatile i32 %and, i32* %sq_flags, align 4
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  ret void
}

; Function Attrs: noreturn null_pointer_is_valid
declare dso_local void @do_exit(i64 noundef) local_unnamed_addr #23

; Function Attrs: null_pointer_is_valid
declare dso_local void @__set_task_comm(%struct.task_struct* noundef, i8* noundef, i1 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i1 @get_signal(%struct.ksignal* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @_copy_to_user(i8* noundef %to, i8* noundef %from, i64 noundef %n) unnamed_addr #1 {
entry:
  %call1 = call fastcc i64 @__range_ok(i8* noundef %to, i64 noundef %n) #25
  %tobool.not = icmp eq i64 %call1, 0
  br i1 %tobool.not, label %return, label %if.then2

if.then2:                                         ; preds = %entry
  %call4 = call fastcc i8* @__uaccess_mask_ptr(i8* noundef %to) #25
  %call5 = call i64 @__arch_copy_to_user(i8* noundef %call4, i8* noundef %from, i64 noundef %n) #27
  br label %return

return:                                           ; preds = %entry, %if.then2
  %n.addr.0 = phi i64 [ %call5, %if.then2 ], [ %n, %entry ]
  ret i64 %n.addr.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @__arch_copy_to_user(i8* noundef, i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.file* @anon_inode_getfile(i8* noundef, %struct.file_operations* noundef, i8* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @get_unused_fd_flags(i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i64 @__do_sys_io_uring_register(i32 noundef %fd, i32 noundef %opcode, i8* noundef %arg, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %call = call fastcc [2 x i64] @fdget(i32 noundef %fd) #25
  %call.fca.0.extract = extractvalue [2 x i64] %call, 0
  %0 = inttoptr i64 %call.fca.0.extract to %struct.file*
  %tobool.not = icmp eq i64 %call.fca.0.extract, 0
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %f_op = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp.not = icmp eq %struct.file_operations* %1, @io_uring_fops
  br i1 %cmp.not, label %if.end3, label %out_fput

if.end3:                                          ; preds = %if.end
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i64 0, i32 15
  %2 = bitcast i8** %private_data to %struct.io_ring_ctx**
  %3 = load %struct.io_ring_ctx*, %struct.io_ring_ctx** %2, align 8
  %call5 = call fastcc i1 @io_run_task_work() #25
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %3, i64 0, i32 1, i32 0
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %call6 = call fastcc i32 @__io_uring_register(%struct.io_ring_ctx* noundef %3, i32 noundef %opcode, i8* noundef %arg, i32 noundef %nr_args) #25
  %conv = sext i32 %call6 to i64
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  br label %out_fput

out_fput:                                         ; preds = %if.end, %if.end3
  %ret.0 = phi i64 [ -95, %if.end ], [ %conv, %if.end3 ]
  call fastcc void @fdput([2 x i64] %call) #25
  br label %cleanup

cleanup:                                          ; preds = %entry, %out_fput
  %retval.0 = phi i64 [ %ret.0, %out_fput ], [ -9, %entry ]
  ret i64 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @__io_uring_register(%struct.io_ring_ctx* noundef %ctx, i32 noundef %opcode, i8* noundef %arg, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  %call = call fastcc i1 @percpu_ref_is_dying(%struct.percpu_ref* noundef %refs) #25
  br i1 %call, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %restricted = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %restricted, align 4
  %0 = and i8 %bf.load, 8
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end15, label %if.then1

if.then1:                                         ; preds = %if.end
  %cmp = icmp ugt i32 %opcode, 19
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.then1
  %conv = zext i32 %opcode to i64
  %call5 = call fastcc i64 @array_index_mask_nospec(i64 noundef %conv, i64 noundef 20) #25
  %1 = trunc i64 %call5 to i32
  %conv10 = and i32 %1, %opcode
  %div.i = lshr i32 %conv10, 6
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 0, i64 %idxprom.i
  %2 = load volatile i64, i64* %arrayidx.i, align 8
  %sh_prom.i = zext i32 %conv10 to i64
  %3 = shl nuw nsw i64 1, %sh_prom.i
  %4 = and i64 %3, %2
  %tobool12.not = icmp eq i64 %4, 0
  br i1 %tobool12.not, label %cleanup, label %if.end15

if.end15:                                         ; preds = %if.end3, %if.end
  %opcode.addr.0 = phi i32 [ %conv10, %if.end3 ], [ %opcode, %if.end ]
  %call16 = call fastcc i1 @io_register_op_must_quiesce(i32 noundef %opcode.addr.0) #25
  br i1 %call16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end15
  %call18 = call fastcc i32 @io_ctx_quiesce(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.end22, label %cleanup

if.end22:                                         ; preds = %if.then17, %if.end15
  switch i32 %opcode.addr.0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb24
    i32 2, label %sw.bb30
    i32 3, label %sw.bb32
    i32 6, label %sw.bb39
    i32 4, label %sw.bb41
    i32 7, label %sw.bb41
    i32 5, label %sw.bb60
    i32 8, label %sw.bb67
    i32 9, label %sw.bb75
    i32 10, label %sw.bb82
    i32 12, label %sw.bb87
    i32 11, label %sw.bb94
    i32 13, label %sw.bb96
    i32 14, label %sw.bb98
    i32 15, label %sw.bb100
    i32 16, label %sw.bb102
    i32 17, label %sw.bb104
    i32 18, label %sw.bb111
    i32 19, label %sw.bb118
  ]

sw.bb:                                            ; preds = %if.end22
  %call23 = call fastcc i32 @io_sqe_buffers_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i64* noundef null) #25
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end22
  %tobool25 = icmp ne i8* %arg, null
  %tobool26 = icmp ne i32 %nr_args, 0
  %or.cond = or i1 %tobool25, %tobool26
  br i1 %or.cond, label %sw.epilog, label %if.end28

if.end28:                                         ; preds = %sw.bb24
  %call29 = call fastcc i32 @io_sqe_buffers_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %sw.epilog

sw.bb30:                                          ; preds = %if.end22
  %call31 = call fastcc i32 @io_sqe_files_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i64* noundef null) #25
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end22
  %tobool33 = icmp ne i8* %arg, null
  %tobool35 = icmp ne i32 %nr_args, 0
  %or.cond130 = or i1 %tobool33, %tobool35
  br i1 %or.cond130, label %sw.epilog, label %if.end37

if.end37:                                         ; preds = %sw.bb32
  %call38 = call fastcc i32 @io_sqe_files_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %sw.epilog

sw.bb39:                                          ; preds = %if.end22
  %call40 = call fastcc i32 @io_register_files_update(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args) #25
  br label %sw.epilog

sw.bb41:                                          ; preds = %if.end22, %if.end22
  %cmp42.not = icmp eq i32 %nr_args, 1
  br i1 %cmp42.not, label %if.end45, label %sw.epilog

if.end45:                                         ; preds = %sw.bb41
  %call46 = call fastcc i32 @io_eventfd_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg) #25
  %tobool47.not = icmp eq i32 %call46, 0
  br i1 %tobool47.not, label %if.end49, label %sw.epilog

if.end49:                                         ; preds = %if.end45
  %cmp50 = icmp eq i32 %opcode.addr.0, 7
  %bf.load53 = load i8, i8* %restricted, align 4
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.end49
  %bf.set = or i8 %bf.load53, 4
  store i8 %bf.set, i8* %restricted, align 4
  br label %sw.epilog

if.else:                                          ; preds = %if.end49
  %bf.clear57 = and i8 %bf.load53, -5
  store i8 %bf.clear57, i8* %restricted, align 4
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end22
  %tobool61 = icmp ne i8* %arg, null
  %tobool63 = icmp ne i32 %nr_args, 0
  %or.cond131 = or i1 %tobool61, %tobool63
  br i1 %or.cond131, label %sw.epilog, label %if.end65

if.end65:                                         ; preds = %sw.bb60
  %call66 = call fastcc i32 @io_eventfd_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %sw.epilog

sw.bb67:                                          ; preds = %if.end22
  %tobool68 = icmp eq i8* %arg, null
  %cmp70 = icmp ugt i32 %nr_args, 256
  %or.cond132 = or i1 %tobool68, %cmp70
  br i1 %or.cond132, label %sw.epilog, label %if.end73

if.end73:                                         ; preds = %sw.bb67
  %call74 = call fastcc i32 @io_probe(i8* noundef nonnull %arg, i32 noundef %nr_args) #25
  br label %sw.epilog

sw.bb75:                                          ; preds = %if.end22
  %tobool76 = icmp ne i8* %arg, null
  %tobool78 = icmp ne i32 %nr_args, 0
  %or.cond133 = or i1 %tobool76, %tobool78
  br i1 %or.cond133, label %sw.epilog, label %if.end80

if.end80:                                         ; preds = %sw.bb75
  %call81 = call fastcc i32 @io_register_personality(%struct.io_ring_ctx* noundef %ctx) #25
  br label %sw.epilog

sw.bb82:                                          ; preds = %if.end22
  %tobool83.not = icmp eq i8* %arg, null
  br i1 %tobool83.not, label %if.end85, label %sw.epilog

if.end85:                                         ; preds = %sw.bb82
  %call86 = call fastcc i32 @io_unregister_personality(%struct.io_ring_ctx* noundef %ctx, i32 noundef %nr_args) #25
  br label %sw.epilog

sw.bb87:                                          ; preds = %if.end22
  %tobool88 = icmp ne i8* %arg, null
  %tobool90 = icmp ne i32 %nr_args, 0
  %or.cond134 = or i1 %tobool88, %tobool90
  br i1 %or.cond134, label %sw.epilog, label %if.end92

if.end92:                                         ; preds = %sw.bb87
  %call93 = call fastcc i32 @io_register_enable_rings(%struct.io_ring_ctx* noundef %ctx) #25
  br label %sw.epilog

sw.bb94:                                          ; preds = %if.end22
  %call95 = call fastcc i32 @io_register_restrictions(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args) #25
  br label %sw.epilog

sw.bb96:                                          ; preds = %if.end22
  %call97 = call fastcc i32 @io_register_rsrc(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i32 noundef 0) #25
  br label %sw.epilog

sw.bb98:                                          ; preds = %if.end22
  %call99 = call fastcc i32 @io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i32 noundef 0) #25
  br label %sw.epilog

sw.bb100:                                         ; preds = %if.end22
  %call101 = call fastcc i32 @io_register_rsrc(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i32 noundef 1) #25
  br label %sw.epilog

sw.bb102:                                         ; preds = %if.end22
  %call103 = call fastcc i32 @io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i32 noundef 1) #25
  br label %sw.epilog

sw.bb104:                                         ; preds = %if.end22
  %tobool105 = icmp ne i8* %arg, null
  %tobool107 = icmp ne i32 %nr_args, 0
  %or.cond135 = and i1 %tobool105, %tobool107
  br i1 %or.cond135, label %if.end109, label %sw.epilog

if.end109:                                        ; preds = %sw.bb104
  %call110 = call fastcc i32 @io_register_iowq_aff(i8* noundef nonnull %arg, i32 noundef %nr_args) #25
  br label %sw.epilog

sw.bb111:                                         ; preds = %if.end22
  %tobool112 = icmp ne i8* %arg, null
  %tobool114 = icmp ne i32 %nr_args, 0
  %or.cond136 = or i1 %tobool112, %tobool114
  br i1 %or.cond136, label %sw.epilog, label %if.end116

if.end116:                                        ; preds = %sw.bb111
  %call117 = call fastcc i32 @io_unregister_iowq_aff() #25
  br label %sw.epilog

sw.bb118:                                         ; preds = %if.end22
  %tobool119 = icmp eq i8* %arg, null
  %cmp121 = icmp ne i32 %nr_args, 2
  %or.cond137 = or i1 %tobool119, %cmp121
  br i1 %or.cond137, label %sw.epilog, label %if.end124

if.end124:                                        ; preds = %sw.bb118
  %call125 = call fastcc i32 @io_register_iowq_max_workers(%struct.io_ring_ctx* noundef %ctx, i8* noundef nonnull %arg) #25
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end22, %sw.bb118, %sw.bb111, %sw.bb104, %sw.bb87, %sw.bb82, %sw.bb75, %sw.bb67, %sw.bb60, %if.then52, %if.else, %if.end45, %sw.bb41, %sw.bb32, %sw.bb24, %if.end124, %if.end116, %if.end109, %sw.bb102, %sw.bb100, %sw.bb98, %sw.bb96, %sw.bb94, %if.end92, %if.end85, %if.end80, %if.end73, %if.end65, %sw.bb39, %if.end37, %sw.bb30, %if.end28, %sw.bb
  %ret.0 = phi i32 [ -22, %sw.bb118 ], [ %call125, %if.end124 ], [ -22, %sw.bb111 ], [ %call117, %if.end116 ], [ %call110, %if.end109 ], [ -22, %sw.bb104 ], [ %call103, %sw.bb102 ], [ %call101, %sw.bb100 ], [ %call99, %sw.bb98 ], [ %call97, %sw.bb96 ], [ %call95, %sw.bb94 ], [ -22, %sw.bb87 ], [ %call93, %if.end92 ], [ -22, %sw.bb82 ], [ %call86, %if.end85 ], [ -22, %sw.bb75 ], [ %call81, %if.end80 ], [ -22, %sw.bb67 ], [ %call74, %if.end73 ], [ -22, %sw.bb60 ], [ %call66, %if.end65 ], [ -22, %sw.bb41 ], [ %call46, %if.end45 ], [ 0, %if.then52 ], [ 0, %if.else ], [ %call40, %sw.bb39 ], [ -22, %sw.bb32 ], [ %call38, %if.end37 ], [ %call31, %sw.bb30 ], [ -22, %sw.bb24 ], [ %call29, %if.end28 ], [ %call23, %sw.bb ], [ -22, %if.end22 ]
  br i1 %call16, label %if.then127, label %cleanup

if.then127:                                       ; preds = %sw.epilog
  call void @percpu_ref_reinit(%struct.percpu_ref* noundef %refs) #27
  %ref_comp = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 7
  call fastcc void @reinit_completion(%struct.completion* noundef %ref_comp) #25
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then127, %if.then17, %if.end3, %if.then1, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ -22, %if.then1 ], [ -13, %if.end3 ], [ %call18, %if.then17 ], [ %ret.0, %if.then127 ], [ %ret.0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn
define internal fastcc i1 @io_register_op_must_quiesce(i32 noundef %op) unnamed_addr #0 {
entry:
  %0 = icmp ugt i32 %op, 19
  %switch.cast = trunc i32 %op to i20
  %switch.downshift = lshr i20 6320, %switch.cast
  %1 = and i20 %switch.downshift, 1
  %switch.masked = icmp ne i20 %1, 0
  %retval.0 = select i1 %0, i1 true, i1 %switch.masked
  ret i1 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_ctx_quiesce(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %refs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 0
  call fastcc void @percpu_ref_kill(%struct.percpu_ref* noundef %refs) #25
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %ref_comp = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 7
  br label %do.body

do.body:                                          ; preds = %if.end, %entry
  %call = call i32 @wait_for_completion_interruptible(%struct.completion* noundef %ref_comp) #27
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %do.end.thread, label %if.end

do.end.thread:                                    ; preds = %do.body
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %if.end9

if.end:                                           ; preds = %do.body
  %call1 = call fastcc i32 @io_run_task_work_sig() #25
  %cmp = icmp sgt i32 %call1, -1
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %if.end
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  call fastcc void @io_refs_resurrect(%struct.percpu_ref* noundef %refs, %struct.completion* noundef %ref_comp) #25
  br label %if.end9

if.end9:                                          ; preds = %do.end.thread, %do.end
  %ret.022 = phi i32 [ 0, %do.end.thread ], [ %call1, %do.end ]
  ret i32 %ret.022
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqe_buffers_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i64* noundef %tags) unnamed_addr #1 {
entry:
  %last_hpage = alloca %struct.page*, align 8
  %data = alloca %struct.io_rsrc_data*, align 8
  %iov = alloca %struct.iovec, align 8
  %0 = bitcast %struct.page** %last_hpage to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store %struct.page* null, %struct.page** %last_hpage, align 8
  %1 = bitcast %struct.io_rsrc_data** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %1) #26
  store %struct.io_rsrc_data* null, %struct.io_rsrc_data** %data, align 8, !annotation !14
  %2 = bitcast %struct.iovec* %iov to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %2) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(16) %2, i8 0, i64 16, i1 false), !annotation !14
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  %3 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %tobool.not = icmp eq %struct.io_mapped_ubuf** %3, null
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %4 = add i32 %nr_args, -16385
  %5 = icmp ult i32 %4, -16384
  br i1 %5, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %call = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool4.not = icmp eq i32 %call, 0
  br i1 %tobool4.not, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end3
  %call7 = call fastcc i32 @io_rsrc_data_alloc(%struct.io_ring_ctx* noundef %ctx, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)* noundef nonnull @io_rsrc_buf_put, i64* noundef %tags, i32 noundef %nr_args, %struct.io_rsrc_data** noundef nonnull %data) #25
  %tobool8.not = icmp eq i32 %call7, 0
  br i1 %tobool8.not, label %if.end10, label %cleanup

if.end10:                                         ; preds = %if.end6
  %call11 = call fastcc i32 @io_buffers_map_alloc(%struct.io_ring_ctx* noundef %ctx, i32 noundef %nr_args) #25
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %for.body.lr.ph, label %if.then13

for.body.lr.ph:                                   ; preds = %if.end10
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 0, i32 0
  %6 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %data, align 8
  %nr_user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 9
  br label %for.body

if.then13:                                        ; preds = %if.end10
  %7 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %data, align 8
  call fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef %7) #25
  br label %cleanup

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.094 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %call16 = call fastcc i32 @io_copy_iov(%struct.iovec* noundef nonnull %iov, i8* noundef %arg, i32 noundef %i.094) #25
  %tobool17.not = icmp eq i32 %call16, 0
  br i1 %tobool17.not, label %if.end19, label %for.end

if.end19:                                         ; preds = %for.body
  %call20 = call fastcc i32 @io_buffer_validate(%struct.iovec* noundef nonnull %iov) #25
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.end23, label %for.end

if.end23:                                         ; preds = %if.end19
  %8 = load i8*, i8** %iov_base, align 8
  %tobool24.not = icmp eq i8* %8, null
  br i1 %tobool24.not, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.end23
  %call25 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %6, i32 noundef %i.094) #25
  %9 = load i64, i64* %call25, align 8
  %tobool26.not = icmp eq i64 %9, 0
  br i1 %tobool26.not, label %if.end28, label %for.end

if.end28:                                         ; preds = %land.lhs.true, %if.end23
  %10 = load %struct.io_mapped_ubuf**, %struct.io_mapped_ubuf*** %user_bufs, align 32
  %idxprom = sext i32 %i.094 to i64
  %arrayidx = getelementptr %struct.io_mapped_ubuf*, %struct.io_mapped_ubuf** %10, i64 %idxprom
  %call30 = call fastcc i32 @io_sqe_buffer_register(%struct.io_ring_ctx* noundef %ctx, %struct.iovec* noundef nonnull %iov, %struct.io_mapped_ubuf** noundef %arrayidx, %struct.page** noundef nonnull %last_hpage) #25
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %for.inc, label %for.end

for.inc:                                          ; preds = %if.end28
  %inc = add nuw i32 %i.094, 1
  %11 = load i32, i32* %nr_user_bufs, align 4
  %inc34 = add i32 %11, 1
  store i32 %inc34, i32* %nr_user_bufs, align 4
  %exitcond.not = icmp eq i32 %inc, %nr_args
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %for.body, %if.end19, %if.end28, %land.lhs.true
  %ret.1 = phi i32 [ 0, %for.inc ], [ %call16, %for.body ], [ %call20, %if.end19 ], [ %call30, %if.end28 ], [ -22, %land.lhs.true ]
  %buf_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 3
  %12 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %tobool35.not = icmp eq %struct.io_rsrc_data* %12, null
  br i1 %tobool35.not, label %if.end44, label %if.then43, !prof !8

if.then43:                                        ; preds = %for.end
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 9104; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !124
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %for.end
  %13 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %data, align 8
  store %struct.io_rsrc_data* %13, %struct.io_rsrc_data** %buf_data, align 8
  %tobool53.not = icmp eq i32 %ret.1, 0
  br i1 %tobool53.not, label %if.else, label %if.then54

if.then54:                                        ; preds = %if.end44
  call fastcc void @__io_sqe_buffers_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

if.else:                                          ; preds = %if.end44
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef null) #25
  br label %cleanup

cleanup:                                          ; preds = %if.then54, %if.else, %if.end6, %if.end3, %if.end, %entry, %if.then13
  %retval.0 = phi i32 [ %call11, %if.then13 ], [ -16, %entry ], [ -22, %if.end ], [ %call, %if.end3 ], [ %call7, %if.end6 ], [ 0, %if.else ], [ %ret.1, %if.then54 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %2) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %1) #26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqe_buffers_unregister(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %buf_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 3
  %0 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %buf_data, align 8
  %tobool.not = icmp eq %struct.io_rsrc_data* %0, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call fastcc i32 @io_rsrc_ref_quiesce(%struct.io_rsrc_data* noundef nonnull %0, %struct.io_ring_ctx* noundef %ctx) #25
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  call fastcc void @__io_sqe_buffers_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then3, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ 0, %if.then3 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqe_files_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args, i64* noundef %tags) unnamed_addr #1 {
entry:
  %fd = alloca i32, align 4
  %0 = bitcast i8* %arg to i32*
  %1 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %1) #26
  store i32 0, i32* %fd, align 4, !annotation !14
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 2
  %2 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %tobool.not = icmp eq %struct.io_rsrc_data* %2, null
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq i32 %nr_args, 0
  br i1 %tobool1.not, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %cmp = icmp ugt i32 %nr_args, 32768
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end3
  %conv = zext i32 %nr_args to i64
  %call = call fastcc i64 @rlimit(i32 noundef 7) #25
  %cmp6 = icmp ult i64 %call, %conv
  br i1 %cmp6, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %call10 = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool11.not = icmp eq i32 %call10, 0
  br i1 %tobool11.not, label %if.end13, label %cleanup

if.end13:                                         ; preds = %if.end9
  %call15 = call fastcc i32 @io_rsrc_data_alloc(%struct.io_ring_ctx* noundef %ctx, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)* noundef nonnull @io_rsrc_file_put, i64* noundef %tags, i32 noundef %nr_args, %struct.io_rsrc_data** noundef %file_data) #25
  %tobool16.not = icmp eq i32 %call15, 0
  br i1 %tobool16.not, label %if.end18, label %cleanup

if.end18:                                         ; preds = %if.end13
  %file_table = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 7
  %call19 = call fastcc i1 @io_alloc_file_tables(%struct.io_file_table* noundef %file_table, i32 noundef %nr_args) #25
  br i1 %call19, label %for.body.lr.ph, label %out_free

for.body.lr.ph:                                   ; preds = %if.end18
  %nr_user_files = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr i32, i32* %0, i64 %indvars.iv
  %3 = bitcast i32* %arrayidx to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %1, i8* noundef %3, i64 noundef 4) #27
  %tobool25.not = icmp eq i64 %call2.i, 0
  br i1 %tobool25.not, label %if.end27, label %out_fput

if.end27:                                         ; preds = %for.body
  %4 = load i32, i32* %fd, align 4
  %cmp28 = icmp eq i32 %4, -1
  br i1 %cmp28, label %if.then30, label %if.end39

if.then30:                                        ; preds = %if.end27
  %5 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %6 = trunc i64 %indvars.iv to i32
  %call32 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef %5, i32 noundef %6) #25
  %7 = load i64, i64* %call32, align 8
  %tobool33.not = icmp eq i64 %7, 0
  br i1 %tobool33.not, label %for.inc, label %out_fput, !prof !8

if.end39:                                         ; preds = %if.end27
  %call40 = call %struct.file* @fget(i32 noundef %4) #27
  %tobool41.not = icmp eq %struct.file* %call40, null
  br i1 %tobool41.not, label %out_fput, label %if.end52, !prof !24

if.end52:                                         ; preds = %if.end39
  %f_op = getelementptr inbounds %struct.file, %struct.file* %call40, i64 0, i32 3
  %8 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8
  %cmp53 = icmp eq %struct.file_operations* %8, @io_uring_fops
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  call void @fput(%struct.file* noundef nonnull %call40) #27
  br label %out_fput

if.end56:                                         ; preds = %if.end52
  %9 = trunc i64 %indvars.iv to i32
  %call58 = call fastcc %struct.io_fixed_file* @io_fixed_file_slot(%struct.io_file_table* noundef %file_table, i32 noundef %9) #25
  call fastcc void @io_fixed_file_set(%struct.io_fixed_file* noundef %call58, %struct.file* noundef nonnull %call40) #25
  br label %for.inc

for.inc:                                          ; preds = %if.then30, %if.end56
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %10 = load i32, i32* %nr_user_files, align 8
  %inc59 = add i32 %10, 1
  store i32 %inc59, i32* %nr_user_files, align 8
  %exitcond.not = icmp eq i64 %indvars.iv.next, %conv
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef null) #25
  br label %cleanup

out_fput:                                         ; preds = %for.body, %if.end39, %if.then30, %if.then55
  %ret.0 = phi i32 [ -9, %if.then55 ], [ -14, %for.body ], [ -9, %if.end39 ], [ -22, %if.then30 ]
  %11 = load i32, i32* %nr_user_files, align 8
  %cmp66131.not = icmp eq i32 %11, 0
  br i1 %cmp66131.not, label %for.end75, label %for.body68

for.body68:                                       ; preds = %out_fput, %for.inc73
  %12 = phi i32 [ %13, %for.inc73 ], [ %11, %out_fput ]
  %i.1132 = phi i32 [ %inc74, %for.inc73 ], [ 0, %out_fput ]
  %call69 = call fastcc %struct.file* @io_file_from_index(%struct.io_ring_ctx* noundef %ctx, i32 noundef %i.1132) #25
  %tobool70.not = icmp eq %struct.file* %call69, null
  br i1 %tobool70.not, label %for.inc73, label %if.then71

if.then71:                                        ; preds = %for.body68
  call void @fput(%struct.file* noundef nonnull %call69) #27
  %.pre = load i32, i32* %nr_user_files, align 8
  br label %for.inc73

for.inc73:                                        ; preds = %for.body68, %if.then71
  %13 = phi i32 [ %12, %for.body68 ], [ %.pre, %if.then71 ]
  %inc74 = add nuw i32 %i.1132, 1
  %cmp66 = icmp ult i32 %inc74, %13
  br i1 %cmp66, label %for.body68, label %for.end75

for.end75:                                        ; preds = %for.inc73, %out_fput
  call fastcc void @io_free_file_tables(%struct.io_file_table* noundef %file_table) #25
  store i32 0, i32* %nr_user_files, align 8
  br label %out_free

out_free:                                         ; preds = %if.end18, %for.end75
  %ret.1 = phi i32 [ %ret.0, %for.end75 ], [ -12, %if.end18 ]
  %14 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  call fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef %14) #25
  store %struct.io_rsrc_data* null, %struct.io_rsrc_data** %file_data, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.end9, %if.end5, %if.end3, %if.end, %entry, %out_free, %for.end
  %retval.0 = phi i32 [ %ret.1, %out_free ], [ 0, %for.end ], [ -16, %entry ], [ -22, %if.end ], [ -24, %if.end3 ], [ -24, %if.end5 ], [ %call10, %if.end9 ], [ %call15, %if.end13 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_sqe_files_unregister(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %file_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 2
  %0 = load %struct.io_rsrc_data*, %struct.io_rsrc_data** %file_data, align 8
  %tobool.not = icmp eq %struct.io_rsrc_data* %0, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call fastcc i32 @io_rsrc_ref_quiesce(%struct.io_rsrc_data* noundef nonnull %0, %struct.io_ring_ctx* noundef %ctx) #25
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  call fastcc void @__io_sqe_files_unregister(%struct.io_ring_ctx* noundef %ctx) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then3, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ 0, %if.then3 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_files_update(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %up = alloca %struct.io_uring_rsrc_update2, align 8
  %0 = bitcast %struct.io_uring_rsrc_update2* %up to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %0, i8 0, i64 32, i1 false), !annotation !14
  %tobool.not = icmp eq i32 %nr_args, 0
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i8* @memset(i8* noundef nonnull %0, i32 noundef 0, i64 noundef 32) #27
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %arg, i64 noundef 16) #27
  %tobool2.not = icmp eq i64 %call2.i, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %call5 = call fastcc i32 @__io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i32 noundef 0, %struct.io_uring_rsrc_update2* noundef nonnull %up, i32 noundef %nr_args) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ %call5, %if.end4 ], [ -22, %entry ], [ -14, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_eventfd_register(%struct.io_ring_ctx* nocapture noundef %ctx, i8* noundef %arg) unnamed_addr #1 {
entry:
  %fd = alloca i32, align 4
  %0 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #26
  store i32 0, i32* %fd, align 4, !annotation !14
  %cq_ev_fd = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 10, i32 2
  %1 = load %struct.eventfd_ctx*, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %tobool.not = icmp eq %struct.eventfd_ctx* %1, null
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %arg, i64 noundef 4) #27
  %tobool1.not = icmp eq i64 %call2.i, 0
  br i1 %tobool1.not, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %2 = load i32, i32* %fd, align 4
  %call4 = call %struct.eventfd_ctx* @eventfd_ctx_fdget(i32 noundef %2) #27
  store %struct.eventfd_ctx* %call4, %struct.eventfd_ctx** %cq_ev_fd, align 8
  %3 = bitcast %struct.eventfd_ctx* %call4 to i8*
  %call7 = call fastcc i1 @IS_ERR(i8* noundef %3) #25
  br i1 %call7, label %if.then8, label %cleanup

if.then8:                                         ; preds = %if.end3
  %call10 = call fastcc i64 @PTR_ERR(i8* noundef %3) #25
  %conv = trunc i64 %call10 to i32
  store %struct.eventfd_ctx* null, %struct.eventfd_ctx** %cq_ev_fd, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry, %if.then8
  %retval.0 = phi i32 [ %conv, %if.then8 ], [ -16, %entry ], [ -14, %if.end ], [ 0, %if.end3 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_probe(i8* noundef %arg, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %conv = zext i32 %nr_args to i64
  %call = call fastcc i64 @__ab_c_size(i64 noundef %conv, i64 noundef 8, i64 noundef 16) #25
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call fastcc i8* @kzalloc(i64 noundef %call, i32 noundef 3264) #25
  %tobool.not = icmp eq i8* %call2, null
  br i1 %tobool.not, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %cmp11.i.i = icmp ugt i64 %call, 2147483647
  br i1 %cmp11.i.i, label %copy_from_user.exit.thread, label %copy_from_user.exit, !prof !24

copy_from_user.exit.thread:                       ; preds = %if.end4
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22include/linux/thread_info.h\22; .popsection; .long 14472b - 14470b; .short 216; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !125
  br label %out

copy_from_user.exit:                              ; preds = %if.end4
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %call2, i8* noundef %arg, i64 noundef %call) #27
  %tobool6.not = icmp eq i64 %call2.i, 0
  br i1 %tobool6.not, label %if.end8, label %out

if.end8:                                          ; preds = %copy_from_user.exit
  %call9 = call i8* @memchr_inv(i8* noundef nonnull %call2, i32 noundef 0, i64 noundef %call) #27
  %tobool10.not = icmp eq i8* %call9, null
  br i1 %tobool10.not, label %if.end12, label %out

if.end12:                                         ; preds = %if.end8
  store i8 39, i8* %call2, align 4
  %0 = icmp ult i32 %nr_args, 40
  %spec.store.select = select i1 %0, i32 %nr_args, i32 40
  %cmp178.not = icmp eq i32 %spec.store.select, 0
  br i1 %cmp178.not, label %if.then.i4, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %if.end12
  %ops = getelementptr inbounds i8, i8* %call2, i64 16
  %1 = bitcast i8* %ops to [0 x %struct.io_uring_probe_op]*
  %wide.trip.count = zext i32 %spec.store.select to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %conv19 = trunc i64 %indvars.iv to i8
  %op = getelementptr [0 x %struct.io_uring_probe_op], [0 x %struct.io_uring_probe_op]* %1, i64 0, i64 %indvars.iv, i32 0
  store i8 %conv19, i8* %op, align 4
  %2 = getelementptr [40 x %struct.io_op_def], [40 x %struct.io_op_def]* bitcast ([40 x { i8, i8, i16 }]* @io_op_defs to [40 x %struct.io_op_def]*), i64 0, i64 %indvars.iv, i32 0
  %bf.load = load i16, i16* %2, align 4
  %3 = and i16 %bf.load, 8
  %tobool22.not = icmp eq i16 %3, 0
  br i1 %tobool22.not, label %if.then23, label %for.inc

if.then23:                                        ; preds = %for.body
  %flags = getelementptr [0 x %struct.io_uring_probe_op], [0 x %struct.io_uring_probe_op]* %1, i64 0, i64 %indvars.iv, i32 2
  store i16 1, i16* %flags, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then23
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.inc
  %phi.cast = trunc i32 %spec.store.select to i8
  br label %if.then.i4

if.then.i4:                                       ; preds = %if.end12, %for.end.loopexit
  %i.0.lcssa = phi i8 [ 0, %if.end12 ], [ %phi.cast, %for.end.loopexit ]
  %4 = getelementptr inbounds i8, i8* %call2, i64 1
  store i8 %i.0.lcssa, i8* %4, align 1
  %call2.i3 = call fastcc i64 @_copy_to_user(i8* noundef %arg, i8* noundef nonnull %call2, i64 noundef %call) #27
  %phi.cmp = icmp eq i64 %call2.i3, 0
  %phi.sel = select i1 %phi.cmp, i32 0, i32 -14
  br label %out

out:                                              ; preds = %if.then.i4, %copy_from_user.exit.thread, %if.end8, %copy_from_user.exit
  %ret.0 = phi i32 [ -14, %copy_from_user.exit ], [ -22, %if.end8 ], [ -14, %copy_from_user.exit.thread ], [ %phi.sel, %if.then.i4 ]
  call void @kfree(i8* noundef nonnull %call2) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %out
  %retval.0 = phi i32 [ %ret.0, %out ], [ -75, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_personality(%struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %id = alloca i32, align 4
  %0 = bitcast i32* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #26
  store i32 0, i32* %id, align 4, !annotation !14
  %1 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %2 = inttoptr i64 %1 to %struct.task_struct*
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i64 0, i32 80
  %3 = load %struct.cred*, %struct.cred** %cred, align 8
  %call1 = call fastcc %struct.cred* @get_cred(%struct.cred* noundef %3) #25
  %personalities = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 16
  %4 = bitcast %struct.cred* %call1 to i8*
  %pers_next = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 17
  %call2 = call fastcc i32 @xa_alloc_cyclic(%struct.xarray* noundef %personalities, i32* noundef nonnull %id, i8* noundef %4, i32* noundef %pers_next) #25
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call fastcc void @put_cred(%struct.cred* noundef %call1) #25
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %id, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %5, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_enable_rings(%struct.io_ring_ctx* nocapture noundef %ctx) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 64
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %registered = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 4
  %1 = load i8, i8* %registered, align 2, !range !18
  %tobool1.not = icmp eq i8 %1, 0
  br i1 %tobool1.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %restricted = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 3
  %bf.load = load i8, i8* %restricted, align 4
  %bf.set = or i8 %bf.load, 8
  store i8 %bf.set, i8* %restricted, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %and5 = and i32 %0, -65
  store i32 %and5, i32* %flags, align 8
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %2 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool6.not = icmp eq %struct.io_sq_data* %2, null
  br i1 %tobool6.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end3
  %wait = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %2, i64 0, i32 5
  %call = call fastcc i1 @wq_has_sleeper(%struct.wait_queue_head* noundef %wait) #25
  br i1 %call, label %if.then8, label %return

if.then8:                                         ; preds = %land.lhs.true
  %3 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %wait10 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %3, i64 0, i32 5
  call void @__wake_up(%struct.wait_queue_head* noundef %wait10, i32 noundef 3, i32 noundef 1, i8* noundef null) #27
  br label %return

return:                                           ; preds = %if.end3, %land.lhs.true, %if.then8, %entry
  %retval.0 = phi i32 [ -77, %entry ], [ 0, %if.then8 ], [ 0, %land.lhs.true ], [ 0, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_restrictions(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 64
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %restrictions = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12
  %registered = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 4
  %1 = load i8, i8* %registered, align 2, !range !18
  %tobool1.not = icmp eq i8 %1, 0
  br i1 %tobool1.not, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %tobool4 = icmp eq i8* %arg, null
  %cmp = icmp ugt i32 %nr_args, 64
  %or.cond = or i1 %tobool4, %cmp
  br i1 %or.cond, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  %conv = zext i32 %nr_args to i64
  %call = call fastcc i64 @array_size(i64 noundef %conv, i64 noundef 16) #25
  %cmp7 = icmp eq i64 %call, -1
  br i1 %cmp7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %call11 = call i8* @memdup_user(i8* noundef nonnull %arg, i64 noundef %call) #27
  %2 = bitcast i8* %call11 to %struct.io_uring_restriction*
  %call12 = call fastcc i1 @IS_ERR(i8* noundef %call11) #25
  br i1 %call12, label %if.then13, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end10
  %cmp17109.not = icmp eq i32 %nr_args, 0
  br i1 %cmp17109.not, label %if.else, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %sqe_flags_required = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 3
  %sqe_flags_allowed = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 2
  %arraydecay47 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 12, i32 1, i64 0
  %arraydecay = getelementptr inbounds %struct.io_restriction, %struct.io_restriction* %restrictions, i64 0, i32 0, i64 0
  br label %for.body

if.then13:                                        ; preds = %if.end10
  %call14 = call fastcc i64 @PTR_ERR(i8* noundef %call11) #25
  %conv15 = trunc i64 %call14 to i32
  br label %cleanup

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.0110 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %idxprom = sext i32 %i.0110 to i64
  %opcode = getelementptr %struct.io_uring_restriction, %struct.io_uring_restriction* %2, i64 %idxprom, i32 0
  %3 = load i16, i16* %opcode, align 4
  switch i16 %3, label %if.then59 [
    i16 0, label %sw.bb
    i16 1, label %sw.bb33
    i16 2, label %sw.bb48
    i16 3, label %sw.bb52
  ]

sw.bb:                                            ; preds = %for.body
  %register_op = getelementptr %struct.io_uring_restriction, %struct.io_uring_restriction* %2, i64 %idxprom, i32 1, i32 0
  %4 = load i8, i8* %register_op, align 2
  %cmp23 = icmp ugt i8 %4, 19
  br i1 %cmp23, label %if.then59, label %if.end26

if.end26:                                         ; preds = %sw.bb
  %sh_prom.i = zext i8 %4 to i64
  %shl.i = shl nuw nsw i64 1, %sh_prom.i
  %5 = load i64, i64* %arraydecay, align 8
  %or.i = or i64 %5, %shl.i
  store i64 %or.i, i64* %arraydecay, align 8
  br label %for.inc

sw.bb33:                                          ; preds = %for.body
  %sqe_op = getelementptr %struct.io_uring_restriction, %struct.io_uring_restriction* %2, i64 %idxprom, i32 1, i32 0
  %6 = load i8, i8* %sqe_op, align 2
  %cmp37 = icmp ugt i8 %6, 39
  br i1 %cmp37, label %if.then59, label %if.end40

if.end40:                                         ; preds = %sw.bb33
  %sh_prom.i102 = zext i8 %6 to i64
  %shl.i103 = shl nuw nsw i64 1, %sh_prom.i102
  %7 = load i64, i64* %arraydecay47, align 8
  %or.i104 = or i64 %7, %shl.i103
  store i64 %or.i104, i64* %arraydecay47, align 8
  br label %for.inc

sw.bb48:                                          ; preds = %for.body
  %sqe_flags = getelementptr %struct.io_uring_restriction, %struct.io_uring_restriction* %2, i64 %idxprom, i32 1, i32 0
  %8 = load i8, i8* %sqe_flags, align 2
  store i8 %8, i8* %sqe_flags_allowed, align 16
  br label %for.inc

sw.bb52:                                          ; preds = %for.body
  %sqe_flags55 = getelementptr %struct.io_uring_restriction, %struct.io_uring_restriction* %2, i64 %idxprom, i32 1, i32 0
  %9 = load i8, i8* %sqe_flags55, align 2
  store i8 %9, i8* %sqe_flags_required, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end26, %if.end40, %sw.bb48, %sw.bb52
  %inc = add nuw i32 %i.0110, 1
  %exitcond.not = icmp eq i32 %inc, %nr_args
  br i1 %exitcond.not, label %if.else, label %for.body

if.then59:                                        ; preds = %sw.bb, %sw.bb33, %for.body
  %10 = bitcast %struct.io_restriction* %restrictions to i8*
  %call61 = call i8* @memset(i8* noundef %10, i32 noundef 0, i64 noundef 24) #27
  br label %if.end64

if.else:                                          ; preds = %for.inc, %for.cond.preheader
  store i8 1, i8* %registered, align 2
  br label %if.end64

if.end64:                                         ; preds = %if.else, %if.then59
  %ret.0107 = phi i32 [ 0, %if.else ], [ -22, %if.then59 ]
  call void @kfree(i8* noundef %call11) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end3, %if.end, %entry, %if.end64, %if.then13
  %retval.0 = phi i32 [ %conv15, %if.then13 ], [ %ret.0107, %if.end64 ], [ -77, %entry ], [ -16, %if.end ], [ -22, %if.end3 ], [ -75, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_rsrc(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %size, i32 noundef %type) unnamed_addr #1 {
entry:
  %rr = alloca %struct.io_uring_rsrc_register, align 8
  %0 = bitcast %struct.io_uring_rsrc_register* %rr to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %0, i8 0, i64 32, i1 false), !annotation !14
  %cmp.not = icmp eq i32 %size, 32
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i8* @memset(i8* noundef nonnull %0, i32 noundef 0, i64 noundef 32) #27
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %arg, i64 noundef 32) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  br i1 %tobool.not, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %nr = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 0
  %1 = load i32, i32* %nr, align 8
  %tobool6 = icmp eq i32 %1, 0
  %resv = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 1
  %2 = load i32, i32* %resv, align 4
  %tobool7 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool6, i1 true, i1 %tobool7
  %resv2 = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 2
  %3 = load i64, i64* %resv2, align 8
  %tobool9 = icmp ne i64 %3, 0
  %or.cond40 = select i1 %or.cond, i1 true, i1 %tobool9
  br i1 %or.cond40, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end5
  switch i32 %type, label %cleanup [
    i32 0, label %sw.bb
    i32 1, label %sw.bb23
  ]

sw.bb:                                            ; preds = %if.end11
  %data = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 3
  %4 = load i64, i64* %data, align 8
  %5 = inttoptr i64 %4 to i8*
  %tags = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 4
  %6 = load i64, i64* %tags, align 8
  %7 = inttoptr i64 %6 to i64*
  %call22 = call fastcc i32 @io_sqe_files_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %5, i32 noundef %1, i64* noundef %7) #25
  br label %cleanup

sw.bb23:                                          ; preds = %if.end11
  %data30 = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 3
  %8 = load i64, i64* %data30, align 8
  %9 = inttoptr i64 %8 to i8*
  %tags38 = getelementptr inbounds %struct.io_uring_rsrc_register, %struct.io_uring_rsrc_register* %rr, i64 0, i32 4
  %10 = load i64, i64* %tags38, align 8
  %11 = inttoptr i64 %10 to i64*
  %call39 = call fastcc i32 @io_sqe_buffers_register(%struct.io_ring_ctx* noundef %ctx, i8* noundef %9, i32 noundef %1, i64* noundef %11) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end5, %if.end, %entry, %sw.bb23, %sw.bb
  %retval.0 = phi i32 [ %call39, %sw.bb23 ], [ %call22, %sw.bb ], [ -22, %entry ], [ -14, %if.end ], [ -22, %if.end5 ], [ -22, %if.end11 ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg, i32 noundef %size, i32 noundef %type) unnamed_addr #1 {
entry:
  %up = alloca %struct.io_uring_rsrc_update2, align 8
  %0 = bitcast %struct.io_uring_rsrc_update2* %up to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %0) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %0, i8 0, i64 32, i1 false), !annotation !14
  %cmp.not = icmp eq i32 %size, 32
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %arg, i64 noundef 32) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  br i1 %tobool.not, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %nr = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 4
  %1 = load i32, i32* %nr, align 8
  %tobool4 = icmp eq i32 %1, 0
  %resv = getelementptr inbounds %struct.io_uring_rsrc_update2, %struct.io_uring_rsrc_update2* %up, i64 0, i32 1
  %2 = load i32, i32* %resv, align 4
  %tobool5 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool4, i1 true, i1 %tobool5
  br i1 %or.cond, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end3
  %call9 = call fastcc i32 @__io_register_rsrc_update(%struct.io_ring_ctx* noundef %ctx, i32 noundef %type, %struct.io_uring_rsrc_update2* noundef nonnull %up, i32 noundef %1) #25
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry, %if.end7
  %retval.0 = phi i32 [ %call9, %if.end7 ], [ -22, %entry ], [ -14, %if.end ], [ -22, %if.end3 ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_iowq_aff(i8* noundef %arg, i32 noundef %len) unnamed_addr #1 {
entry:
  %new_mask = alloca [1 x %struct.cpumask], align 8
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %3 = bitcast [1 x %struct.cpumask]* %new_mask to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %3) #26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(32) %3, i8 0, i64 32, i1 false), !annotation !14
  %tobool.not = icmp eq %struct.io_uring_task* %2, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 4
  %4 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool1.not = icmp eq %struct.io_wq* %4, null
  br i1 %tobool1.not, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %arraydecay = getelementptr inbounds [1 x %struct.cpumask], [1 x %struct.cpumask]* %new_mask, i64 0, i64 0
  call fastcc void @cpumask_clear(%struct.cpumask* noundef nonnull %arraydecay) #25
  %5 = icmp ult i32 %len, 32
  %narrow = select i1 %5, i32 %len, i32 32
  %spec.select = zext i32 %narrow to i64
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %3, i8* noundef %arg, i64 noundef %spec.select) #27
  %tobool11.not = icmp eq i64 %call2.i, 0
  br i1 %tobool11.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end
  %6 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %call17 = call i32 @io_wq_cpu_affinity(%struct.io_wq* noundef %6, %struct.cpumask* noundef nonnull %arraydecay) #27
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %lor.lhs.false, %if.end14
  %retval.0 = phi i32 [ %call17, %if.end14 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -14, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %3) #26
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_unregister_iowq_aff() unnamed_addr #1 {
entry:
  %0 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %1 = inttoptr i64 %0 to %struct.task_struct*
  %io_uring = getelementptr inbounds %struct.task_struct, %struct.task_struct* %1, i64 0, i32 85
  %2 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring, align 8
  %tobool.not = icmp eq %struct.io_uring_task* %2, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %2, i64 0, i32 4
  %3 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool1.not = icmp eq %struct.io_wq* %3, null
  br i1 %tobool1.not, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i32 @io_wq_cpu_affinity(%struct.io_wq* noundef nonnull %3, %struct.cpumask* noundef null) #27
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ %call3, %if.end ], [ -22, %lor.lhs.false ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_register_iowq_max_workers(%struct.io_ring_ctx* noundef %ctx, i8* noundef %arg) unnamed_addr #1 {
entry:
  %new_count = alloca i64, align 8, !annotation !14
  %tmpcast = bitcast i64* %new_count to [2 x i32]*, !annotation !14
  %0 = bitcast i64* %new_count to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #26
  store i64 0, i64* %new_count, align 8, !annotation !14
  %arraydecay = bitcast i64* %new_count to i32*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef nonnull %0, i8* noundef %arg, i64 noundef 8) #27
  %tobool.not = icmp eq i64 %call2.i, 0
  br i1 %tobool.not, label %for.body.preheader, label %cleanup112

for.body.preheader:                               ; preds = %entry
  %arrayidx = bitcast i64* %new_count to i32*
  %1 = load i32, i32* %arrayidx, align 8
  %cmp2 = icmp slt i32 %1, 0
  br i1 %cmp2, label %cleanup112, label %for.cond

for.cond:                                         ; preds = %for.body.preheader
  %arrayidx.1 = getelementptr inbounds [2 x i32], [2 x i32]* %tmpcast, i64 0, i64 1
  %2 = load i32, i32* %arrayidx.1, align 4
  %cmp2.1 = icmp slt i32 %2, 0
  br i1 %cmp2.1, label %cleanup112, label %for.cond.1

for.cond.1:                                       ; preds = %for.cond
  %flags = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 0, i32 2
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 2
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %if.else, label %if.then7

if.then7:                                         ; preds = %for.cond.1
  %sq_data = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 5
  %4 = load %struct.io_sq_data*, %struct.io_sq_data** %sq_data, align 32
  %tobool8.not = icmp eq %struct.io_sq_data* %4, null
  br i1 %tobool8.not, label %do.end.thread, label %if.then9

if.then9:                                         ; preds = %if.then7
  %refs = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %4, i64 0, i32 0
  call fastcc void @refcount_inc(%struct.refcount_struct* noundef %refs) #25
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %lock = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %4, i64 0, i32 2
  call void @mutex_lock(%struct.mutex* noundef %lock) #27
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %thread = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %4, i64 0, i32 4
  %5 = load %struct.task_struct*, %struct.task_struct** %thread, align 8
  %tobool11.not = icmp eq %struct.task_struct* %5, null
  br i1 %tobool11.not, label %do.end.thread, label %do.end

if.else:                                          ; preds = %for.cond.1
  %6 = call i64 asm "mrs $0, sp_el0", "=r"() #28, !srcloc !12
  %7 = inttoptr i64 %6 to %struct.task_struct*
  br label %do.end

do.end.thread:                                    ; preds = %if.then9, %if.then7
  %iowq_limits165 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8
  %8 = bitcast [2 x i32]* %iowq_limits165 to i8*
  %call21166 = call i8* @memcpy(i8* noundef %8, i8* noundef nonnull %0, i64 noundef 8) #27
  %iowq_limits_set167 = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 9
  store i8 1, i8* %iowq_limits_set167, align 16
  br label %if.else31

do.end:                                           ; preds = %if.then9, %if.else
  %sqd.0 = phi %struct.io_sq_data* [ null, %if.else ], [ %4, %if.then9 ]
  %.pn = phi %struct.task_struct* [ %7, %if.else ], [ %5, %if.then9 ]
  %tctx.0.in = getelementptr inbounds %struct.task_struct, %struct.task_struct* %.pn, i64 0, i32 85
  %tctx.0 = load %struct.io_uring_task*, %struct.io_uring_task** %tctx.0.in, align 8
  %iowq_limits = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8
  %9 = bitcast [2 x i32]* %iowq_limits to i8*
  %call21 = call i8* @memcpy(i8* noundef %9, i8* noundef nonnull %0, i64 noundef 8) #27
  %iowq_limits_set = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 9
  store i8 1, i8* %iowq_limits_set, align 16
  %tobool22.not = icmp eq %struct.io_uring_task* %tctx.0, null
  br i1 %tobool22.not, label %if.else31, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end
  %io_wq = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %tctx.0, i64 0, i32 4
  %10 = load %struct.io_wq*, %struct.io_wq** %io_wq, align 8
  %tobool23.not = icmp eq %struct.io_wq* %10, null
  br i1 %tobool23.not, label %if.else31, label %if.then24

if.then24:                                        ; preds = %land.lhs.true
  %call27 = call i32 @io_wq_max_workers(%struct.io_wq* noundef nonnull %10, i32* noundef nonnull %arraydecay) #27
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %if.end34, label %err

if.else31:                                        ; preds = %do.end.thread, %land.lhs.true, %do.end
  %sqd.0170 = phi %struct.io_sq_data* [ %4, %do.end.thread ], [ %sqd.0, %land.lhs.true ], [ %sqd.0, %do.end ]
  %call33 = call i8* @memset(i8* noundef nonnull %0, i32 noundef 0, i64 noundef 8) #27
  br label %if.end34

if.end34:                                         ; preds = %if.then24, %if.else31
  %sqd.0169 = phi %struct.io_sq_data* [ %sqd.0, %if.then24 ], [ %sqd.0170, %if.else31 ]
  %tobool35.not = icmp eq %struct.io_sq_data* %sqd.0169, null
  br i1 %tobool35.not, label %if.end38, label %if.then36

if.then36:                                        ; preds = %if.end34
  %lock37 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd.0169, i64 0, i32 2
  call void @mutex_unlock(%struct.mutex* noundef %lock37) #27
  call fastcc void @io_put_sq_data(%struct.io_sq_data* noundef nonnull %sqd.0169) #25
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end34
  %call2.i162 = call fastcc i64 @_copy_to_user(i8* noundef %arg, i8* noundef nonnull %0, i64 noundef 8) #27
  %tobool41.not = icmp ne i64 %call2.i162, 0
  %tobool35.not.not = xor i1 %tobool35.not, true
  %brmerge = select i1 %tobool41.not, i1 true, i1 %tobool35.not.not
  %.mux = select i1 %tobool41.not, i32 -14, i32 0
  br i1 %brmerge, label %cleanup112, label %if.end46

if.end46:                                         ; preds = %if.end38
  %tctx_list = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 6
  %11 = bitcast %struct.list_head* %tctx_list to %struct.io_tctx_node**
  %node.0177 = load %struct.io_tctx_node*, %struct.io_tctx_node** %11, align 8
  %ctx_node178 = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.0177, i64 0, i32 0
  %cmp52.not179 = icmp eq %struct.list_head* %ctx_node178, %tctx_list
  br i1 %cmp52.not179, label %cleanup112, label %for.body54.preheader

for.body54.preheader:                             ; preds = %if.end46
  %arrayidx89 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8, i64 0
  %arrayidx89.1 = getelementptr %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 14, i32 8, i64 1
  br label %for.body54

for.body54:                                       ; preds = %for.body54.preheader, %cleanup
  %node.0180 = phi %struct.io_tctx_node* [ %node.0, %cleanup ], [ %node.0177, %for.body54.preheader ]
  %task = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.0180, i64 0, i32 1
  %12 = load %struct.task_struct*, %struct.task_struct** %task, align 8
  %io_uring56 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %12, i64 0, i32 85
  %13 = load %struct.io_uring_task*, %struct.io_uring_task** %io_uring56, align 8
  %io_wq57 = getelementptr inbounds %struct.io_uring_task, %struct.io_uring_task* %13, i64 0, i32 4
  %14 = load %struct.io_wq*, %struct.io_wq** %io_wq57, align 8
  %tobool58.not = icmp eq %struct.io_wq* %14, null
  br i1 %tobool58.not, label %if.then69, label %for.body86.preheader, !prof !24

for.body86.preheader:                             ; preds = %for.body54
  %15 = load i32, i32* %arrayidx89, align 4
  store i32 %15, i32* %arrayidx, align 8
  %16 = load i32, i32* %arrayidx89.1, align 4
  store i32 %16, i32* %arrayidx.1, align 4
  %call97 = call i32 @io_wq_max_workers(%struct.io_wq* noundef nonnull %14, i32* noundef nonnull %arraydecay) #27
  br label %cleanup

if.then69:                                        ; preds = %for.body54
  call void asm sideeffect ".pushsection __bug_table,\22aw\22; .align 2; 14470: .long 14471f - 14470b; .pushsection .rodata.str,\22aMS\22,@progbits,1; 14472: .string \22fs/io_uring.c\22; .popsection; .long 14472b - 14470b; .short 10715; .short (1 << 0)|((1 << 1) | ((9) << 8)); .popsection; 14471: brk 0x800", ""() #26, !srcloc !126
  br label %cleanup

cleanup:                                          ; preds = %if.then69, %for.body86.preheader
  %17 = bitcast %struct.io_tctx_node* %node.0180 to %struct.io_tctx_node**
  %node.0 = load %struct.io_tctx_node*, %struct.io_tctx_node** %17, align 8
  %ctx_node = getelementptr inbounds %struct.io_tctx_node, %struct.io_tctx_node* %node.0, i64 0, i32 0
  %cmp52.not = icmp eq %struct.list_head* %ctx_node, %tctx_list
  br i1 %cmp52.not, label %cleanup112, label %for.body54

err:                                              ; preds = %if.then24
  %tobool108.not = icmp eq %struct.io_sq_data* %sqd.0, null
  br i1 %tobool108.not, label %cleanup112, label %if.then109

if.then109:                                       ; preds = %err
  %lock110 = getelementptr inbounds %struct.io_sq_data, %struct.io_sq_data* %sqd.0, i64 0, i32 2
  call void @mutex_unlock(%struct.mutex* noundef %lock110) #27
  call fastcc void @io_put_sq_data(%struct.io_sq_data* noundef nonnull %sqd.0) #25
  br label %cleanup112

cleanup112:                                       ; preds = %cleanup, %for.body.preheader, %for.cond, %if.end46, %if.end38, %err, %if.then109, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %.mux, %if.end38 ], [ %call27, %if.then109 ], [ %call27, %err ], [ 0, %if.end46 ], [ -22, %for.cond ], [ -22, %for.body.preheader ], [ 0, %cleanup ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #26
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_reinit(%struct.percpu_ref* noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly
define internal fastcc void @reinit_completion(%struct.completion* nocapture noundef writeonly %x) unnamed_addr #10 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i64 0, i32 0
  store i32 0, i32* %done, align 8
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @wait_for_completion_interruptible(%struct.completion* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @io_refs_resurrect(%struct.percpu_ref* noundef %ref, %struct.completion* noundef %compl) unnamed_addr #1 {
entry:
  %call = call fastcc i1 @percpu_ref_tryget(%struct.percpu_ref* noundef %ref) #25
  br i1 %call, label %if.then2.critedge, label %if.then

if.then:                                          ; preds = %entry
  call void @wait_for_completion(%struct.completion* noundef %compl) #27
  call void @percpu_ref_resurrect(%struct.percpu_ref* noundef %ref) #27
  br label %if.end3

if.then2.critedge:                                ; preds = %entry
  call void @percpu_ref_resurrect(%struct.percpu_ref* noundef %ref) #27
  call fastcc void @percpu_ref_put(%struct.percpu_ref* noundef %ref) #25
  br label %if.end3

if.end3:                                          ; preds = %if.then, %if.then2.critedge
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_resurrect(%struct.percpu_ref* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_rsrc_data_alloc(%struct.io_ring_ctx* noundef %ctx, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)* noundef %do_put, i64* noundef %utags, i32 noundef %nr, %struct.io_rsrc_data** nocapture noundef writeonly %pdata) unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kzalloc(i64 noundef 80, i32 noundef 3264) #25
  %0 = bitcast i8* %call to %struct.io_rsrc_data*
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup18, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %nr to i64
  %mul = shl nuw nsw i64 %conv, 3
  %call1 = call fastcc i8** @io_alloc_page_table(i64 noundef %mul) #25
  %tags = getelementptr inbounds i8, i8* %call, i64 8
  %1 = bitcast i8* %tags to i8***
  store i8** %call1, i8*** %1, align 8
  %tobool3.not = icmp eq i8** %call1, null
  br i1 %tobool3.not, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @kfree(i8* noundef nonnull %call) #27
  br label %cleanup18

if.end5:                                          ; preds = %if.end
  %nr6 = getelementptr inbounds i8, i8* %call, i64 16
  %2 = bitcast i8* %nr6 to i32*
  store i32 %nr, i32* %2, align 8
  %ctx7 = bitcast i8* %call to %struct.io_ring_ctx**
  store %struct.io_ring_ctx* %ctx, %struct.io_ring_ctx** %ctx7, align 8
  %do_put8 = getelementptr inbounds i8, i8* %call, i64 24
  %3 = bitcast i8* %do_put8 to void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)**
  store void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)* %do_put, void (%struct.io_ring_ctx*, %struct.io_rsrc_put*)** %3, align 8
  %tobool9.not = icmp ne i64* %utags, null
  %cmp42 = icmp ne i32 %nr, 0
  %or.cond = and i1 %tobool9.not, %cmp42
  br i1 %or.cond, label %for.body, label %if.end17

for.cond:                                         ; preds = %for.body
  %exitcond.not = icmp eq i64 %indvars.iv.next, %conv
  br i1 %exitcond.not, label %if.end17, label %for.body

for.body:                                         ; preds = %if.end5, %for.cond
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond ], [ 0, %if.end5 ]
  %4 = trunc i64 %indvars.iv to i32
  %call12 = call fastcc i64* @io_get_tag_slot(%struct.io_rsrc_data* noundef nonnull %0, i32 noundef %4) #25
  %5 = bitcast i64* %call12 to i8*
  %arrayidx = getelementptr i64, i64* %utags, i64 %indvars.iv
  %6 = bitcast i64* %arrayidx to i8*
  %call2.i = call fastcc i64 @_copy_from_user(i8* noundef %5, i8* noundef %6, i64 noundef 8) #27
  %tobool14.not = icmp eq i64 %call2.i, 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br i1 %tobool14.not, label %for.cond, label %fail

if.end17:                                         ; preds = %for.cond, %if.end5
  %refs = getelementptr inbounds i8, i8* %call, i64 32
  %counter.i = bitcast i8* %refs to i32*
  store volatile i32 1, i32* %counter.i, align 4
  %done = getelementptr inbounds i8, i8* %call, i64 40
  %7 = bitcast i8* %done to %struct.completion*
  call fastcc void @init_completion(%struct.completion* noundef %7) #25
  %8 = bitcast %struct.io_rsrc_data** %pdata to i8**
  store i8* %call, i8** %8, align 8
  br label %cleanup18

fail:                                             ; preds = %for.body
  call fastcc void @io_rsrc_data_free(%struct.io_rsrc_data* noundef nonnull %0) #25
  br label %cleanup18

cleanup18:                                        ; preds = %entry, %fail, %if.end17, %if.then4
  %retval.0 = phi i32 [ -14, %fail ], [ 0, %if.end17 ], [ -12, %if.then4 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_rsrc_buf_put(%struct.io_ring_ctx* nocapture noundef readonly %ctx, %struct.io_rsrc_put* nocapture noundef %prsrc) #1 {
entry:
  %0 = getelementptr inbounds %struct.io_rsrc_put, %struct.io_rsrc_put* %prsrc, i64 0, i32 2
  %buf = bitcast %union.anon.38* %0 to %struct.io_mapped_ubuf**
  call fastcc void @io_buffer_unmap(%struct.io_ring_ctx* noundef %ctx, %struct.io_mapped_ubuf** noundef %buf) #25
  store %struct.io_mapped_ubuf* null, %struct.io_mapped_ubuf** %buf, align 8
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_buffers_map_alloc(%struct.io_ring_ctx* nocapture noundef writeonly %ctx, i32 noundef %nr_args) unnamed_addr #1 {
entry:
  %conv = zext i32 %nr_args to i64
  %call = call fastcc i8* @kcalloc(i64 noundef %conv, i32 noundef 3264) #25
  %user_bufs = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 10
  %0 = bitcast %struct.io_mapped_ubuf*** %user_bufs to i8**
  store i8* %call, i8** %0, align 32
  %tobool.not = icmp eq i8* %call, null
  %cond = select i1 %tobool.not, i32 -12, i32 0
  ret i32 %cond
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8** @io_alloc_page_table(i64 noundef %size) unnamed_addr #1 {
entry:
  %sub = add i64 %size, 4095
  %div = lshr i64 %sub, 12
  %conv1 = and i64 %div, 4294967295
  %call = call fastcc i8* @kcalloc(i64 noundef %conv1, i32 noundef 4197568) #25
  %0 = bitcast i8* %call to i8**
  %tobool.not = icmp eq i8* %call, null
  br i1 %tobool.not, label %cleanup15, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %conv = trunc i64 %div to i32
  %cmp42.not = icmp eq i32 %conv, 0
  br i1 %cmp42.not, label %cleanup15, label %for.body.preheader

for.body.preheader:                               ; preds = %for.cond.preheader
  %wide.trip.count = and i64 %div, 4294967295
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %size.addr.044 = phi i64 [ %size, %for.body.preheader ], [ %sub14, %for.inc ]
  %cmp3 = icmp ult i64 %size.addr.044, 4096
  %cond = select i1 %cmp3, i64 %size.addr.044, i64 4096
  %call7 = call fastcc i8* @kzalloc(i64 noundef %cond, i32 noundef 4197568) #25
  %arrayidx = getelementptr i8*, i8** %0, i64 %indvars.iv
  store i8* %call7, i8** %arrayidx, align 8
  %tobool10.not = icmp eq i8* %call7, null
  br i1 %tobool10.not, label %cleanup.thread, label %for.inc

cleanup.thread:                                   ; preds = %for.body
  call fastcc void @io_free_page_table(i8** noundef nonnull %0, i64 noundef %size) #25
  br label %cleanup15

for.inc:                                          ; preds = %for.body
  %sub14 = sub i64 %size.addr.044, %cond
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %cleanup15, label %for.body

cleanup15:                                        ; preds = %for.inc, %for.cond.preheader, %cleanup.thread, %entry
  %retval.2 = phi i8** [ null, %entry ], [ null, %cleanup.thread ], [ %0, %for.cond.preheader ], [ %0, %for.inc ]
  ret i8** %retval.2
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kcalloc(i64 noundef %n, i32 noundef %flags) unnamed_addr #1 {
entry:
  %or = or i32 %flags, 256
  %call = call fastcc i8* @kmalloc_array(i64 noundef %n, i32 noundef %or) #25
  ret i8* %call
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kmalloc_array(i64 noundef %n, i32 noundef %flags) unnamed_addr #1 {
entry:
  %0 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %n, i64 8)
  %1 = extractvalue { i64, i1 } %0, 1
  br i1 %1, label %cleanup, label %if.end8, !prof !24

if.end8:                                          ; preds = %entry
  %2 = extractvalue { i64, i1 } %0, 0
  %call9 = call noalias align 128 i8* @__kmalloc(i64 noundef %2, i32 noundef %flags) #27
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end8
  %retval.0 = phi i8* [ %call9, %if.end8 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @io_rsrc_ref_quiesce(%struct.io_rsrc_data* noundef %data, %struct.io_ring_ctx* noundef %ctx) unnamed_addr #1 {
entry:
  %quiesce = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 6
  %0 = load i8, i8* %quiesce, align 8, !range !18
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  store i8 1, i8* %quiesce, align 8
  %refs = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 4
  %uring_lock = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 1, i32 0
  %rsrc_put_work = getelementptr inbounds %struct.io_ring_ctx, %struct.io_ring_ctx* %ctx, i64 0, i32 13, i32 4
  %done = getelementptr inbounds %struct.io_rsrc_data, %struct.io_rsrc_data* %data, i64 0, i32 5
  br label %do.body

do.body:                                          ; preds = %if.end13, %if.end
  %call = call fastcc i32 @io_rsrc_node_switch_start(%struct.io_ring_ctx* noundef %ctx) #25
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %if.end4, label %do.end

if.end4:                                          ; preds = %do.body
  call fastcc void @io_rsrc_node_switch(%struct.io_ring_ctx* noundef %ctx, %struct.io_rsrc_data* noundef %data) #25
  %call.i.i.i.i = call fastcc i32 @__ll_sc_atomic_sub_return(%struct.atomic_t* noundef %refs) #27
  %cmp.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.i.i, label %do.end, label %if.end7

if.end7:                                          ; preds = %if.end4
  call void @mutex_unlock(%struct.mutex* noundef %uring_lock) #27
  %call8 = call i1 @flush_delayed_work(%struct.delayed_work* noundef %rsrc_put_work) #27
  %call9 = call i32 @wait_for_completion_interruptible(%struct.completion* noundef %done) #27
  %tobool10.not = icmp eq i32 %call9, 0
  br i1 %tobool10.not, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  br label %do.end

if.end13:                                         ; preds = %if.end7
  call fastcc void @__ll_sc_atomic_add(%struct.atomic_t* noundef %refs) #27
  %call16 = call i1 @flush_delayed_work(%struct.delayed_work* noundef %rsrc_put_work) #27
  call fastcc void @reinit_completion(%struct.completion* noundef %done) #25
  %call18 = call fastcc i32 @io_run_task_work_sig() #25
  call void @mutex_lock(%struct.mutex* noundef %uring_lock) #27
  %cmp = icmp sgt i32 %call18, -1
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %if.end4, %do.body, %if.end13, %if.then11
  %ret.0 = phi i32 [ 0, %if.then11 ], [ %call18, %if.end13 ], [ 0, %if.end4 ], [ %call, %do.body ]
  store i8 0, i8* %quiesce, align 8
  br label %cleanup

cleanup:                                          ; preds = %entry, %do.end
  %retval.0 = phi i32 [ %ret.0, %do.end ], [ -6, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal void @io_rsrc_file_put(%struct.io_ring_ctx* nocapture noundef readnone %ctx, %struct.io_rsrc_put* nocapture noundef readonly %prsrc) #1 {
entry:
  %0 = getelementptr inbounds %struct.io_rsrc_put, %struct.io_rsrc_put* %prsrc, i64 0, i32 2
  %file1 = bitcast %union.anon.38* %0 to %struct.file**
  %1 = load %struct.file*, %struct.file** %file1, align 8
  call void @fput(%struct.file* noundef %1) #27
  ret void
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i1 @io_alloc_file_tables(%struct.io_file_table* nocapture noundef writeonly %table, i32 noundef %nr_files) unnamed_addr #1 {
entry:
  %conv = zext i32 %nr_files to i64
  %call = call fastcc i8* @kvcalloc(i64 noundef %conv) #25
  %0 = bitcast %struct.io_file_table* %table to i8**
  store i8* %call, i8** %0, align 8
  %tobool = icmp ne i8* %call, null
  ret i1 %tobool
}

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i8* @kvcalloc(i64 noundef %n) unnamed_addr #1 {
entry:
  %call = call fastcc i8* @kvmalloc_array(i64 noundef %n, i32 noundef 4197824) #25
  ret i8* %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.eventfd_ctx* @eventfd_ctx_fdget(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @memchr_inv(i8* noundef, i32 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc i32 @xa_alloc_cyclic(%struct.xarray* noundef %xa, i32* noundef %id, i8* noundef %entry1, i32* noundef %next) unnamed_addr #1 {
entry:
  %rlock.i = getelementptr inbounds %struct.xarray, %struct.xarray* %xa, i64 0, i32 0, i32 0, i32 0
  call fastcc void @__raw_spin_lock(%struct.raw_spinlock* noundef %rlock.i) #27
  %call = call i32 @__xa_alloc_cyclic(%struct.xarray* noundef %xa, i32* noundef %id, i8* noundef %entry1, i64 65535, i32* noundef %next, i32 noundef 3264) #27
  call fastcc void @__raw_spin_unlock(%struct.raw_spinlock* noundef %rlock.i) #27
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__xa_alloc_cyclic(%struct.xarray* noundef, i32* noundef, i8* noundef, i64, i32* noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i8* @memdup_user(i8* noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @cpumask_clear(%struct.cpumask* noundef %dstp) unnamed_addr #1 {
entry:
  %arraydecay = getelementptr inbounds %struct.cpumask, %struct.cpumask* %dstp, i64 0, i32 0, i64 0
  call fastcc void @bitmap_zero(i64* noundef %arraydecay) #25
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @io_wq_cpu_affinity(%struct.io_wq* noundef, %struct.cpumask* noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid
define internal fastcc void @bitmap_zero(i64* noundef %dst) unnamed_addr #1 {
entry:
  %0 = bitcast i64* %dst to i8*
  %call = call i8* @memset(i8* noundef %0, i32 noundef 0, i64 noundef 32) #27
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local %struct.kmem_cache* @kmem_cache_create(i8* noundef, i32 noundef, i32 noundef, i32 noundef, void (i8*)* noundef) local_unnamed_addr #4

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.uadd.sat.i64(i64, i64) #24

attributes #0 = { mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readnone willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #1 = { noinline nounwind null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #2 = { argmemonly mustprogress nofree nosync nounwind willreturn }
attributes #3 = { mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #4 = { null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" }
attributes #5 = { cold noinline nounwind null_pointer_is_valid optsize "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #6 = { argmemonly mustprogress nofree nounwind willreturn writeonly }
attributes #7 = { nofree noinline norecurse nosync nounwind null_pointer_is_valid readonly "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #8 = { mustprogress nofree noinline norecurse nounwind null_pointer_is_valid willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #9 = { nofree noinline norecurse nounwind null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #10 = { mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn writeonly "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #11 = { mustprogress nofree nosync nounwind readnone speculatable willreturn }
attributes #12 = { mustprogress nofree noinline norecurse nosync nounwind null_pointer_is_valid willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #13 = { nofree noinline nounwind null_pointer_is_valid readonly "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #14 = { nofree nounwind readonly }
attributes #15 = { argmemonly mustprogress nofree nounwind willreturn }
attributes #16 = { nofree noinline norecurse nosync nounwind null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #17 = { cold null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" }
attributes #18 = { mustprogress nofree noinline nosync nounwind null_pointer_is_valid readonly willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #19 = { mustprogress nofree noinline nosync nounwind null_pointer_is_valid readnone willreturn "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #20 = { nofree noinline norecurse nosync nounwind null_pointer_is_valid writeonly "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #21 = { mustprogress nofree noinline nosync nounwind null_pointer_is_valid willreturn writeonly "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #22 = { noinline noreturn nounwind null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" "warn-stack-size"="2048" }
attributes #23 = { noreturn null_pointer_is_valid "disable-tail-calls"="true" "frame-pointer"="non-leaf" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+v8a,-aes,-crypto,-fp-armv8,-neon,-sha2" }
attributes #24 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #25 = { nobuiltin "no-builtins" }
attributes #26 = { nounwind }
attributes #27 = { nobuiltin nounwind "no-builtins" }
attributes #28 = { nounwind readnone }
attributes #29 = { nounwind readonly }
attributes #30 = { cold nobuiltin nounwind "no-builtins" }
attributes #31 = { nobuiltin nounwind readnone willreturn "no-builtins" }
attributes #32 = { nobuiltin noreturn nounwind "no-builtins" }

!llvm.named.register.sp = !{!0}
!llvm.module.flags = !{!1, !2, !3, !4, !5, !6}
!llvm.ident = !{!7}

!0 = !{!"sp"}
!1 = !{i32 1, !"wchar_size", i32 2}
!2 = !{i32 1, !"branch-target-enforcement", i32 0}
!3 = !{i32 1, !"sign-return-address", i32 0}
!4 = !{i32 1, !"sign-return-address-all", i32 0}
!5 = !{i32 1, !"sign-return-address-with-bkey", i32 0}
!6 = !{i32 7, !"frame-pointer", i32 1}
!7 = !{!"clang version 14.0.0"}
!8 = !{!"branch_weights", i32 2000, i32 1}
!9 = !{i64 2158936677}
!10 = !{i64 2158938327}
!11 = !{i64 2158939983}
!12 = !{i64 1680181}
!13 = !{i64 2159013515}
!14 = !{!"auto-init"}
!15 = !{i64 2147996586, i64 2147997102, i64 2147997132, i64 2147997159, i64 2147997193, i64 2147997223}
!16 = !{i64 2150923031}
!17 = !{i64 2148014332, i64 2148015006, i64 2148015036, i64 2148015068, i64 2148015102, i64 2148015138, i64 2148015163}
!18 = !{i8 0, i8 2}
!19 = !{i64 2149046467}
!20 = !{i64 2149868916}
!21 = !{i64 2148092448, i64 2148092481, i64 2148092534, i64 2148092593, i64 2148092627, i64 2148092682, i64 2148092711, i64 2148092731}
!22 = !{i64 2149876197}
!23 = !{i64 2149668427}
!24 = !{!"branch_weights", i32 1, i32 2000}
!25 = !{i64 2158386581}
!26 = !{i64 2158282999}
!27 = !{i64 2158333495}
!28 = !{i64 2158346331}
!29 = !{i64 2148065666, i64 2148066177, i64 2148066207, i64 2148066233, i64 2148066265, i64 2148066294}
!30 = !{i64 2148007159, i64 2148007807, i64 2148007837, i64 2148007869, i64 2148007903, i64 2148007939, i64 2148007964}
!31 = !{i64 2158375470}
!32 = !{i64 2152757023}
!33 = !{i64 2152757835}
!34 = !{i64 2149468007, i64 2149468048, i64 2149468104, i64 2149468156}
!35 = !{i64 2149442061, i64 2149442108, i64 2149442114, i64 2149442151, i64 2149442169, i64 2149443096, i64 2149443144, i64 2149443192, i64 2149443255, i64 2149443304, i64 2149442247, i64 2149442272, i64 2149442298, i64 2149442304, i64 2149442341, i64 2149442347, i64 2149442397, i64 2149442443, i64 2149442476}
!36 = !{i64 2150102614}
!37 = !{i64 2148051853, i64 2148052501, i64 2148052531, i64 2148052562, i64 2148052594, i64 2148052629, i64 2148052654}
!38 = !{i64 2150102831}
!39 = !{i64 2149853915}
!40 = !{i64 2149419742, i64 2149419789, i64 2149419795, i64 2149419832, i64 2149419850, i64 2149421161, i64 2149421209, i64 2149421257, i64 2149421320, i64 2149421369, i64 2149419928, i64 2149419953, i64 2149419979, i64 2149419985, i64 2149420827, i64 2149420867, i64 2149420885, i64 2149420917, i64 2149420945, i64 2149420999, i64 2149421019, i64 2149421116, i64 2149420008, i64 2149420022, i64 2149420028, i64 2149420078, i64 2149420124, i64 2149420157}
!41 = !{i64 2149421921, i64 2149421968, i64 2149421974, i64 2149422011, i64 2149422029, i64 2149422972, i64 2149423020, i64 2149423068, i64 2149423131, i64 2149423180, i64 2149422107, i64 2149422132, i64 2149422158, i64 2149422164, i64 2149422201, i64 2149422207, i64 2149422257, i64 2149422303, i64 2149422336}
!42 = !{i64 2149414039, i64 2149414086, i64 2149414092, i64 2149414129, i64 2149414147, i64 2149415488, i64 2149415536, i64 2149415584, i64 2149415647, i64 2149415696, i64 2149414225, i64 2149414250, i64 2149414276, i64 2149414282, i64 2149415154, i64 2149415194, i64 2149415212, i64 2149415244, i64 2149415272, i64 2149415326, i64 2149415346, i64 2149415443, i64 2149414305, i64 2149414319, i64 2149414325, i64 2149414375, i64 2149414421, i64 2149414454}
!43 = !{i64 2149879758}
!44 = !{i64 2149425755, i64 2149425802, i64 2149425808, i64 2149425845, i64 2149425863, i64 2149431235, i64 2149431283, i64 2149431331, i64 2149431394, i64 2149431443, i64 2149425941, i64 2149425966, i64 2149425992, i64 2149425998, i64 2149430901, i64 2149430941, i64 2149430959, i64 2149430991, i64 2149431019, i64 2149431073, i64 2149431093, i64 2149431190, i64 2149426021, i64 2149426035, i64 2149426041, i64 2149426091, i64 2149426137, i64 2149426170}
!45 = !{i64 2149858208}
!46 = !{i64 2149883061}
!47 = !{i64 2149404583, i64 2149404630, i64 2149404636, i64 2149404673, i64 2149404691, i64 2149406031, i64 2149406079, i64 2149406127, i64 2149406190, i64 2149406239, i64 2149404769, i64 2149404794, i64 2149404820, i64 2149404826, i64 2149405697, i64 2149405737, i64 2149405755, i64 2149405787, i64 2149405815, i64 2149405869, i64 2149405889, i64 2149405986, i64 2149404849, i64 2149404863, i64 2149404869, i64 2149404919, i64 2149404965, i64 2149404998}
!48 = !{i64 2150003740}
!49 = !{!"branch_weights", i32 1, i32 4000, i32 1}
!50 = !{i64 2158324231}
!51 = !{i64 2158325571}
!52 = !{i64 2158327273}
!53 = !{i64 2152745724}
!54 = !{i64 2152746536}
!55 = !{i64 2148109656, i64 2148109689, i64 2148109741, i64 2148109800, i64 2148109834, i64 2148109890, i64 2148109919, i64 2148109946}
!56 = !{i64 2148111306, i64 2148111339, i64 2148111390, i64 2148111446, i64 2148111479, i64 2148111534, i64 2148111563, i64 2148111590}
!57 = !{i64 482561, i64 482579}
!58 = !{i64 2147969763}
!59 = !{i64 4248262, i64 4248345, i64 4248569, i64 4248789, i64 4248812}
!60 = !{i64 4252964, i64 4252988}
!61 = !{i64 2151805748}
!62 = !{i64 2158968822}
!63 = !{i64 2158380219}
!64 = !{i64 2158976970}
!65 = !{i64 2158979229}
!66 = !{i64 2158983344}
!67 = !{i64 2148076236, i64 2148076757, i64 2148076787, i64 2148076813, i64 2148076845, i64 2148076874}
!68 = !{i64 2158902273}
!69 = !{i64 2158900592}
!70 = !{i64 2158961065}
!71 = !{i64 2158966799}
!72 = !{i64 2158968470}
!73 = !{i64 2159009307}
!74 = !{i64 2159010973}
!75 = !{i64 2158911391}
!76 = !{i64 2158908015}
!77 = !{i64 2158909721}
!78 = !{i64 2148051005, i64 2148051519, i64 2148051549, i64 2148051575, i64 2148051607, i64 2148051636}
!79 = !{i64 2158452471}
!80 = !{i64 2151984127}
!81 = !{i64 2151987988}
!82 = !{i64 2151988830}
!83 = !{i64 2151990084}
!84 = !{i64 2151997968}
!85 = !{i64 2151998810}
!86 = !{i64 2152000062}
!87 = !{i64 2149466951, i64 2149466993, i64 2149467052, i64 2149467105}
!88 = !{i64 2158788669}
!89 = !{i64 2151965767}
!90 = !{i64 2151969190}
!91 = !{i64 2151970032}
!92 = !{i64 2151971218}
!93 = !{i64 2158288339}
!94 = !{i64 2158290099}
!95 = !{i64 2158284837}
!96 = !{i64 2158286501}
!97 = !{i32 0, i32 8}
!98 = !{i64 2158737243}
!99 = !{i64 2158281012}
!100 = !{i64 2158766533}
!101 = !{i64 2158896593}
!102 = !{i64 2158898263}
!103 = distinct !{!103, !104}
!104 = !{!"llvm.loop.peeled.count", i32 1}
!105 = !{i64 2148037272, i64 2148037786, i64 2148037816, i64 2148037842, i64 2148037874, i64 2148037903}
!106 = !{i64 2158321912}
!107 = !{i64 2158127262}
!108 = !{i64 2148006307, i64 2148006823, i64 2148006853, i64 2148006880, i64 2148006914, i64 2148006944}
!109 = !{i64 2152740231}
!110 = !{i64 2152741043}
!111 = !{i64 2158380995}
!112 = !{i64 2158816488}
!113 = !{i64 2148002550, i64 2148003214, i64 2148003244, i64 2148003276, i64 2148003310, i64 2148003345, i64 2148003370}
!114 = !{!"branch_weights", i32 4001, i32 4000000}
!115 = !{i64 2158410195}
!116 = !{i64 2151909055}
!117 = !{i64 2148077089, i64 2148077751, i64 2148077781, i64 2148077812, i64 2148077844, i64 2148077879, i64 2148077904}
!118 = !{i32 0, i32 33}
!119 = !{i64 0, i64 65}
!120 = distinct !{!120, !121}
!121 = !{!"llvm.loop.isvectorized", i32 1}
!122 = distinct !{!122, !121}
!123 = !{i64 2148131464, i64 2148131496, i64 2148131540, i64 2148131587, i64 2148131613}
!124 = !{i64 2158948199}
!125 = !{i64 2149194553}
!126 = !{i64 2159072672}
